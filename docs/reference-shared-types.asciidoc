[[reference-shared-types]]
== Shared types


[discrete]
=== AcknowledgedResponseBase

SHARED TYPE!
[pass]
++++
<pre>
++++
interface AcknowledgedResponseBase {
  /** @property acknowledged For a successful response, this value is always true. On failure, an exception is returned instead. */
  acknowledged: boolean
}
[pass]
++++
</pre>
++++

[discrete]
=== AggregateName

SHARED TYPE!
[pass]
++++
<pre>
++++
type AggregateName = string
[pass]
++++
</pre>
++++

[discrete]
=== BulkIndexByScrollFailure

SHARED TYPE!
[pass]
++++
<pre>
++++
interface BulkIndexByScrollFailure {
  cause: <<ErrorCause>>
  id: <<Id>>
  index: <<IndexName>>
  status: number
  type: string
}
[pass]
++++
</pre>
++++

[discrete]
=== BulkStats

SHARED TYPE!
[pass]
++++
<pre>
++++
interface BulkStats {
  total_operations: number
  total_time?: <<Duration>>
  total_time_in_millis: <<DurationValue>><<<UnitMillis>>>
  total_size?: <<ByteSize>>
  total_size_in_bytes: number
  avg_time?: <<Duration>>
  avg_time_in_millis: <<DurationValue>><<<UnitMillis>>>
  avg_size?: <<ByteSize>>
  avg_size_in_bytes: number
}
[pass]
++++
</pre>
++++

[discrete]
=== ByteSize

SHARED TYPE!
[pass]
++++
<pre>
++++
type ByteSize = number | string
[pass]
++++
</pre>
++++

[discrete]
=== Bytes

SHARED TYPE!
[pass]
++++
<pre>
++++
type Bytes = 'b' | 'kb' | 'mb' | 'gb' | 'tb' | 'pb'
[pass]
++++
</pre>
++++

[discrete]
=== CategoryId

SHARED TYPE!
[pass]
++++
<pre>
++++
type CategoryId = string
[pass]
++++
</pre>
++++

[discrete]
=== ClusterAlias

SHARED TYPE!
[pass]
++++
<pre>
++++
type ClusterAlias = string
[pass]
++++
</pre>
++++

[discrete]
=== ClusterDetails

SHARED TYPE!
[pass]
++++
<pre>
++++
interface ClusterDetails {
  status: <<ClusterSearchStatus>>
  indices: string
  took?: <<DurationValue>><<<UnitMillis>>>
  timed_out: boolean
  _shards?: <<ShardStatistics>>
  failures?: <<ShardFailure>>[]
}
[pass]
++++
</pre>
++++

[discrete]
=== ClusterInfoTarget

SHARED TYPE!
[pass]
++++
<pre>
++++
type ClusterInfoTarget = '_all' | 'http' | 'ingest' | 'thread_pool' | 'script'
[pass]
++++
</pre>
++++

[discrete]
=== ClusterInfoTargets

SHARED TYPE!
[pass]
++++
<pre>
++++
type ClusterInfoTargets = <<ClusterInfoTarget>> | <<ClusterInfoTarget>>[]
[pass]
++++
</pre>
++++

[discrete]
=== ClusterSearchStatus

SHARED TYPE!
[pass]
++++
<pre>
++++
type ClusterSearchStatus = 'running' | 'successful' | 'partial' | 'skipped' | 'failed'
[pass]
++++
</pre>
++++

[discrete]
=== ClusterStatistics

SHARED TYPE!
[pass]
++++
<pre>
++++
interface ClusterStatistics {
  skipped: number
  successful: number
  total: number
  running: number
  partial: number
  failed: number
  details?: Record<<<ClusterAlias>>, <<ClusterDetails>>>
}
[pass]
++++
</pre>
++++

[discrete]
=== CompletionStats

SHARED TYPE!
[pass]
++++
<pre>
++++
interface CompletionStats {
  /** @property size_in_bytes Total amount, in bytes, of memory used for completion across all shards assigned to selected nodes. */
  size_in_bytes: number
  /** @property size Total amount of memory used for completion across all shards assigned to selected nodes. */
  size?: <<ByteSize>>
  fields?: Record<<<Field>>, <<FieldSizeUsage>>>
}
[pass]
++++
</pre>
++++

[discrete]
=== Conflicts

SHARED TYPE!
[pass]
++++
<pre>
++++
type Conflicts = 'abort' | 'proceed'
[pass]
++++
</pre>
++++

[discrete]
=== CoordsGeoBounds

SHARED TYPE!
[pass]
++++
<pre>
++++
interface CoordsGeoBounds {
  top: number
  bottom: number
  left: number
  right: number
}
[pass]
++++
</pre>
++++

[discrete]
=== DFIIndependenceMeasure

SHARED TYPE!
[pass]
++++
<pre>
++++
type DFIIndependenceMeasure = 'standardized' | 'saturated' | 'chisquared'
[pass]
++++
</pre>
++++

[discrete]
=== DFRAfterEffect

SHARED TYPE!
[pass]
++++
<pre>
++++
type DFRAfterEffect = 'no' | 'b' | 'l'
[pass]
++++
</pre>
++++

[discrete]
=== DFRBasicModel

SHARED TYPE!
[pass]
++++
<pre>
++++
type DFRBasicModel = 'be' | 'd' | 'g' | 'if' | 'in' | 'ine' | 'p'
[pass]
++++
</pre>
++++

[discrete]
=== DataStreamName

SHARED TYPE!
[pass]
++++
<pre>
++++
type DataStreamName = string
[pass]
++++
</pre>
++++

[discrete]
=== DataStreamNames

SHARED TYPE!
[pass]
++++
<pre>
++++
type DataStreamNames = <<DataStreamName>> | <<DataStreamName>>[]
[pass]
++++
</pre>
++++

[discrete]
=== DateFormat

SHARED TYPE!
[pass]
++++
<pre>
++++
type DateFormat = string
[pass]
++++
</pre>
++++

[discrete]
=== DateMath

SHARED TYPE!
[pass]
++++
<pre>
++++
type DateMath = string | Date
[pass]
++++
</pre>
++++

[discrete]
=== DateTime

SHARED TYPE!
[pass]
++++
<pre>
++++
type DateTime = string | <<EpochTime>><<<UnitMillis>>> | Date
[pass]
++++
</pre>
++++

[discrete]
=== Distance

SHARED TYPE!
[pass]
++++
<pre>
++++
type Distance = string
[pass]
++++
</pre>
++++

[discrete]
=== DistanceUnit

SHARED TYPE!
[pass]
++++
<pre>
++++
type DistanceUnit = 'in' | 'ft' | 'yd' | 'mi' | 'nmi' | 'km' | 'm' | 'cm' | 'mm'
[pass]
++++
</pre>
++++

[discrete]
=== DocStats

SHARED TYPE!
[pass]
++++
<pre>
++++
interface DocStats {
  /** @property count Total number of non-deleted documents across all primary shards assigned to selected nodes. This number is based on documents in Lucene segments and may include documents from nested fields. */
  count: number
  /** @property deleted Total number of deleted documents across all primary shards assigned to selected nodes. This number is based on documents in Lucene segments. Elasticsearch reclaims the disk space of deleted Lucene documents when a segment is merged. */
  deleted?: number
}
[pass]
++++
</pre>
++++

[discrete]
=== Duration

SHARED TYPE!
[pass]
++++
<pre>
++++
type Duration = string | -1 | 0
[pass]
++++
</pre>
++++

[discrete]
=== DurationLarge

SHARED TYPE!
[pass]
++++
<pre>
++++
type DurationLarge = string
[pass]
++++
</pre>
++++

[discrete]
=== DurationValue

SHARED TYPE!
[pass]
++++
<pre>
++++
type DurationValue<Unit = unknown> = Unit
[pass]
++++
</pre>
++++

[discrete]
=== ElasticsearchVersionInfo

SHARED TYPE!
[pass]
++++
<pre>
++++
interface ElasticsearchVersionInfo {
  build_date: <<DateTime>>
  build_flavor: string
  build_hash: string
  build_snapshot: boolean
  build_type: string
  lucene_version: <<VersionString>>
  minimum_index_compatibility_version: <<VersionString>>
  minimum_wire_compatibility_version: <<VersionString>>
  number: string
}
[pass]
++++
</pre>
++++

[discrete]
=== ElasticsearchVersionMinInfo

SHARED TYPE!
[pass]
++++
<pre>
++++
interface ElasticsearchVersionMinInfo {
  build_flavor: string
  minimum_index_compatibility_version: <<VersionString>>
  minimum_wire_compatibility_version: <<VersionString>>
  number: string
}
[pass]
++++
</pre>
++++

[discrete]
=== EmptyObject

SHARED TYPE!
[pass]
++++
<pre>
++++
interface EmptyObject {
}
[pass]
++++
</pre>
++++

[discrete]
=== EpochTime

SHARED TYPE!
[pass]
++++
<pre>
++++
type EpochTime<Unit = unknown> = Unit
[pass]
++++
</pre>
++++

[discrete]
=== ErrorCause

SHARED TYPE!
[pass]
++++
<pre>
++++
interface ErrorCauseKeys {
  type: string
  reason?: string
  stack_trace?: string
  caused_by?: <<ErrorCause>>
  root_cause?: <<ErrorCause>>[]
  suppressed?: <<ErrorCause>>[]
}
export type <<ErrorCause>> = ErrorCauseKeys
  & { [property: string]: any }
[pass]
++++
</pre>
++++

[discrete]
=== ErrorResponseBase

SHARED TYPE!
[pass]
++++
<pre>
++++
interface ErrorResponseBase {
  error: <<ErrorCause>>
  status: number
}
[pass]
++++
</pre>
++++

[discrete]
=== EsqlColumns

SHARED TYPE!
[pass]
++++
<pre>
++++
type EsqlColumns = ArrayBuffer
[pass]
++++
</pre>
++++

[discrete]
=== ExpandWildcard

SHARED TYPE!
[pass]
++++
<pre>
++++
type ExpandWildcard = 'all' | 'open' | 'closed' | 'hidden' | 'none'
[pass]
++++
</pre>
++++

[discrete]
=== ExpandWildcards

SHARED TYPE!
[pass]
++++
<pre>
++++
type ExpandWildcards = <<ExpandWildcard>> | <<ExpandWildcard>>[]
[pass]
++++
</pre>
++++

[discrete]
=== Field

SHARED TYPE!
[pass]
++++
<pre>
++++
type Field = string
[pass]
++++
</pre>
++++

[discrete]
=== FieldMemoryUsage

SHARED TYPE!
[pass]
++++
<pre>
++++
interface FieldMemoryUsage {
  memory_size?: <<ByteSize>>
  memory_size_in_bytes: number
}
[pass]
++++
</pre>
++++

[discrete]
=== FieldSizeUsage

SHARED TYPE!
[pass]
++++
<pre>
++++
interface FieldSizeUsage {
  size?: <<ByteSize>>
  size_in_bytes: number
}
[pass]
++++
</pre>
++++

[discrete]
=== FieldSort

SHARED TYPE!
[pass]
++++
<pre>
++++
interface FieldSort {
  missing?: AggregationsMissing
  mode?: <<SortMode>>
  nested?: <<NestedSortValue>>
  order?: <<SortOrder>>
  unmapped_type?: MappingFieldType
  numeric_type?: <<FieldSortNumericType>>
  format?: string
}
[pass]
++++
</pre>
++++

[discrete]
=== FieldSortNumericType

SHARED TYPE!
[pass]
++++
<pre>
++++
type FieldSortNumericType = 'number' | 'number' | 'date' | 'date_nanos'
[pass]
++++
</pre>
++++

[discrete]
=== FieldValue

SHARED TYPE!
[pass]
++++
<pre>
++++
type FieldValue = number | number | string | boolean | null | any
[pass]
++++
</pre>
++++

[discrete]
=== FielddataStats

SHARED TYPE!
[pass]
++++
<pre>
++++
interface FielddataStats {
  evictions?: number
  memory_size?: <<ByteSize>>
  memory_size_in_bytes: number
  fields?: Record<<<Field>>, <<FieldMemoryUsage>>>
}
[pass]
++++
</pre>
++++

[discrete]
=== Fields

SHARED TYPE!
[pass]
++++
<pre>
++++
type Fields = <<Field>> | <<Field>>[]
[pass]
++++
</pre>
++++

[discrete]
=== FlushStats

SHARED TYPE!
[pass]
++++
<pre>
++++
interface FlushStats {
  periodic: number
  total: number
  total_time?: <<Duration>>
  total_time_in_millis: <<DurationValue>><<<UnitMillis>>>
}
[pass]
++++
</pre>
++++

[discrete]
=== Fuzziness

SHARED TYPE!
[pass]
++++
<pre>
++++
type Fuzziness = string | number
[pass]
++++
</pre>
++++

[discrete]
=== GeoBounds

SHARED TYPE!
[pass]
++++
<pre>
++++
type GeoBounds = <<CoordsGeoBounds>> | <<TopLeftBottomRightGeoBounds>> | <<TopRightBottomLeftGeoBounds>> | <<WktGeoBounds>>
[pass]
++++
</pre>
++++

[discrete]
=== GeoDistanceSort

SHARED TYPE!
[pass]
++++
<pre>
++++
interface GeoDistanceSortKeys {
  mode?: <<SortMode>>
  distance_type?: <<GeoDistanceType>>
  ignore_unmapped?: boolean
  order?: <<SortOrder>>
  unit?: <<DistanceUnit>>
  nested?: <<NestedSortValue>>
}
export type <<GeoDistanceSort>> = GeoDistanceSortKeys
  & { [property: string]: <<GeoLocation>> | <<GeoLocation>>[] | <<SortMode>> | <<GeoDistanceType>> | boolean | <<SortOrder>> | <<DistanceUnit>> | <<NestedSortValue>> }
[pass]
++++
</pre>
++++

[discrete]
=== GeoDistanceType

SHARED TYPE!
[pass]
++++
<pre>
++++
type GeoDistanceType = 'arc' | 'plane'
[pass]
++++
</pre>
++++

[discrete]
=== GeoHash

SHARED TYPE!
[pass]
++++
<pre>
++++
type GeoHash = string
[pass]
++++
</pre>
++++

[discrete]
=== GeoHashLocation

SHARED TYPE!
[pass]
++++
<pre>
++++
interface GeoHashLocation {
  geohash: <<GeoHash>>
}
[pass]
++++
</pre>
++++

[discrete]
=== GeoHashPrecision

SHARED TYPE!
[pass]
++++
<pre>
++++
type GeoHashPrecision = number | string
[pass]
++++
</pre>
++++

[discrete]
=== GeoHexCell

SHARED TYPE!
[pass]
++++
<pre>
++++
type GeoHexCell = string
[pass]
++++
</pre>
++++

[discrete]
=== GeoLine

SHARED TYPE!
[pass]
++++
<pre>
++++
interface GeoLine {
  /** @property type Always `"LineString"` */
  type: string
  /** @property coordinates Array of `[lon, lat]` coordinates */
  coordinates: number[][]
}
[pass]
++++
</pre>
++++

[discrete]
=== GeoLocation

SHARED TYPE!
[pass]
++++
<pre>
++++
type GeoLocation = <<LatLonGeoLocation>> | <<GeoHashLocation>> | number[] | string
[pass]
++++
</pre>
++++

[discrete]
=== GeoShape

SHARED TYPE!
[pass]
++++
<pre>
++++
type GeoShape = any
[pass]
++++
</pre>
++++

[discrete]
=== GeoShapeRelation

SHARED TYPE!
[pass]
++++
<pre>
++++
type GeoShapeRelation = 'intersects' | 'disjoint' | 'within' | 'contains'
[pass]
++++
</pre>
++++

[discrete]
=== GeoTile

SHARED TYPE!
[pass]
++++
<pre>
++++
type GeoTile = string
[pass]
++++
</pre>
++++

[discrete]
=== GeoTilePrecision

SHARED TYPE!
[pass]
++++
<pre>
++++
type GeoTilePrecision = number
[pass]
++++
</pre>
++++

[discrete]
=== GetStats

SHARED TYPE!
[pass]
++++
<pre>
++++
interface GetStats {
  current: number
  exists_time?: <<Duration>>
  exists_time_in_millis: <<DurationValue>><<<UnitMillis>>>
  exists_total: number
  missing_time?: <<Duration>>
  missing_time_in_millis: <<DurationValue>><<<UnitMillis>>>
  missing_total: number
  time?: <<Duration>>
  time_in_millis: <<DurationValue>><<<UnitMillis>>>
  total: number
}
[pass]
++++
</pre>
++++

[discrete]
=== GrokPattern

SHARED TYPE!
[pass]
++++
<pre>
++++
type GrokPattern = string
[pass]
++++
</pre>
++++

[discrete]
=== HealthStatus

SHARED TYPE!
[pass]
++++
<pre>
++++
type HealthStatus = 'green' | 'GREEN' | 'yellow' | 'YELLOW' | 'red' | 'RED'
[pass]
++++
</pre>
++++

[discrete]
=== Host

SHARED TYPE!
[pass]
++++
<pre>
++++
type Host = string
[pass]
++++
</pre>
++++

[discrete]
=== HttpHeaders

SHARED TYPE!
[pass]
++++
<pre>
++++
type HttpHeaders = Record<string, string | string[]>
[pass]
++++
</pre>
++++

[discrete]
=== IBDistribution

SHARED TYPE!
[pass]
++++
<pre>
++++
type IBDistribution = 'll' | 'spl'
[pass]
++++
</pre>
++++

[discrete]
=== IBLambda

SHARED TYPE!
[pass]
++++
<pre>
++++
type IBLambda = 'df' | 'ttf'
[pass]
++++
</pre>
++++

[discrete]
=== Id

SHARED TYPE!
[pass]
++++
<pre>
++++
type Id = string
[pass]
++++
</pre>
++++

[discrete]
=== Ids

SHARED TYPE!
[pass]
++++
<pre>
++++
type Ids = <<Id>> | <<Id>>[]
[pass]
++++
</pre>
++++

[discrete]
=== IndexAlias

SHARED TYPE!
[pass]
++++
<pre>
++++
type IndexAlias = string
[pass]
++++
</pre>
++++

[discrete]
=== IndexName

SHARED TYPE!
[pass]
++++
<pre>
++++
type IndexName = string
[pass]
++++
</pre>
++++

[discrete]
=== IndexPattern

SHARED TYPE!
[pass]
++++
<pre>
++++
type IndexPattern = string
[pass]
++++
</pre>
++++

[discrete]
=== IndexPatterns

SHARED TYPE!
[pass]
++++
<pre>
++++
type IndexPatterns = <<IndexPattern>>[]
[pass]
++++
</pre>
++++

[discrete]
=== IndexingStats

SHARED TYPE!
[pass]
++++
<pre>
++++
interface IndexingStats {
  index_current: number
  delete_current: number
  delete_time?: <<Duration>>
  delete_time_in_millis: <<DurationValue>><<<UnitMillis>>>
  delete_total: number
  is_throttled: boolean
  noop_update_total: number
  throttle_time?: <<Duration>>
  throttle_time_in_millis: <<DurationValue>><<<UnitMillis>>>
  index_time?: <<Duration>>
  index_time_in_millis: <<DurationValue>><<<UnitMillis>>>
  index_total: number
  index_failed: number
  types?: Record<string, <<IndexingStats>>>
  write_load?: number
}
[pass]
++++
</pre>
++++

[discrete]
=== Indices

SHARED TYPE!
[pass]
++++
<pre>
++++
type Indices = <<IndexName>> | <<IndexName>>[]
[pass]
++++
</pre>
++++

[discrete]
=== IndicesOptions

SHARED TYPE!
[pass]
++++
<pre>
++++
interface IndicesOptions {
  /** @property allow_no_indices If false, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`. */
  allow_no_indices?: boolean
  /** @property expand_wildcards Type of index that wildcard patterns can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams. Supports comma-separated values, such as `open,hidden`. */
  expand_wildcards?: <<ExpandWildcards>>
  /** @property ignore_unavailable If true, missing or closed indices are not included in the response. */
  ignore_unavailable?: boolean
  /** @property ignore_throttled If true, concrete, expanded or aliased indices are ignored when frozen. */
  ignore_throttled?: boolean
}
[pass]
++++
</pre>
++++

[discrete]
=== IndicesResponseBase

SHARED TYPE!
[pass]
++++
<pre>
++++
interface IndicesResponseBase extends <<AcknowledgedResponseBase>> {
  _shards?: <<ShardStatistics>>
}
[pass]
++++
</pre>
++++

[discrete]
=== InlineGet

SHARED TYPE!
[pass]
++++
<pre>
++++
interface InlineGetKeys<TDocument = unknown> {
  fields?: Record<string, any>
  found: boolean
  _seq_no?: <<SequenceNumber>>
  _primary_term?: number
  _routing?: <<Routing>>
  _source?: TDocument
}
export type <<InlineGet>><TDocument = unknown> = InlineGetKeys<TDocument>
  & { [property: string]: any }
[pass]
++++
</pre>
++++

[discrete]
=== Ip

SHARED TYPE!
[pass]
++++
<pre>
++++
type Ip = string
[pass]
++++
</pre>
++++

[discrete]
=== KnnQuery

SHARED TYPE!
[pass]
++++
<pre>
++++
interface KnnQuery extends QueryDslQueryBase {
  /** @property field The name of the vector field to search against */
  field: <<Field>>
  /** @property query_vector The query vector */
  query_vector?: <<QueryVector>>
  /** @property query_vector_builder The query vector builder. You must provide a query_vector_builder or query_vector, but not both. */
  query_vector_builder?: <<QueryVectorBuilder>>
  /** @property num_candidates The number of nearest neighbor candidates to consider per shard */
  num_candidates?: number
  /** @property k The final number of nearest neighbors to return as top hits */
  k?: number
  /** @property filter Filters for the kNN search query */
  filter?: QueryDslQueryContainer | QueryDslQueryContainer[]
  /** @property similarity The minimum similarity for a vector to be considered a match */
  similarity?: number
}
[pass]
++++
</pre>
++++

[discrete]
=== KnnRetriever

SHARED TYPE!
[pass]
++++
<pre>
++++
interface KnnRetriever extends <<RetrieverBase>> {
  /** @property field The name of the vector field to search against. */
  field: string
  /** @property query_vector Query vector. Must have the same number of dimensions as the vector field you are searching against. You must provide a query_vector_builder or query_vector, but not both. */
  query_vector?: <<QueryVector>>
  /** @property query_vector_builder Defines a model to build a query vector. */
  query_vector_builder?: <<QueryVectorBuilder>>
  /** @property k Number of nearest neighbors to return as top hits. */
  k: number
  /** @property num_candidates Number of nearest neighbor candidates to consider per shard. */
  num_candidates: number
  /** @property similarity The minimum similarity required for a document to be considered a match. */
  similarity?: number
}
[pass]
++++
</pre>
++++

[discrete]
=== KnnSearch

SHARED TYPE!
[pass]
++++
<pre>
++++
interface KnnSearch {
  /** @property field The name of the vector field to search against */
  field: <<Field>>
  /** @property query_vector The query vector */
  query_vector?: <<QueryVector>>
  /** @property query_vector_builder The query vector builder. You must provide a query_vector_builder or query_vector, but not both. */
  query_vector_builder?: <<QueryVectorBuilder>>
  /** @property k The final number of nearest neighbors to return as top hits */
  k?: number
  /** @property num_candidates The number of nearest neighbor candidates to consider per shard */
  num_candidates?: number
  /** @property boost Boost value to apply to kNN scores */
  boost?: number
  /** @property filter Filters for the kNN search query */
  filter?: QueryDslQueryContainer | QueryDslQueryContainer[]
  /** @property similarity The minimum similarity for a vector to be considered a match */
  similarity?: number
  /** @property inner_hits If defined, each search hit will contain inner hits. */
  inner_hits?: SearchInnerHits
}
[pass]
++++
</pre>
++++

[discrete]
=== LatLonGeoLocation

SHARED TYPE!
[pass]
++++
<pre>
++++
interface LatLonGeoLocation {
  /** @property lat Latitude */
  lat: number
  /** @property lon Longitude */
  lon: number
}
[pass]
++++
</pre>
++++

[discrete]
=== Level

SHARED TYPE!
[pass]
++++
<pre>
++++
type Level = 'cluster' | 'indices' | 'shards'
[pass]
++++
</pre>
++++

[discrete]
=== LifecycleOperationMode

SHARED TYPE!
[pass]
++++
<pre>
++++
type LifecycleOperationMode = 'RUNNING' | 'STOPPING' | 'STOPPED'
[pass]
++++
</pre>
++++

[discrete]
=== MapboxVectorTiles

SHARED TYPE!
[pass]
++++
<pre>
++++
type MapboxVectorTiles = ArrayBuffer
[pass]
++++
</pre>
++++

[discrete]
=== MergesStats

SHARED TYPE!
[pass]
++++
<pre>
++++
interface MergesStats {
  current: number
  current_docs: number
  current_size?: string
  current_size_in_bytes: number
  total: number
  total_auto_throttle?: string
  total_auto_throttle_in_bytes: number
  total_docs: number
  total_size?: string
  total_size_in_bytes: number
  total_stopped_time?: <<Duration>>
  total_stopped_time_in_millis: <<DurationValue>><<<UnitMillis>>>
  total_throttled_time?: <<Duration>>
  total_throttled_time_in_millis: <<DurationValue>><<<UnitMillis>>>
  total_time?: <<Duration>>
  total_time_in_millis: <<DurationValue>><<<UnitMillis>>>
}
[pass]
++++
</pre>
++++

[discrete]
=== Metadata

SHARED TYPE!
[pass]
++++
<pre>
++++
type Metadata = Record<string, any>
[pass]
++++
</pre>
++++

[discrete]
=== Metrics

SHARED TYPE!
[pass]
++++
<pre>
++++
type Metrics = string | string[]
[pass]
++++
</pre>
++++

[discrete]
=== MinimumShouldMatch

SHARED TYPE!
[pass]
++++
<pre>
++++
type MinimumShouldMatch = number | string
[pass]
++++
</pre>
++++

[discrete]
=== MultiTermQueryRewrite

SHARED TYPE!
[pass]
++++
<pre>
++++
type MultiTermQueryRewrite = string
[pass]
++++
</pre>
++++

[discrete]
=== Name

SHARED TYPE!
[pass]
++++
<pre>
++++
type Name = string
[pass]
++++
</pre>
++++

[discrete]
=== Names

SHARED TYPE!
[pass]
++++
<pre>
++++
type Names = <<Name>> | <<Name>>[]
[pass]
++++
</pre>
++++

[discrete]
=== Namespace

SHARED TYPE!
[pass]
++++
<pre>
++++
type Namespace = string
[pass]
++++
</pre>
++++

[discrete]
=== NestedSortValue

SHARED TYPE!
[pass]
++++
<pre>
++++
interface NestedSortValue {
  filter?: QueryDslQueryContainer
  max_children?: number
  nested?: <<NestedSortValue>>
  path: <<Field>>
}
[pass]
++++
</pre>
++++

[discrete]
=== NodeAttributes

SHARED TYPE!
[pass]
++++
<pre>
++++
interface NodeAttributes {
  /** @property attributes Lists node attributes. */
  attributes: Record<string, string>
  /** @property ephemeral_id The ephemeral ID of the node. */
  ephemeral_id: <<Id>>
  /** @property id The unique identifier of the node. */
  id?: <<NodeId>>
  /** @property name The unique identifier of the node. */
  name: <<NodeName>>
  /** @property transport_address The host and port where transport HTTP connections are accepted. */
  transport_address: <<TransportAddress>>
}
[pass]
++++
</pre>
++++

[discrete]
=== NodeId

SHARED TYPE!
[pass]
++++
<pre>
++++
type NodeId = string
[pass]
++++
</pre>
++++

[discrete]
=== NodeIds

SHARED TYPE!
[pass]
++++
<pre>
++++
type NodeIds = <<NodeId>> | <<NodeId>>[]
[pass]
++++
</pre>
++++

[discrete]
=== NodeName

SHARED TYPE!
[pass]
++++
<pre>
++++
type NodeName = string
[pass]
++++
</pre>
++++

[discrete]
=== NodeRole

SHARED TYPE!
[pass]
++++
<pre>
++++
type NodeRole = 'master' | 'data' | 'data_cold' | 'data_content' | 'data_frozen' | 'data_hot' | 'data_warm' | 'client' | 'ingest' | 'ml' | 'voting_only' | 'transform' | 'remote_cluster_client' | 'coordinating_only'
[pass]
++++
</pre>
++++

[discrete]
=== NodeRoles

SHARED TYPE!
[pass]
++++
<pre>
++++
type NodeRoles = <<NodeRole>>[]
[pass]
++++
</pre>
++++

[discrete]
=== NodeShard

SHARED TYPE!
[pass]
++++
<pre>
++++
interface NodeShard {
  state: IndicesStatsShardRoutingState
  primary: boolean
  node?: <<NodeName>>
  shard: number
  index: <<IndexName>>
  allocation_id?: Record<string, <<Id>>>
  recovery_source?: Record<string, <<Id>>>
  unassigned_info?: ClusterAllocationExplainUnassignedInformation
  relocating_node?: <<NodeId>> | null
  relocation_failure_info?: <<RelocationFailureInfo>>
}
[pass]
++++
</pre>
++++

[discrete]
=== NodeStatistics

SHARED TYPE!
[pass]
++++
<pre>
++++
interface NodeStatistics {
  failures?: <<ErrorCause>>[]
  /** @property total Total number of nodes selected by the request. */
  total: number
  /** @property successful Number of nodes that responded successfully to the request. */
  successful: number
  /** @property failed Number of nodes that rejected the request or failed to respond. If this value is not 0, a reason for the rejection or failure is included in the response. */
  failed: number
}
[pass]
++++
</pre>
++++

[discrete]
=== Normalization

SHARED TYPE!
[pass]
++++
<pre>
++++
type Normalization = 'no' | 'h1' | 'h2' | 'h3' | 'z'
[pass]
++++
</pre>
++++

[discrete]
=== OpType

SHARED TYPE!
[pass]
++++
<pre>
++++
type OpType = 'index' | 'create'
[pass]
++++
</pre>
++++

[discrete]
=== Password

SHARED TYPE!
[pass]
++++
<pre>
++++
type Password = string
[pass]
++++
</pre>
++++

[discrete]
=== Percentage

SHARED TYPE!
[pass]
++++
<pre>
++++
type Percentage = string | number
[pass]
++++
</pre>
++++

[discrete]
=== PipelineName

SHARED TYPE!
[pass]
++++
<pre>
++++
type PipelineName = string
[pass]
++++
</pre>
++++

[discrete]
=== PluginStats

SHARED TYPE!
[pass]
++++
<pre>
++++
interface PluginStats {
  classname: string
  description: string
  elasticsearch_version: <<VersionString>>
  extended_plugins: string[]
  has_native_controller: boolean
  java_version: <<VersionString>>
  name: <<Name>>
  version: <<VersionString>>
  licensed: boolean
}
[pass]
++++
</pre>
++++

[discrete]
=== PropertyName

SHARED TYPE!
[pass]
++++
<pre>
++++
type PropertyName = string
[pass]
++++
</pre>
++++

[discrete]
=== QueryCacheStats

SHARED TYPE!
[pass]
++++
<pre>
++++
interface QueryCacheStats {
  /** @property cache_count Total number of entries added to the query cache across all shards assigned to selected nodes. This number includes current and evicted entries. */
  cache_count: number
  /** @property cache_size Total number of entries currently in the query cache across all shards assigned to selected nodes. */
  cache_size: number
  /** @property evictions Total number of query cache evictions across all shards assigned to selected nodes. */
  evictions: number
  /** @property hit_count Total count of query cache hits across all shards assigned to selected nodes. */
  hit_count: number
  /** @property memory_size Total amount of memory used for the query cache across all shards assigned to selected nodes. */
  memory_size?: <<ByteSize>>
  /** @property memory_size_in_bytes Total amount, in bytes, of memory used for the query cache across all shards assigned to selected nodes. */
  memory_size_in_bytes: number
  /** @property miss_count Total count of query cache misses across all shards assigned to selected nodes. */
  miss_count: number
  /** @property total_count Total count of hits and misses in the query cache across all shards assigned to selected nodes. */
  total_count: number
}
[pass]
++++
</pre>
++++

[discrete]
=== QueryVector

SHARED TYPE!
[pass]
++++
<pre>
++++
type QueryVector = number[]
[pass]
++++
</pre>
++++

[discrete]
=== QueryVectorBuilder

SHARED TYPE!
[pass]
++++
<pre>
++++
interface QueryVectorBuilder {
  text_embedding?: <<TextEmbedding>>
}
[pass]
++++
</pre>
++++

[discrete]
=== RRFRetriever

SHARED TYPE!
[pass]
++++
<pre>
++++
interface RRFRetriever extends <<RetrieverBase>> {
  /** @property retrievers A list of child retrievers to specify which sets of returned top documents will have the RRF formula applied to them. */
  retrievers: <<RetrieverContainer>>[]
  /** @property rank_constant This value determines how much influence documents in individual result sets per query have over the final ranked result set. */
  rank_constant?: number
  /** @property rank_window_size This value determines the size of the individual result sets per query. */
  rank_window_size?: number
}
[pass]
++++
</pre>
++++

[discrete]
=== RankBase

SHARED TYPE!
[pass]
++++
<pre>
++++
interface RankBase {
}
[pass]
++++
</pre>
++++

[discrete]
=== RankContainer

SHARED TYPE!
[pass]
++++
<pre>
++++
interface RankContainer {
  /** @property rrf The reciprocal rank fusion parameters */
  rrf?: <<RrfRank>>
}
[pass]
++++
</pre>
++++

[discrete]
=== RecoveryStats

SHARED TYPE!
[pass]
++++
<pre>
++++
interface RecoveryStats {
  current_as_source: number
  current_as_target: number
  throttle_time?: <<Duration>>
  throttle_time_in_millis: <<DurationValue>><<<UnitMillis>>>
}
[pass]
++++
</pre>
++++

[discrete]
=== Refresh

SHARED TYPE!
[pass]
++++
<pre>
++++
type Refresh = boolean | 'true' | 'false' | 'wait_for'
[pass]
++++
</pre>
++++

[discrete]
=== RefreshStats

SHARED TYPE!
[pass]
++++
<pre>
++++
interface RefreshStats {
  external_total: number
  external_total_time_in_millis: <<DurationValue>><<<UnitMillis>>>
  listeners: number
  total: number
  total_time?: <<Duration>>
  total_time_in_millis: <<DurationValue>><<<UnitMillis>>>
}
[pass]
++++
</pre>
++++

[discrete]
=== RelationName

SHARED TYPE!
[pass]
++++
<pre>
++++
type RelationName = string
[pass]
++++
</pre>
++++

[discrete]
=== RelocationFailureInfo

SHARED TYPE!
[pass]
++++
<pre>
++++
interface RelocationFailureInfo {
  failed_attempts: number
}
[pass]
++++
</pre>
++++

[discrete]
=== RequestBase

SHARED TYPE!
[pass]
++++
<pre>
++++
interface RequestBase extends <<SpecUtilsCommonQueryParameters>> {
}
[pass]
++++
</pre>
++++

[discrete]
=== RequestCacheStats

SHARED TYPE!
[pass]
++++
<pre>
++++
interface RequestCacheStats {
  evictions: number
  hit_count: number
  memory_size?: string
  memory_size_in_bytes: number
  miss_count: number
}
[pass]
++++
</pre>
++++

[discrete]
=== Result

SHARED TYPE!
[pass]
++++
<pre>
++++
type Result = 'created' | 'updated' | 'deleted' | 'not_found' | 'noop'
[pass]
++++
</pre>
++++

[discrete]
=== Retries

SHARED TYPE!
[pass]
++++
<pre>
++++
interface Retries {
  bulk: number
  search: number
}
[pass]
++++
</pre>
++++

[discrete]
=== RetrieverBase

SHARED TYPE!
[pass]
++++
<pre>
++++
interface RetrieverBase {
  /** @property filter Query to filter the documents that can match. */
  filter?: QueryDslQueryContainer | QueryDslQueryContainer[]
  /** @property min_score Minimum _score for matching documents. Documents with a lower _score are not included in the top documents. */
  min_score?: number
}
[pass]
++++
</pre>
++++

[discrete]
=== RetrieverContainer

SHARED TYPE!
[pass]
++++
<pre>
++++
interface RetrieverContainer {
  /** @property standard A retriever that replaces the functionality of a traditional query. */
  standard?: <<StandardRetriever>>
  /** @property knn A retriever that replaces the functionality of a knn search. */
  knn?: <<KnnRetriever>>
  /** @property rrf A retriever that produces top documents from reciprocal rank fusion (RRF). */
  rrf?: <<RRFRetriever>>
  /** @property text_similarity_reranker A retriever that reranks the top documents based on a reranking model using the InferenceAPI */
  text_similarity_reranker?: <<TextSimilarityReranker>>
}
[pass]
++++
</pre>
++++

[discrete]
=== Routing

SHARED TYPE!
[pass]
++++
<pre>
++++
type Routing = string
[pass]
++++
</pre>
++++

[discrete]
=== RrfRank

SHARED TYPE!
[pass]
++++
<pre>
++++
interface RrfRank {
  /** @property rank_constant How much influence documents in individual result sets per query have over the final ranked result set */
  rank_constant?: number
  /** @property rank_window_size Size of the individual result sets per query */
  rank_window_size?: number
}
[pass]
++++
</pre>
++++

[discrete]
=== ScalarValue

SHARED TYPE!
[pass]
++++
<pre>
++++
type ScalarValue = number | number | string | boolean | null
[pass]
++++
</pre>
++++

[discrete]
=== ScoreSort

SHARED TYPE!
[pass]
++++
<pre>
++++
interface ScoreSort {
  order?: <<SortOrder>>
}
[pass]
++++
</pre>
++++

[discrete]
=== Script

SHARED TYPE!
[pass]
++++
<pre>
++++
interface Script {
  /** @property source The script source. */
  source?: string
  /** @property id The `id` for a stored script. */
  id?: <<Id>>
  /** @property params Specifies any named parameters that are passed into the script as variables. Use parameters instead of hard-coded values to decrease compile time. */
  params?: Record<string, any>
  /** @property lang Specifies the language the script is written in. */
  lang?: <<ScriptLanguage>>
  options?: Record<string, string>
}
[pass]
++++
</pre>
++++

[discrete]
=== ScriptField

SHARED TYPE!
[pass]
++++
<pre>
++++
interface ScriptField {
  script: <<Script>> | string
  ignore_failure?: boolean
}
[pass]
++++
</pre>
++++

[discrete]
=== ScriptLanguage

SHARED TYPE!
[pass]
++++
<pre>
++++
type ScriptLanguage = 'painless' | 'expression' | 'mustache' | 'java' | string
[pass]
++++
</pre>
++++

[discrete]
=== ScriptSort

SHARED TYPE!
[pass]
++++
<pre>
++++
interface ScriptSort {
  order?: <<SortOrder>>
  script: <<Script>> | string
  type?: <<ScriptSortType>>
  mode?: <<SortMode>>
  nested?: <<NestedSortValue>>
}
[pass]
++++
</pre>
++++

[discrete]
=== ScriptSortType

SHARED TYPE!
[pass]
++++
<pre>
++++
type ScriptSortType = 'string' | 'number' | 'version'
[pass]
++++
</pre>
++++

[discrete]
=== ScriptTransform

SHARED TYPE!
[pass]
++++
<pre>
++++
interface ScriptTransform {
  lang?: string
  params?: Record<string, any>
  source?: string
  id?: string
}
[pass]
++++
</pre>
++++

[discrete]
=== ScrollId

SHARED TYPE!
[pass]
++++
<pre>
++++
type ScrollId = string
[pass]
++++
</pre>
++++

[discrete]
=== ScrollIds

SHARED TYPE!
[pass]
++++
<pre>
++++
type ScrollIds = <<ScrollId>> | <<ScrollId>>[]
[pass]
++++
</pre>
++++

[discrete]
=== SearchStats

SHARED TYPE!
[pass]
++++
<pre>
++++
interface SearchStats {
  fetch_current: number
  fetch_time?: <<Duration>>
  fetch_time_in_millis: <<DurationValue>><<<UnitMillis>>>
  fetch_total: number
  open_contexts?: number
  query_current: number
  query_time?: <<Duration>>
  query_time_in_millis: <<DurationValue>><<<UnitMillis>>>
  query_total: number
  scroll_current: number
  scroll_time?: <<Duration>>
  scroll_time_in_millis: <<DurationValue>><<<UnitMillis>>>
  scroll_total: number
  suggest_current: number
  suggest_time?: <<Duration>>
  suggest_time_in_millis: <<DurationValue>><<<UnitMillis>>>
  suggest_total: number
  groups?: Record<string, <<SearchStats>>>
}
[pass]
++++
</pre>
++++

[discrete]
=== SearchTransform

SHARED TYPE!
[pass]
++++
<pre>
++++
interface SearchTransform {
  request: WatcherSearchInputRequestDefinition
  timeout: <<Duration>>
}
[pass]
++++
</pre>
++++

[discrete]
=== SearchType

SHARED TYPE!
[pass]
++++
<pre>
++++
type SearchType = 'query_then_fetch' | 'dfs_query_then_fetch'
[pass]
++++
</pre>
++++

[discrete]
=== SegmentsStats

SHARED TYPE!
[pass]
++++
<pre>
++++
interface SegmentsStats {
  /** @property count Total number of segments across all shards assigned to selected nodes. */
  count: number
  /** @property doc_values_memory Total amount of memory used for doc values across all shards assigned to selected nodes. */
  doc_values_memory?: <<ByteSize>>
  /** @property doc_values_memory_in_bytes Total amount, in bytes, of memory used for doc values across all shards assigned to selected nodes. */
  doc_values_memory_in_bytes: number
  /** @property file_sizes This object is not populated by the cluster stats API. To get information on segment files, use the node stats API. */
  file_sizes: Record<string, IndicesStatsShardFileSizeInfo>
  /** @property fixed_bit_set Total amount of memory used by fixed bit sets across all shards assigned to selected nodes. Fixed bit sets are used for nested object field types and type filters for join fields. */
  fixed_bit_set?: <<ByteSize>>
  /** @property fixed_bit_set_memory_in_bytes Total amount of memory, in bytes, used by fixed bit sets across all shards assigned to selected nodes. */
  fixed_bit_set_memory_in_bytes: number
  /** @property index_writer_memory Total amount of memory used by all index writers across all shards assigned to selected nodes. */
  index_writer_memory?: <<ByteSize>>
  index_writer_max_memory_in_bytes?: number
  /** @property index_writer_memory_in_bytes Total amount, in bytes, of memory used by all index writers across all shards assigned to selected nodes. */
  index_writer_memory_in_bytes: number
  /** @property max_unsafe_auto_id_timestamp Unix timestamp, in milliseconds, of the most recently retried indexing request. */
  max_unsafe_auto_id_timestamp: number
  /** @property memory Total amount of memory used for segments across all shards assigned to selected nodes. */
  memory?: <<ByteSize>>
  /** @property memory_in_bytes Total amount, in bytes, of memory used for segments across all shards assigned to selected nodes. */
  memory_in_bytes: number
  /** @property norms_memory Total amount of memory used for normalization factors across all shards assigned to selected nodes. */
  norms_memory?: <<ByteSize>>
  /** @property norms_memory_in_bytes Total amount, in bytes, of memory used for normalization factors across all shards assigned to selected nodes. */
  norms_memory_in_bytes: number
  /** @property points_memory Total amount of memory used for points across all shards assigned to selected nodes. */
  points_memory?: <<ByteSize>>
  /** @property points_memory_in_bytes Total amount, in bytes, of memory used for points across all shards assigned to selected nodes. */
  points_memory_in_bytes: number
  stored_memory?: <<ByteSize>>
  /** @property stored_fields_memory_in_bytes Total amount, in bytes, of memory used for stored fields across all shards assigned to selected nodes. */
  stored_fields_memory_in_bytes: number
  /** @property terms_memory_in_bytes Total amount, in bytes, of memory used for terms across all shards assigned to selected nodes. */
  terms_memory_in_bytes: number
  /** @property terms_memory Total amount of memory used for terms across all shards assigned to selected nodes. */
  terms_memory?: <<ByteSize>>
  /** @property term_vectory_memory Total amount of memory used for term vectors across all shards assigned to selected nodes. */
  term_vectory_memory?: <<ByteSize>>
  /** @property term_vectors_memory_in_bytes Total amount, in bytes, of memory used for term vectors across all shards assigned to selected nodes. */
  term_vectors_memory_in_bytes: number
  /** @property version_map_memory Total amount of memory used by all version maps across all shards assigned to selected nodes. */
  version_map_memory?: <<ByteSize>>
  /** @property version_map_memory_in_bytes Total amount, in bytes, of memory used by all version maps across all shards assigned to selected nodes. */
  version_map_memory_in_bytes: number
}
[pass]
++++
</pre>
++++

[discrete]
=== SequenceNumber

SHARED TYPE!
[pass]
++++
<pre>
++++
type SequenceNumber = number
[pass]
++++
</pre>
++++

[discrete]
=== Service

SHARED TYPE!
[pass]
++++
<pre>
++++
type Service = string
[pass]
++++
</pre>
++++

[discrete]
=== ShardFailure

SHARED TYPE!
[pass]
++++
<pre>
++++
interface ShardFailure {
  index?: <<IndexName>>
  node?: string
  reason: <<ErrorCause>>
  shard: number
  status?: string
}
[pass]
++++
</pre>
++++

[discrete]
=== ShardStatistics

SHARED TYPE!
[pass]
++++
<pre>
++++
interface ShardStatistics {
  failed: number
  /** @property successful Indicates how many shards have successfully run the search. */
  successful: number
  /** @property total Indicates how many shards the search will run on overall. */
  total: number
  failures?: <<ShardFailure>>[]
  skipped?: number
}
[pass]
++++
</pre>
++++

[discrete]
=== ShardsOperationResponseBase

SHARED TYPE!
[pass]
++++
<pre>
++++
interface ShardsOperationResponseBase {
  _shards?: <<ShardStatistics>>
}
[pass]
++++
</pre>
++++

[discrete]
=== SlicedScroll

SHARED TYPE!
[pass]
++++
<pre>
++++
interface SlicedScroll {
  field?: <<Field>>
  id: <<Id>>
  max: number
}
[pass]
++++
</pre>
++++

[discrete]
=== Slices

SHARED TYPE!
[pass]
++++
<pre>
++++
type Slices = number | <<SlicesCalculation>>
[pass]
++++
</pre>
++++

[discrete]
=== SlicesCalculation

SHARED TYPE!
[pass]
++++
<pre>
++++
type SlicesCalculation = 'auto'
[pass]
++++
</pre>
++++

[discrete]
=== Sort

SHARED TYPE!
[pass]
++++
<pre>
++++
type Sort = <<SortCombinations>> | <<SortCombinations>>[]
[pass]
++++
</pre>
++++

[discrete]
=== SortCombinations

SHARED TYPE!
[pass]
++++
<pre>
++++
type SortCombinations = <<Field>> | <<SortOptions>>
[pass]
++++
</pre>
++++

[discrete]
=== SortMode

SHARED TYPE!
[pass]
++++
<pre>
++++
type SortMode = 'min' | 'max' | 'sum' | 'avg' | 'median'
[pass]
++++
</pre>
++++

[discrete]
=== SortOptions

SHARED TYPE!
[pass]
++++
<pre>
++++
interface SortOptionsKeys {
  _score?: <<ScoreSort>>
  _doc?: <<ScoreSort>>
  _geo_distance?: <<GeoDistanceSort>>
  _script?: <<ScriptSort>>
}
export type <<SortOptions>> = SortOptionsKeys
  & { [property: string]: <<FieldSort>> | <<SortOrder>> | <<ScoreSort>> | <<GeoDistanceSort>> | <<ScriptSort>> }
[pass]
++++
</pre>
++++

[discrete]
=== SortOrder

SHARED TYPE!
[pass]
++++
<pre>
++++
type SortOrder = 'asc' | 'desc'
[pass]
++++
</pre>
++++

[discrete]
=== SortResults

SHARED TYPE!
[pass]
++++
<pre>
++++
type SortResults = <<FieldValue>>[]
[pass]
++++
</pre>
++++

[discrete]
=== StandardRetriever

SHARED TYPE!
[pass]
++++
<pre>
++++
interface StandardRetriever extends <<RetrieverBase>> {
  /** @property query Defines a query to retrieve a set of top documents. */
  query?: QueryDslQueryContainer
  /** @property search_after Defines a search after object parameter used for pagination. */
  search_after?: <<SortResults>>
  /** @property terminate_after Maximum number of documents to collect for each shard. */
  terminate_after?: number
  /** @property sort A sort object that that specifies the order of matching documents. */
  sort?: <<Sort>>
  /** @property collapse Collapses the top documents by a specified key into a single top document per key. */
  collapse?: SearchFieldCollapse
}
[pass]
++++
</pre>
++++

[discrete]
=== StoreStats

SHARED TYPE!
[pass]
++++
<pre>
++++
interface StoreStats {
  /** @property size Total size of all shards assigned to selected nodes. */
  size?: <<ByteSize>>
  /** @property size_in_bytes Total size, in bytes, of all shards assigned to selected nodes. */
  size_in_bytes: number
  /** @property reserved A prediction of how much larger the shard stores will eventually grow due to ongoing peer recoveries, restoring snapshots, and similar activities. */
  reserved?: <<ByteSize>>
  /** @property reserved_in_bytes A prediction, in bytes, of how much larger the shard stores will eventually grow due to ongoing peer recoveries, restoring snapshots, and similar activities. */
  reserved_in_bytes: number
  /** @property total_data_set_size Total data set size of all shards assigned to selected nodes. This includes the size of shards not stored fully on the nodes, such as the cache for partially mounted indices. */
  total_data_set_size?: <<ByteSize>>
  /** @property total_data_set_size_in_bytes Total data set size, in bytes, of all shards assigned to selected nodes. This includes the size of shards not stored fully on the nodes, such as the cache for partially mounted indices. */
  total_data_set_size_in_bytes?: number
}
[pass]
++++
</pre>
++++

[discrete]
=== StoredScript

SHARED TYPE!
[pass]
++++
<pre>
++++
interface StoredScript {
  /** @property lang Specifies the language the script is written in. */
  lang: <<ScriptLanguage>>
  options?: Record<string, string>
  /** @property source The script source. */
  source: string
}
[pass]
++++
</pre>
++++

[discrete]
=== SuggestMode

SHARED TYPE!
[pass]
++++
<pre>
++++
type SuggestMode = 'missing' | 'popular' | 'always'
[pass]
++++
</pre>
++++

[discrete]
=== SuggestionName

SHARED TYPE!
[pass]
++++
<pre>
++++
type SuggestionName = string
[pass]
++++
</pre>
++++

[discrete]
=== TaskFailure

SHARED TYPE!
[pass]
++++
<pre>
++++
interface TaskFailure {
  task_id: number
  node_id: <<NodeId>>
  status: string
  reason: <<ErrorCause>>
}
[pass]
++++
</pre>
++++

[discrete]
=== TaskId

SHARED TYPE!
[pass]
++++
<pre>
++++
type TaskId = string | number
[pass]
++++
</pre>
++++

[discrete]
=== TextEmbedding

SHARED TYPE!
[pass]
++++
<pre>
++++
interface TextEmbedding {
  model_id: string
  model_text: string
}
[pass]
++++
</pre>
++++

[discrete]
=== TextSimilarityReranker

SHARED TYPE!
[pass]
++++
<pre>
++++
interface TextSimilarityReranker extends <<RetrieverBase>> {
  /** @property retriever The nested retriever which will produce the first-level results, that will later be used for reranking. */
  retriever: <<RetrieverContainer>>
  /** @property rank_window_size This value determines how many documents we will consider from the nested retriever. */
  rank_window_size?: number
  /** @property inference_id Unique identifier of the inference endpoint created using the inference API. */
  inference_id?: string
  /** @property inference_text The text snippet used as the basis for similarity comparison */
  inference_text?: string
  /** @property field The document field to be used for text similarity comparisons. This field should contain the text that will be evaluated against the inference_text */
  field?: string
}
[pass]
++++
</pre>
++++

[discrete]
=== ThreadType

SHARED TYPE!
[pass]
++++
<pre>
++++
type ThreadType = 'cpu' | 'wait' | 'block' | 'gpu' | 'mem'
[pass]
++++
</pre>
++++

[discrete]
=== TimeOfDay

SHARED TYPE!
[pass]
++++
<pre>
++++
type TimeOfDay = string
[pass]
++++
</pre>
++++

[discrete]
=== TimeUnit

SHARED TYPE!
[pass]
++++
<pre>
++++
type TimeUnit = 'nanos' | 'micros' | 'ms' | 's' | 'm' | 'h' | 'd'
[pass]
++++
</pre>
++++

[discrete]
=== TimeZone

SHARED TYPE!
[pass]
++++
<pre>
++++
type TimeZone = string
[pass]
++++
</pre>
++++

[discrete]
=== TopLeftBottomRightGeoBounds

SHARED TYPE!
[pass]
++++
<pre>
++++
interface TopLeftBottomRightGeoBounds {
  top_left: <<GeoLocation>>
  bottom_right: <<GeoLocation>>
}
[pass]
++++
</pre>
++++

[discrete]
=== TopRightBottomLeftGeoBounds

SHARED TYPE!
[pass]
++++
<pre>
++++
interface TopRightBottomLeftGeoBounds {
  top_right: <<GeoLocation>>
  bottom_left: <<GeoLocation>>
}
[pass]
++++
</pre>
++++

[discrete]
=== TransformContainer

SHARED TYPE!
[pass]
++++
<pre>
++++
interface TransformContainer {
  chain?: <<TransformContainer>>[]
  script?: <<ScriptTransform>>
  search?: <<SearchTransform>>
}
[pass]
++++
</pre>
++++

[discrete]
=== TranslogStats

SHARED TYPE!
[pass]
++++
<pre>
++++
interface TranslogStats {
  earliest_last_modified_age: number
  operations: number
  size?: string
  size_in_bytes: number
  uncommitted_operations: number
  uncommitted_size?: string
  uncommitted_size_in_bytes: number
}
[pass]
++++
</pre>
++++

[discrete]
=== TransportAddress

SHARED TYPE!
[pass]
++++
<pre>
++++
type TransportAddress = string
[pass]
++++
</pre>
++++

[discrete]
=== UnitFloatMillis

SHARED TYPE!
[pass]
++++
<pre>
++++
type UnitFloatMillis = number
[pass]
++++
</pre>
++++

[discrete]
=== UnitMillis

SHARED TYPE!
[pass]
++++
<pre>
++++
type UnitMillis = number
[pass]
++++
</pre>
++++

[discrete]
=== UnitNanos

SHARED TYPE!
[pass]
++++
<pre>
++++
type UnitNanos = number
[pass]
++++
</pre>
++++

[discrete]
=== UnitSeconds

SHARED TYPE!
[pass]
++++
<pre>
++++
type UnitSeconds = number
[pass]
++++
</pre>
++++

[discrete]
=== Username

SHARED TYPE!
[pass]
++++
<pre>
++++
type Username = string
[pass]
++++
</pre>
++++

[discrete]
=== Uuid

SHARED TYPE!
[pass]
++++
<pre>
++++
type Uuid = string
[pass]
++++
</pre>
++++

[discrete]
=== VersionNumber

SHARED TYPE!
[pass]
++++
<pre>
++++
type VersionNumber = number
[pass]
++++
</pre>
++++

[discrete]
=== VersionString

SHARED TYPE!
[pass]
++++
<pre>
++++
type VersionString = string
[pass]
++++
</pre>
++++

[discrete]
=== VersionType

SHARED TYPE!
[pass]
++++
<pre>
++++
type VersionType = 'internal' | 'external' | 'external_gte' | 'force'
[pass]
++++
</pre>
++++

[discrete]
=== WaitForActiveShardOptions

SHARED TYPE!
[pass]
++++
<pre>
++++
type WaitForActiveShardOptions = 'all' | 'index-setting'
[pass]
++++
</pre>
++++

[discrete]
=== WaitForActiveShards

SHARED TYPE!
[pass]
++++
<pre>
++++
type WaitForActiveShards = number | <<WaitForActiveShardOptions>>
[pass]
++++
</pre>
++++

[discrete]
=== WaitForEvents

SHARED TYPE!
[pass]
++++
<pre>
++++
type WaitForEvents = 'immediate' | 'urgent' | 'high' | 'normal' | 'low' | 'languid'
[pass]
++++
</pre>
++++

[discrete]
=== WarmerStats

SHARED TYPE!
[pass]
++++
<pre>
++++
interface WarmerStats {
  current: number
  total: number
  total_time?: <<Duration>>
  total_time_in_millis: <<DurationValue>><<<UnitMillis>>>
}
[pass]
++++
</pre>
++++

[discrete]
=== WktGeoBounds

SHARED TYPE!
[pass]
++++
<pre>
++++
interface WktGeoBounds {
  wkt: string
}
[pass]
++++
</pre>
++++

[discrete]
=== WriteResponseBase

SHARED TYPE!
[pass]
++++
<pre>
++++
interface WriteResponseBase {
  _id: <<Id>>
  _index: <<IndexName>>
  _primary_term?: number
  result: <<Result>>
  _seq_no?: <<SequenceNumber>>
  _shards: <<ShardStatistics>>
  _version: <<VersionNumber>>
  forced_refresh?: boolean
}
[pass]
++++
</pre>
++++

[discrete]
=== byte

SHARED TYPE!
[pass]
++++
<pre>
++++
type number = number
[pass]
++++
</pre>
++++

[discrete]
=== double

SHARED TYPE!
[pass]
++++
<pre>
++++
type number = number
[pass]
++++
</pre>
++++

[discrete]
=== float

SHARED TYPE!
[pass]
++++
<pre>
++++
type number = number
[pass]
++++
</pre>
++++

[discrete]
=== integer

SHARED TYPE!
[pass]
++++
<pre>
++++
type number = number
[pass]
++++
</pre>
++++

[discrete]
=== long

SHARED TYPE!
[pass]
++++
<pre>
++++
type number = number
[pass]
++++
</pre>
++++

[discrete]
=== short

SHARED TYPE!
[pass]
++++
<pre>
++++
type number = number
[pass]
++++
</pre>
++++

[discrete]
=== uint

SHARED TYPE!
[pass]
++++
<pre>
++++
type number = number
[pass]
++++
</pre>
++++

[discrete]
=== ulong

SHARED TYPE!
[pass]
++++
<pre>
++++
type number = number
[pass]
++++
</pre>
++++

[discrete]
=== SpecUtilsBaseNode

SHARED TYPE!
[pass]
++++
<pre>
++++
interface SpecUtilsBaseNode {
  attributes: Record<string, string>
  host: <<Host>>
  ip: <<Ip>>
  name: <<Name>>
  roles?: <<NodeRoles>>
  transport_address: <<TransportAddress>>
}
[pass]
++++
</pre>
++++

[discrete]
=== SpecUtilsNullValue

SHARED TYPE!
[pass]
++++
<pre>
++++
type SpecUtilsNullValue = null
[pass]
++++
</pre>
++++

[discrete]
=== SpecUtilsPipeSeparatedFlags

SHARED TYPE!
[pass]
++++
<pre>
++++
type SpecUtilsPipeSeparatedFlags<T = unknown> = T | string
[pass]
++++
</pre>
++++

[discrete]
=== SpecUtilsStringified

SHARED TYPE!
[pass]
++++
<pre>
++++
type SpecUtilsStringified<T = unknown> = T | string
[pass]
++++
</pre>
++++

[discrete]
=== SpecUtilsVoid

SHARED TYPE!
[pass]
++++
<pre>
++++

[pass]
++++
</pre>
++++

[discrete]
=== SpecUtilsWithNullValue

SHARED TYPE!
[pass]
++++
<pre>
++++
type SpecUtilsWithNullValue<T = unknown> = T | <<SpecUtilsNullValue>>
[pass]
++++
</pre>
++++

[discrete]
=== SpecUtilsAdditionalProperties

SHARED TYPE!
[pass]
++++
<pre>
++++
interface SpecUtilsAdditionalProperties<TKey = unknown, TValue = unknown> {
}
[pass]
++++
</pre>
++++

[discrete]
=== SpecUtilsAdditionalProperty

SHARED TYPE!
[pass]
++++
<pre>
++++
interface SpecUtilsAdditionalProperty<TKey = unknown, TValue = unknown> {
}
[pass]
++++
</pre>
++++

[discrete]
=== SpecUtilsCommonQueryParameters

SHARED TYPE!
[pass]
++++
<pre>
++++
interface SpecUtilsCommonQueryParameters {
  /** @property error_trace When set to `true` Elasticsearch will include the full stack trace of errors when they occur. */
  error_trace?: boolean
  /** @property filter_path Comma-separated list of filters in dot notation which reduce the response returned by Elasticsearch. */
  filter_path?: string | string[]
  /** @property human When set to `true` will return statistics in a format suitable for humans. For example `"exists_time": "1h"` for humans and `"eixsts_time_in_millis": 3600000` for computers. When disabled the human readable values will be omitted. This makes sense for responses being consumed only by machines. */
  human?: boolean
  /** @property pretty If set to `true` the returned JSON will be "pretty-formatted". Only use this option for debugging only. */
  pretty?: boolean
}
[pass]
++++
</pre>
++++

[discrete]
=== SpecUtilsCommonCatQueryParameters

SHARED TYPE!
[pass]
++++
<pre>
++++
interface SpecUtilsCommonCatQueryParameters {
  /** @property format Specifies the format to return the columnar data in, can be set to `text`, `json`, `cbor`, `yaml`, or `smile`. */
  format?: string
  /** @property h List of columns to appear in the response. Supports simple wildcards. */
  h?: <<Names>>
  /** @property help When set to `true` will output available columns. This option can't be combined with any other query string option. */
  help?: boolean
  /** @property local If `true`, the request computes the list of selected nodes from the local cluster state. If `false` the list of selected nodes are computed from the cluster state of the master node. In both cases the coordinating node will send requests for further information to each selected node. */
  local?: boolean
  /** @property master_timeout Period to wait for a connection to the master node. */
  master_timeout?: <<Duration>>
  /** @property s List of columns that determine how the table should be sorted. Sorting defaults to ascending and can be changed by setting `:asc` or `:desc` as a suffix to the column name. */
  s?: <<Names>>
  /** @property v When set to `true` will enable verbose output. */
  v?: boolean
}
[pass]
++++
</pre>
++++

[discrete]
=== SpecUtilsOverloadOf

SHARED TYPE!
[pass]
++++
<pre>
++++
interface SpecUtilsOverloadOf<TDefinition = unknown> {
}
[pass]
++++
</pre>
++++
