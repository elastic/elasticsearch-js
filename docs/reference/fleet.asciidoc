[[reference-fleet]]
== client.fleet

////////
===========================================================================================================================
||                                                                                                                       ||
||                                                                                                                       ||
||                                                                                                                       ||
||        ██████╗ ███████╗ █████╗ ██████╗ ███╗   ███╗███████╗                                                            ||
||        ██╔══██╗██╔════╝██╔══██╗██╔══██╗████╗ ████║██╔════╝                                                            ||
||        ██████╔╝█████╗  ███████║██║  ██║██╔████╔██║█████╗                                                              ||
||        ██╔══██╗██╔══╝  ██╔══██║██║  ██║██║╚██╔╝██║██╔══╝                                                              ||
||        ██║  ██║███████╗██║  ██║██████╔╝██║ ╚═╝ ██║███████╗                                                            ||
||        ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝     ╚═╝╚══════╝                                                            ||
||                                                                                                                       ||
||                                                                                                                       ||
||    This file is autogenerated, DO NOT send pull requests that changes this file directly.                             ||
||    You should update the script that does the generation, which can be found in:                                      ||
||    https://github.com/elastic/elastic-client-generator-js                                                             ||
||                                                                                                                       ||
||    You can run the script with the following command:                                                                 ||
||       npm run elasticsearch -- --version <version>                                                                    ||
||                                                                                                                       ||
||                                                                                                                       ||
||                                                                                                                       ||
===========================================================================================================================
////////
++++
<style>
.lang-ts a.xref {
  text-decoration: underline !important;
}
</style>
++++


[discrete]
[[client.fleet.globalCheckpoints]]
== `client.fleet.globalCheckpoints()`

Get global checkpoints. Get the current global checkpoints for an index. This API is designed for internal use by the Fleet server project.

{ref}/get-global-checkpoints.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: FleetGlobalCheckpointsRequest, options?: TransportRequestOptions) => Promise<FleetGlobalCheckpointsResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface FleetGlobalCheckpointsRequest extends <<RequestBase>> {
  index: <<IndexName>> | <<IndexAlias>>
  wait_for_advance?: boolean
  wait_for_index?: boolean
  checkpoints?: <<FleetCheckpoint>>[]
  timeout?: <<Duration>>
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
interface FleetGlobalCheckpointsResponse {
  global_checkpoints: <<FleetCheckpoint>>[]
  timed_out: boolean
}

----


[discrete]
[[client.fleet.msearch]]
== `client.fleet.msearch()`

Run multiple Fleet searches. Run several Fleet searches with a single API request. The API follows the same structure as the multi search API. However, similar to the Fleet search API, it supports the `wait_for_checkpoints` parameter.
[discrete]
=== Function signature

[source,ts]
----
(request: FleetMsearchRequest, options?: TransportRequestOptions) => Promise<FleetMsearchResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface FleetMsearchRequest extends <<RequestBase>> {
  index?: <<IndexName>> | <<IndexAlias>>
  allow_no_indices?: boolean
  ccs_minimize_roundtrips?: boolean
  expand_wildcards?: <<ExpandWildcards>>
  ignore_throttled?: boolean
  ignore_unavailable?: boolean
  max_concurrent_searches?: <<long>>
  max_concurrent_shard_requests?: <<long>>
  pre_filter_shard_size?: <<long>>
  search_type?: <<SearchType>>
  rest_total_hits_as_int?: boolean
  typed_keys?: boolean
  wait_for_checkpoints?: <<FleetCheckpoint>>[]
  allow_partial_search_results?: boolean
  searches?: <<MsearchRequestItem>>[]
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
interface FleetMsearchResponse<TDocument = unknown> {
  docs: <<MsearchResponseItem>><TDocument>[]
}

----


[discrete]
[[client.fleet.search]]
== `client.fleet.search()`

Run a Fleet search. The purpose of the Fleet search API is to provide an API where the search will be run only after the provided checkpoint has been processed and is visible for searches inside of Elasticsearch.
[discrete]
=== Function signature

[source,ts]
----
(request: FleetSearchRequest, options?: TransportRequestOptions) => Promise<FleetSearchResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface FleetSearchRequest extends <<RequestBase>> {
  index: <<IndexName>> | <<IndexAlias>>
  allow_no_indices?: boolean
  analyzer?: string
  analyze_wildcard?: boolean
  batched_reduce_size?: <<long>>
  ccs_minimize_roundtrips?: boolean
  default_operator?: <<QueryDslOperator>>
  df?: string
  expand_wildcards?: <<ExpandWildcards>>
  ignore_throttled?: boolean
  ignore_unavailable?: boolean
  lenient?: boolean
  max_concurrent_shard_requests?: <<long>>
  preference?: string
  pre_filter_shard_size?: <<long>>
  request_cache?: boolean
  routing?: <<Routing>>
  scroll?: <<Duration>>
  search_type?: <<SearchType>>
  suggest_field?: <<Field>>
  suggest_mode?: <<SuggestMode>>
  suggest_size?: <<long>>
  suggest_text?: string
  typed_keys?: boolean
  rest_total_hits_as_int?: boolean
  _source_excludes?: <<Fields>>
  _source_includes?: <<Fields>>
  q?: string
  wait_for_checkpoints?: <<FleetCheckpoint>>[]
  allow_partial_search_results?: boolean
  aggregations?: Record<string, <<AggregationsAggregationContainer>>>
  pass:[/**] @alias aggregations */
  aggs?: Record<string, <<AggregationsAggregationContainer>>>
  collapse?: <<SearchFieldCollapse>>
  explain?: boolean
  ext?: Record<string, any>
  from?: <<integer>>
  highlight?: <<SearchHighlight>>
  track_total_hits?: <<SearchTrackHits>>
  indices_boost?: Record<<<IndexName>>, <<double>>>[]
  docvalue_fields?: (<<QueryDslFieldAndFormat>> | <<Field>>)[]
  min_score?: <<double>>
  post_filter?: <<QueryDslQueryContainer>>
  profile?: boolean
  query?: <<QueryDslQueryContainer>>
  rescore?: <<SearchRescore>> | <<SearchRescore>>[]
  script_fields?: Record<string, <<ScriptField>>>
  search_after?: <<SortResults>>
  size?: <<integer>>
  slice?: <<SlicedScroll>>
  sort?: <<Sort>>
  _source?: <<SearchSourceConfig>>
  fields?: (<<QueryDslFieldAndFormat>> | <<Field>>)[]
  suggest?: <<SearchSuggester>>
  terminate_after?: <<long>>
  timeout?: string
  track_scores?: boolean
  version?: boolean
  seq_no_primary_term?: boolean
  stored_fields?: <<Fields>>
  pit?: <<SearchPointInTimeReference>>
  runtime_mappings?: <<MappingRuntimeFields>>
  stats?: string[]
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
interface FleetSearchResponse<TDocument = unknown> {
  took: <<long>>
  timed_out: boolean
  _shards: <<ShardStatistics>>
  hits: <<SearchHitsMetadata>><TDocument>
  aggregations?: Record<<<AggregateName>>, <<AggregationsAggregate>>>
  _clusters?: <<ClusterStatistics>>
  fields?: Record<string, any>
  max_score?: <<double>>
  num_reduce_phases?: <<long>>
  profile?: <<SearchProfile>>
  pit_id?: <<Id>>
  _scroll_id?: <<ScrollId>>
  suggest?: Record<<<SuggestionName>>, <<SearchSuggest>><TDocument>[]>
  terminated_early?: boolean
}

----


