# `TextStructureFindFieldStructureRequest` [interface-TextStructureFindFieldStructureRequest]

| Name | Type | Description |
| - | - | - |
| `body` | string | ({ [key: string]: any; } & { column_names?: never; delimiter?: never; documents_to_sample?: never; ecs_compatibility?: never; explain?: never; field?: never; format?: never; grok_pattern?: never; index?: never; quote?: never; should_trim_fields?: never; timeout?: never; timestamp_field?: never; timestamp_format?: never; }) | All values in `body` will be added to the request body. |
| `column_names` | string | If `format` is set to `delimited`, you can specify the column names in a comma-separated list. If this parameter is not specified, the structure finder uses the column names from the header row of the text. If the text does not have a header row, columns are named "column1", "column2", "column3", for example. |
| `delimiter` | string | If you have set `format` to `delimited`, you can specify the character used to delimit the values in each row. Only a single character is supported; the delimiter cannot have multiple characters. By default, the API considers the following possibilities: comma, tab, semi-colon, and pipe ( `|`). In this default scenario, all rows must have the same number of fields for the delimited format to be detected. If you specify a delimiter, up to 10% of the rows can have a different number of columns than the first row. |
| `documents_to_sample` | [uint](./uint.md) | The number of documents to include in the structural analysis. The minimum value is 2. |
| `ecs_compatibility` | [TextStructureEcsCompatibilityType](./TextStructureEcsCompatibilityType.md) | The mode of compatibility with ECS compliant Grok patterns. Use this parameter to specify whether to use ECS Grok patterns instead of legacy ones when the structure finder creates a Grok pattern. This setting primarily has an impact when a whole message Grok pattern such as `%{CATALINALOG}` matches the input. If the structure finder identifies a common structure but has no idea of the meaning then generic field names such as `path`, `ipaddress`, `field1`, and `field2` are used in the `grok_pattern` output. The intention in that situation is that a user who knows the meanings will rename the fields before using them. |
| `explain` | boolean | If `true`, the response includes a field named `explanation`, which is an array of strings that indicate how the structure finder produced its result. |
| `field` | [Field](./Field.md) | The field that should be analyzed. |
| `format` | [TextStructureFormatType](./TextStructureFormatType.md) | The high level structure of the text. By default, the API chooses the format. In this default scenario, all rows must have the same number of fields for a delimited format to be detected. If the format is set to delimited and the delimiter is not set, however, the API tolerates up to 5% of rows that have a different number of columns than the first row. |
| `grok_pattern` | [GrokPattern](./GrokPattern.md) | If the format is `semi_structured_text`, you can specify a Grok pattern that is used to extract fields from every message in the text. The name of the timestamp field in the Grok pattern must match what is specified in the `timestamp_field` parameter. If that parameter is not specified, the name of the timestamp field in the Grok pattern must match "timestamp". If `grok_pattern` is not specified, the structure finder creates a Grok pattern. |
| `index` | [IndexName](./IndexName.md) | The name of the index that contains the analyzed field. |
| `querystring` | { [key: string]: any; } & { column_names?: never; delimiter?: never; documents_to_sample?: never; ecs_compatibility?: never; explain?: never; field?: never; format?: never; grok_pattern?: never; index?: never; quote?: never; should_trim_fields?: never; timeout?: never; timestamp_field?: never; timestamp_format?: never; } | All values in `querystring` will be added to the request querystring. |
| `quote` | string | If the format is `delimited`, you can specify the character used to quote the values in each row if they contain newlines or the delimiter character. Only a single character is supported. If this parameter is not specified, the default value is a double quote ( `"`). If your delimited text format does not use quoting, a workaround is to set this argument to a character that does not appear anywhere in the sample. |
| `should_trim_fields` | boolean | If the format is `delimited`, you can specify whether values between delimiters should have whitespace trimmed from them. If this parameter is not specified and the delimiter is pipe ( `|`), the default value is true. Otherwise, the default value is `false`. |
| `timeout` | [Duration](./Duration.md) | The maximum amount of time that the structure analysis can take. If the analysis is still running when the timeout expires, it will be stopped. |
| `timestamp_field` | [Field](./Field.md) | The name of the field that contains the primary timestamp of each record in the text. In particular, if the text was ingested into an index, this is the field that would be used to populate the `@timestamp` field. If the format is `semi_structured_text`, this field must match the name of the appropriate extraction in the `grok_pattern`. Therefore, for semi-structured text, it is best not to specify this parameter unless `grok_pattern` is also specified. For structured text, if you specify this parameter, the field must exist within the text. If this parameter is not specified, the structure finder makes a decision about which field (if any) is the primary timestamp field. For structured text, it is not compulsory to have a timestamp in the text. |
| `timestamp_format` | string | The Java time format of the timestamp field in the text. Only a subset of Java time format letter groups are supported: * `a` * `d` * `dd` * `EEE` * `EEEE` * `H` * `HH` * `h` * `M` * `MM` * `MMM` * `MMMM` * `mm` * `ss` * `XX` * `XXX` * `yy` * `yyyy` * `zzz`Additionally `S` letter groups (fractional seconds) of length one to nine are supported providing they occur after `ss` and are separated from the `ss` by a period ( `.`), comma ( `,`), or colon ( `:`). Spacing and punctuation is also permitted with the exception a question mark ( `?`), newline, and carriage return, together with literal text enclosed in single quotes. For example, `MM/dd HH.mm.ss,SSSSSS 'in' yyyy` is a valid override format. One valuable use case for this parameter is when the format is semi-structured text, there are multiple timestamp formats in the text, and you know which format corresponds to the primary timestamp, but you do not want to specify the full `grok_pattern`. Another is when the timestamp format is one that the structure finder does not consider by default. If this parameter is not specified, the structure finder chooses the best format from a built-in set. If the special value `null` is specified, the structure finder will not look for a primary timestamp in the text. When the format is semi-structured text, this will result in the structure finder treating the text as single-line messages. |
