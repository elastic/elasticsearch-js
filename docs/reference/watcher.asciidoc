[[reference-watcher]]
== client.watcher

////////
===========================================================================================================================
||                                                                                                                       ||
||                                                                                                                       ||
||                                                                                                                       ||
||        ██████╗ ███████╗ █████╗ ██████╗ ███╗   ███╗███████╗                                                            ||
||        ██╔══██╗██╔════╝██╔══██╗██╔══██╗████╗ ████║██╔════╝                                                            ||
||        ██████╔╝█████╗  ███████║██║  ██║██╔████╔██║█████╗                                                              ||
||        ██╔══██╗██╔══╝  ██╔══██║██║  ██║██║╚██╔╝██║██╔══╝                                                              ||
||        ██║  ██║███████╗██║  ██║██████╔╝██║ ╚═╝ ██║███████╗                                                            ||
||        ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝     ╚═╝╚══════╝                                                            ||
||                                                                                                                       ||
||                                                                                                                       ||
||    This file is autogenerated, DO NOT send pull requests that changes this file directly.                             ||
||    You should update the script that does the generation, which can be found in:                                      ||
||    https://github.com/elastic/elastic-client-generator-js                                                             ||
||                                                                                                                       ||
||    You can run the script with the following command:                                                                 ||
||       npm run elasticsearch -- --version <version>                                                                    ||
||                                                                                                                       ||
||                                                                                                                       ||
||                                                                                                                       ||
===========================================================================================================================
////////
++++
<style>
.lang-ts a.xref {
  text-decoration: underline !important;
}
</style>
++++


[discrete]
[[client.watcher.ackWatch]]
== `client.watcher.ackWatch()`

Acknowledges a watch, manually throttling the execution of the watch's actions.

{ref}/watcher-api-ack-watch.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: WatcherAckWatchRequest, options?: TransportRequestOptions) => Promise<WatcherAckWatchResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface WatcherAckWatchRequest extends <<RequestBase>> {
  watch_id: <<Name>>
  action_id?: <<Names>>
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
interface WatcherAckWatchResponse {
  status: <<WatcherWatchStatus>>
}

----


[discrete]
[[client.watcher.activateWatch]]
== `client.watcher.activateWatch()`

Activates a currently inactive watch.

{ref}/watcher-api-activate-watch.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: WatcherActivateWatchRequest, options?: TransportRequestOptions) => Promise<WatcherActivateWatchResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface WatcherActivateWatchRequest extends <<RequestBase>> {
  watch_id: <<Name>>
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
interface WatcherActivateWatchResponse {
  status: <<WatcherActivationStatus>>
}

----


[discrete]
[[client.watcher.deactivateWatch]]
== `client.watcher.deactivateWatch()`

Deactivates a currently active watch.

{ref}/watcher-api-deactivate-watch.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: WatcherDeactivateWatchRequest, options?: TransportRequestOptions) => Promise<WatcherDeactivateWatchResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface WatcherDeactivateWatchRequest extends <<RequestBase>> {
  watch_id: <<Name>>
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
interface WatcherDeactivateWatchResponse {
  status: <<WatcherActivationStatus>>
}

----


[discrete]
[[client.watcher.deleteWatch]]
== `client.watcher.deleteWatch()`

Removes a watch from Watcher.

{ref}/watcher-api-delete-watch.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: WatcherDeleteWatchRequest, options?: TransportRequestOptions) => Promise<WatcherDeleteWatchResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface WatcherDeleteWatchRequest extends <<RequestBase>> {
  id: <<Name>>
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
interface WatcherDeleteWatchResponse {
  found: boolean
  _id: <<Id>>
  _version: <<VersionNumber>>
}

----


[discrete]
[[client.watcher.executeWatch]]
== `client.watcher.executeWatch()`

This API can be used to force execution of the watch outside of its triggering logic or to simulate the watch execution for debugging purposes. For testing and debugging purposes, you also have fine-grained control on how the watch runs. You can execute the watch without executing all of its actions or alternatively by simulating them. You can also force execution by ignoring the watch condition and control whether a watch record would be written to the watch history after execution.

{ref}/watcher-api-execute-watch.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: WatcherExecuteWatchRequest, options?: TransportRequestOptions) => Promise<WatcherExecuteWatchResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface WatcherExecuteWatchRequest extends <<RequestBase>> {
  id?: <<Id>>
  debug?: boolean
  action_modes?: Record<string, <<WatcherActionExecutionMode>>>
  alternative_input?: Record<string, any>
  ignore_condition?: boolean
  record_execution?: boolean
  simulated_actions?: <<WatcherSimulatedActions>>
  trigger_data?: <<WatcherScheduleTriggerEvent>>
  watch?: <<WatcherWatch>>
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
interface WatcherExecuteWatchResponse {
  _id: <<Id>>
  watch_record: WatcherExecuteWatchWatchRecord
}

----


[discrete]
[[client.watcher.getSettings]]
== `client.watcher.getSettings()`

Retrieve settings for the watcher system index

{ref}/watcher-api-get-settings.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: WatcherGetSettingsRequest, options?: TransportRequestOptions) => Promise<WatcherGetSettingsResponse>
----

[discrete]
[[client.watcher.getWatch]]
== `client.watcher.getWatch()`

Retrieves a watch by its ID.

{ref}/watcher-api-get-watch.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: WatcherGetWatchRequest, options?: TransportRequestOptions) => Promise<WatcherGetWatchResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface WatcherGetWatchRequest extends <<RequestBase>> {
  id: <<Name>>
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
interface WatcherGetWatchResponse {
  found: boolean
  _id: <<Id>>
  status?: <<WatcherWatchStatus>>
  watch?: <<WatcherWatch>>
  _primary_term?: <<integer>>
  _seq_no?: <<SequenceNumber>>
  _version?: <<VersionNumber>>
}

----


[discrete]
[[client.watcher.putWatch]]
== `client.watcher.putWatch()`

Creates a new watch, or updates an existing one.

{ref}/watcher-api-put-watch.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: WatcherPutWatchRequest, options?: TransportRequestOptions) => Promise<WatcherPutWatchResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface WatcherPutWatchRequest extends <<RequestBase>> {
  id: <<Id>>
  active?: boolean
  if_primary_term?: <<long>>
  if_seq_no?: <<SequenceNumber>>
  version?: <<VersionNumber>>
  actions?: Record<string, <<WatcherAction>>>
  condition?: <<WatcherConditionContainer>>
  input?: <<WatcherInputContainer>>
  metadata?: <<Metadata>>
  throttle_period?: string
  transform?: <<TransformContainer>>
  trigger?: <<WatcherTriggerContainer>>
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
interface WatcherPutWatchResponse {
  created: boolean
  _id: <<Id>>
  _primary_term: <<long>>
  _seq_no: <<SequenceNumber>>
  _version: <<VersionNumber>>
}

----


[discrete]
[[client.watcher.queryWatches]]
== `client.watcher.queryWatches()`

Retrieves stored watches.

{ref}/watcher-api-query-watches.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: WatcherQueryWatchesRequest, options?: TransportRequestOptions) => Promise<WatcherQueryWatchesResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface WatcherQueryWatchesRequest extends <<RequestBase>> {
  from?: <<integer>>
  size?: <<integer>>
  query?: <<QueryDslQueryContainer>>
  sort?: <<Sort>>
  search_after?: <<SortResults>>
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
interface WatcherQueryWatchesResponse {
  count: <<integer>>
  watches: <<WatcherQueryWatch>>[]
}

----


[discrete]
[[client.watcher.start]]
== `client.watcher.start()`

Starts Watcher if it is not already running.

{ref}/watcher-api-start.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: WatcherStartRequest, options?: TransportRequestOptions) => Promise<WatcherStartResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface WatcherStartRequest extends <<RequestBase>> {}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
type WatcherStartResponse = <<AcknowledgedResponseBase>>

----


[discrete]
[[client.watcher.stats]]
== `client.watcher.stats()`

Retrieves the current Watcher metrics.

{ref}/watcher-api-stats.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: WatcherStatsRequest, options?: TransportRequestOptions) => Promise<WatcherStatsResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface WatcherStatsRequest extends <<RequestBase>> {
  metric?: WatcherStatsWatcherMetric | WatcherStatsWatcherMetric[]
  emit_stacktraces?: boolean
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
interface WatcherStatsResponse {
  _nodes: <<NodeStatistics>>
  cluster_name: <<Name>>
  manually_stopped: boolean
  stats: WatcherStatsWatcherNodeStats[]
}

----


[discrete]
[[client.watcher.stop]]
== `client.watcher.stop()`

Stops Watcher if it is running.

{ref}/watcher-api-stop.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: WatcherStopRequest, options?: TransportRequestOptions) => Promise<WatcherStopResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface WatcherStopRequest extends <<RequestBase>> {}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
type WatcherStopResponse = <<AcknowledgedResponseBase>>

----


[discrete]
[[client.watcher.updateSettings]]
== `client.watcher.updateSettings()`

Update settings for the watcher system index

{ref}/watcher-api-update-settings.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: WatcherUpdateSettingsRequest, options?: TransportRequestOptions) => Promise<WatcherUpdateSettingsResponse>
----

