[[reference-cluster]]
== client.cluster

////////
===========================================================================================================================
||                                                                                                                       ||
||                                                                                                                       ||
||                                                                                                                       ||
||        ██████╗ ███████╗ █████╗ ██████╗ ███╗   ███╗███████╗                                                            ||
||        ██╔══██╗██╔════╝██╔══██╗██╔══██╗████╗ ████║██╔════╝                                                            ||
||        ██████╔╝█████╗  ███████║██║  ██║██╔████╔██║█████╗                                                              ||
||        ██╔══██╗██╔══╝  ██╔══██║██║  ██║██║╚██╔╝██║██╔══╝                                                              ||
||        ██║  ██║███████╗██║  ██║██████╔╝██║ ╚═╝ ██║███████╗                                                            ||
||        ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝     ╚═╝╚══════╝                                                            ||
||                                                                                                                       ||
||                                                                                                                       ||
||    This file is autogenerated, DO NOT send pull requests that changes this file directly.                             ||
||    You should update the script that does the generation, which can be found in:                                      ||
||    https://github.com/elastic/elastic-client-generator-js                                                             ||
||                                                                                                                       ||
||    You can run the script with the following command:                                                                 ||
||       npm run elasticsearch -- --version <version>                                                                    ||
||                                                                                                                       ||
||                                                                                                                       ||
||                                                                                                                       ||
===========================================================================================================================
////////
++++
<style>
.lang-ts a.xref {
  text-decoration: underline !important;
}
</style>
++++


[discrete]
[[client.cluster.allocationExplain]]
== `client.cluster.allocationExplain()`

Provides explanations for shard allocations in the cluster.

{ref}/cluster-allocation-explain.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: ClusterAllocationExplainRequest, options?: TransportRequestOptions) => Promise<ClusterAllocationExplainResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface ClusterAllocationExplainRequest extends <<RequestBase>> {
  include_disk_info?: boolean
  include_yes_decisions?: boolean
  current_node?: string
  index?: <<IndexName>>
  primary?: boolean
  shard?: <<integer>>
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
interface ClusterAllocationExplainResponse {
  allocate_explanation?: string
  allocation_delay?: <<Duration>>
  allocation_delay_in_millis?: <<DurationValue>><<<UnitMillis>>>
  can_allocate?: ClusterAllocationExplainDecision
  can_move_to_other_node?: ClusterAllocationExplainDecision
  can_rebalance_cluster?: ClusterAllocationExplainDecision
  can_rebalance_cluster_decisions?: ClusterAllocationExplainAllocationDecision[]
  can_rebalance_to_other_node?: ClusterAllocationExplainDecision
  can_remain_decisions?: ClusterAllocationExplainAllocationDecision[]
  can_remain_on_current_node?: ClusterAllocationExplainDecision
  cluster_info?: ClusterAllocationExplainClusterInfo
  configured_delay?: <<Duration>>
  configured_delay_in_millis?: <<DurationValue>><<<UnitMillis>>>
  current_node?: ClusterAllocationExplainCurrentNode
  current_state: string
  index: <<IndexName>>
  move_explanation?: string
  node_allocation_decisions?: ClusterAllocationExplainNodeAllocationExplanation[]
  primary: boolean
  rebalance_explanation?: string
  remaining_delay?: <<Duration>>
  remaining_delay_in_millis?: <<DurationValue>><<<UnitMillis>>>
  shard: <<integer>>
  unassigned_info?: ClusterAllocationExplainUnassignedInformation
  note?: string
}

----


[discrete]
[[client.cluster.deleteComponentTemplate]]
== `client.cluster.deleteComponentTemplate()`

Delete component templates. Deletes component templates. Component templates are building blocks for constructing index templates that specify index mappings, settings, and aliases.

{ref}/indices-component-template.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: ClusterDeleteComponentTemplateRequest, options?: TransportRequestOptions) => Promise<ClusterDeleteComponentTemplateResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface ClusterDeleteComponentTemplateRequest extends <<RequestBase>> {
  name: <<Names>>
  master_timeout?: <<Duration>>
  timeout?: <<Duration>>
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
type ClusterDeleteComponentTemplateResponse = <<AcknowledgedResponseBase>>

----


[discrete]
[[client.cluster.deleteVotingConfigExclusions]]
== `client.cluster.deleteVotingConfigExclusions()`

Clears cluster voting config exclusions.

{ref}/voting-config-exclusions.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: ClusterDeleteVotingConfigExclusionsRequest, options?: TransportRequestOptions) => Promise<ClusterDeleteVotingConfigExclusionsResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface ClusterDeleteVotingConfigExclusionsRequest extends <<RequestBase>> {
  wait_for_removal?: boolean
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
type ClusterDeleteVotingConfigExclusionsResponse = boolean

----


[discrete]
[[client.cluster.existsComponentTemplate]]
== `client.cluster.existsComponentTemplate()`

Check component templates. Returns information about whether a particular component template exists.

{ref}/indices-component-template.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: ClusterExistsComponentTemplateRequest, options?: TransportRequestOptions) => Promise<ClusterExistsComponentTemplateResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface ClusterExistsComponentTemplateRequest extends <<RequestBase>> {
  name: <<Names>>
  master_timeout?: <<Duration>>
  local?: boolean
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
type ClusterExistsComponentTemplateResponse = boolean

----


[discrete]
[[client.cluster.getComponentTemplate]]
== `client.cluster.getComponentTemplate()`

Get component templates. Retrieves information about component templates.

{ref}/indices-component-template.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: ClusterGetComponentTemplateRequest, options?: TransportRequestOptions) => Promise<ClusterGetComponentTemplateResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface ClusterGetComponentTemplateRequest extends <<RequestBase>> {
  name?: <<Name>>
  flat_settings?: boolean
  include_defaults?: boolean
  local?: boolean
  master_timeout?: <<Duration>>
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
interface ClusterGetComponentTemplateResponse {
  component_templates: <<ClusterComponentTemplate>>[]
}

----


[discrete]
[[client.cluster.getSettings]]
== `client.cluster.getSettings()`

Returns cluster-wide settings. By default, it returns only settings that have been explicitly defined.

{ref}/cluster-get-settings.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: ClusterGetSettingsRequest, options?: TransportRequestOptions) => Promise<ClusterGetSettingsResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface ClusterGetSettingsRequest extends <<RequestBase>> {
  flat_settings?: boolean
  include_defaults?: boolean
  master_timeout?: <<Duration>>
  timeout?: <<Duration>>
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
interface ClusterGetSettingsResponse {
  persistent: Record<string, any>
  transient: Record<string, any>
  defaults?: Record<string, any>
}

----


[discrete]
[[client.cluster.health]]
== `client.cluster.health()`

The cluster health API returns a simple status on the health of the cluster. You can also use the API to get the health status of only specified data streams and indices. For data streams, the API retrieves the health status of the stream’s backing indices. The cluster health status is: green, yellow or red. On the shard level, a red status indicates that the specific shard is not allocated in the cluster, yellow means that the primary shard is allocated but replicas are not, and green means that all shards are allocated. The index level status is controlled by the worst shard status. The cluster status is controlled by the worst index status.

{ref}/cluster-health.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: ClusterHealthRequest, options?: TransportRequestOptions) => Promise<ClusterHealthResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface ClusterHealthRequest extends <<RequestBase>> {
  index?: <<Indices>>
  expand_wildcards?: <<ExpandWildcards>>
  level?: <<Level>>
  local?: boolean
  master_timeout?: <<Duration>>
  timeout?: <<Duration>>
  wait_for_active_shards?: <<WaitForActiveShards>>
  wait_for_events?: <<WaitForEvents>>
  wait_for_nodes?: string | <<integer>>
  wait_for_no_initializing_shards?: boolean
  wait_for_no_relocating_shards?: boolean
  wait_for_status?: <<HealthStatus>>
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
type ClusterHealthResponse = ClusterHealthHealthResponseBody

----


[discrete]
[[client.cluster.info]]
== `client.cluster.info()`

Get cluster info. Returns basic information about the cluster.

{ref}/cluster-info.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: ClusterInfoRequest, options?: TransportRequestOptions) => Promise<ClusterInfoResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface ClusterInfoRequest extends <<RequestBase>> {
  target: <<ClusterInfoTargets>>
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
interface ClusterInfoResponse {
  cluster_name: <<Name>>
  http?: <<NodesHttp>>
  ingest?: <<NodesIngest>>
  thread_pool?: Record<string, <<NodesThreadCount>>>
  script?: <<NodesScripting>>
}

----


[discrete]
[[client.cluster.pendingTasks]]
== `client.cluster.pendingTasks()`

Returns cluster-level changes (such as create index, update mapping, allocate or fail shard) that have not yet been executed. NOTE: This API returns a list of any pending updates to the cluster state. These are distinct from the tasks reported by the Task Management API which include periodic tasks and tasks initiated by the user, such as node stats, search queries, or create index requests. However, if a user-initiated task such as a create index command causes a cluster state update, the activity of this task might be reported by both task api and pending cluster tasks API.

{ref}/cluster-pending.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: ClusterPendingTasksRequest, options?: TransportRequestOptions) => Promise<ClusterPendingTasksResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface ClusterPendingTasksRequest extends <<RequestBase>> {
  local?: boolean
  master_timeout?: <<Duration>>
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
interface ClusterPendingTasksResponse {
  tasks: ClusterPendingTasksPendingTask[]
}

----


[discrete]
[[client.cluster.postVotingConfigExclusions]]
== `client.cluster.postVotingConfigExclusions()`

Updates the cluster voting config exclusions by node ids or node names.

{ref}/voting-config-exclusions.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: ClusterPostVotingConfigExclusionsRequest, options?: TransportRequestOptions) => Promise<ClusterPostVotingConfigExclusionsResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface ClusterPostVotingConfigExclusionsRequest extends <<RequestBase>> {
  node_names?: <<Names>>
  node_ids?: <<Ids>>
  timeout?: <<Duration>>
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
type ClusterPostVotingConfigExclusionsResponse = boolean

----


[discrete]
[[client.cluster.putComponentTemplate]]
== `client.cluster.putComponentTemplate()`

Create or update a component template. Creates or updates a component template. Component templates are building blocks for constructing index templates that specify index mappings, settings, and aliases. An index template can be composed of multiple component templates. To use a component template, specify it in an index template’s `composed_of` list. Component templates are only applied to new data streams and indices as part of a matching index template. Settings and mappings specified directly in the index template or the create index request override any settings or mappings specified in a component template. Component templates are only used during index creation. For data streams, this includes data stream creation and the creation of a stream’s backing indices. Changes to component templates do not affect existing indices, including a stream’s backing indices. You can use C-style `/* *\/` block comments in component templates. You can include comments anywhere in the request body except before the opening curly bracket.

{ref}/indices-component-template.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: ClusterPutComponentTemplateRequest, options?: TransportRequestOptions) => Promise<ClusterPutComponentTemplateResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface ClusterPutComponentTemplateRequest extends <<RequestBase>> {
  name: <<Name>>
  create?: boolean
  master_timeout?: <<Duration>>
  template: <<IndicesIndexState>>
  version?: <<VersionNumber>>
  _meta?: <<Metadata>>
  deprecated?: boolean
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
type ClusterPutComponentTemplateResponse = <<AcknowledgedResponseBase>>

----


[discrete]
[[client.cluster.putSettings]]
== `client.cluster.putSettings()`

Updates the cluster settings.

{ref}/cluster-update-settings.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: ClusterPutSettingsRequest, options?: TransportRequestOptions) => Promise<ClusterPutSettingsResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface ClusterPutSettingsRequest extends <<RequestBase>> {
  flat_settings?: boolean
  master_timeout?: <<Duration>>
  timeout?: <<Duration>>
  persistent?: Record<string, any>
  transient?: Record<string, any>
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
interface ClusterPutSettingsResponse {
  acknowledged: boolean
  persistent: Record<string, any>
  transient: Record<string, any>
}

----


[discrete]
[[client.cluster.remoteInfo]]
== `client.cluster.remoteInfo()`

The cluster remote info API allows you to retrieve all of the configured remote cluster information. It returns connection and endpoint information keyed by the configured remote cluster alias.

{ref}/cluster-remote-info.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: ClusterRemoteInfoRequest, options?: TransportRequestOptions) => Promise<ClusterRemoteInfoResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface ClusterRemoteInfoRequest extends <<RequestBase>> {}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
type ClusterRemoteInfoResponse = Record<string, ClusterRemoteInfoClusterRemoteInfo>

----


[discrete]
[[client.cluster.reroute]]
== `client.cluster.reroute()`

Allows to manually change the allocation of individual shards in the cluster.

{ref}/cluster-reroute.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: ClusterRerouteRequest, options?: TransportRequestOptions) => Promise<ClusterRerouteResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface ClusterRerouteRequest extends <<RequestBase>> {
  dry_run?: boolean
  explain?: boolean
  metric?: <<Metrics>>
  retry_failed?: boolean
  master_timeout?: <<Duration>>
  timeout?: <<Duration>>
  commands?: ClusterRerouteCommand[]
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
interface ClusterRerouteResponse {
  acknowledged: boolean
  explanations?: ClusterRerouteRerouteExplanation[]
  state?: any
}

----


[discrete]
[[client.cluster.state]]
== `client.cluster.state()`

Returns a comprehensive information about the state of the cluster.

{ref}/cluster-state.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: ClusterStateRequest, options?: TransportRequestOptions) => Promise<ClusterStateResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface ClusterStateRequest extends <<RequestBase>> {
  metric?: <<Metrics>>
  index?: <<Indices>>
  allow_no_indices?: boolean
  expand_wildcards?: <<ExpandWildcards>>
  flat_settings?: boolean
  ignore_unavailable?: boolean
  local?: boolean
  master_timeout?: <<Duration>>
  wait_for_metadata_version?: <<VersionNumber>>
  wait_for_timeout?: <<Duration>>
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
type ClusterStateResponse = any

----


[discrete]
[[client.cluster.stats]]
== `client.cluster.stats()`

Returns cluster statistics. It returns basic index metrics (shard numbers, store size, memory usage) and information about the current nodes that form the cluster (number, roles, os, jvm versions, memory usage, cpu and installed plugins).

{ref}/cluster-stats.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: ClusterStatsRequest, options?: TransportRequestOptions) => Promise<ClusterStatsResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface ClusterStatsRequest extends <<RequestBase>> {
  node_id?: <<NodeIds>>
  include_remotes?: boolean
  timeout?: <<Duration>>
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
type ClusterStatsResponse = ClusterStatsStatsResponseBase

----


