[[reference-transform]]
== client.transform

////////
===========================================================================================================================
||                                                                                                                       ||
||                                                                                                                       ||
||                                                                                                                       ||
||        ██████╗ ███████╗ █████╗ ██████╗ ███╗   ███╗███████╗                                                            ||
||        ██╔══██╗██╔════╝██╔══██╗██╔══██╗████╗ ████║██╔════╝                                                            ||
||        ██████╔╝█████╗  ███████║██║  ██║██╔████╔██║█████╗                                                              ||
||        ██╔══██╗██╔══╝  ██╔══██║██║  ██║██║╚██╔╝██║██╔══╝                                                              ||
||        ██║  ██║███████╗██║  ██║██████╔╝██║ ╚═╝ ██║███████╗                                                            ||
||        ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝     ╚═╝╚══════╝                                                            ||
||                                                                                                                       ||
||                                                                                                                       ||
||    This file is autogenerated, DO NOT send pull requests that changes this file directly.                             ||
||    You should update the script that does the generation, which can be found in:                                      ||
||    https://github.com/elastic/elastic-client-generator-js                                                             ||
||                                                                                                                       ||
||    You can run the script with the following command:                                                                 ||
||       npm run elasticsearch -- --version <version>                                                                    ||
||                                                                                                                       ||
||                                                                                                                       ||
||                                                                                                                       ||
===========================================================================================================================
////////
++++
<style>
.lang-ts a.xref {
  text-decoration: underline !important;
}
</style>
++++


[discrete]
[[client.transform.deleteTransform]]
== `client.transform.deleteTransform()`

Delete a transform. Deletes a transform.

{ref}/delete-transform.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: TransformDeleteTransformRequest, options?: TransportRequestOptions) => Promise<TransformDeleteTransformResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface TransformDeleteTransformRequest extends <<RequestBase>> {
  transform_id: <<Id>>
  force?: boolean
  delete_dest_index?: boolean
  timeout?: <<Duration>>
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
type TransformDeleteTransformResponse = <<AcknowledgedResponseBase>>

----


[discrete]
[[client.transform.getNodeStats]]
== `client.transform.getNodeStats()`

Retrieves transform usage information for transform nodes.
[discrete]
=== Function signature

[source,ts]
----
(request: TransformGetNodeStatsRequest, options?: TransportRequestOptions) => Promise<TransformGetNodeStatsResponse>
----

[discrete]
[[client.transform.getTransform]]
== `client.transform.getTransform()`

Get transforms. Retrieves configuration information for transforms.

{ref}/get-transform.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: TransformGetTransformRequest, options?: TransportRequestOptions) => Promise<TransformGetTransformResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface TransformGetTransformRequest extends <<RequestBase>> {
  transform_id?: <<Names>>
  allow_no_match?: boolean
  from?: <<integer>>
  size?: <<integer>>
  exclude_generated?: boolean
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
interface TransformGetTransformResponse {
  count: <<long>>
  transforms: TransformGetTransformTransformSummary[]
}

----


[discrete]
[[client.transform.getTransformStats]]
== `client.transform.getTransformStats()`

Get transform stats. Retrieves usage information for transforms.

{ref}/get-transform-stats.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: TransformGetTransformStatsRequest, options?: TransportRequestOptions) => Promise<TransformGetTransformStatsResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface TransformGetTransformStatsRequest extends <<RequestBase>> {
  transform_id: <<Names>>
  allow_no_match?: boolean
  from?: <<long>>
  size?: <<long>>
  timeout?: <<Duration>>
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
interface TransformGetTransformStatsResponse {
  count: <<long>>
  transforms: TransformGetTransformStatsTransformStats[]
}

----


[discrete]
[[client.transform.previewTransform]]
== `client.transform.previewTransform()`

Preview a transform. Generates a preview of the results that you will get when you create a transform with the same configuration. It returns a maximum of 100 results. The calculations are based on all the current data in the source index. It also generates a list of mappings and settings for the destination index. These values are determined based on the field types of the source index and the transform aggregations.

{ref}/preview-transform.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: TransformPreviewTransformRequest, options?: TransportRequestOptions) => Promise<TransformPreviewTransformResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface TransformPreviewTransformRequest extends <<RequestBase>> {
  transform_id?: <<Id>>
  timeout?: <<Duration>>
  dest?: <<TransformDestination>>
  description?: string
  frequency?: <<Duration>>
  pivot?: <<TransformPivot>>
  source?: <<TransformSource>>
  settings?: <<TransformSettings>>
  sync?: <<TransformSyncContainer>>
  retention_policy?: <<TransformRetentionPolicyContainer>>
  latest?: <<TransformLatest>>
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
interface TransformPreviewTransformResponse<TTransform = unknown> {
  generated_dest_index: <<IndicesIndexState>>
  preview: TTransform[]
}

----


[discrete]
[[client.transform.putTransform]]
== `client.transform.putTransform()`

Create a transform. Creates a transform. A transform copies data from source indices, transforms it, and persists it into an entity-centric destination index. You can also think of the destination index as a two-dimensional tabular data structure (known as a data frame). The ID for each document in the data frame is generated from a hash of the entity, so there is a unique row per entity. You must choose either the latest or pivot method for your transform; you cannot use both in a single transform. If you choose to use the pivot method for your transform, the entities are defined by the set of `group_by` fields in the pivot object. If you choose to use the latest method, the entities are defined by the `unique_key` field values in the latest object. You must have `create_index`, `index`, and `read` privileges on the destination index and `read` and `view_index_metadata` privileges on the source indices. When Elasticsearch security features are enabled, the transform remembers which roles the user that created it had at the time of creation and uses those same roles. If those roles do not have the required privileges on the source and destination indices, the transform fails when it attempts unauthorized operations. NOTE: You must use Kibana or this API to create a transform. Do not add a transform directly into any `.transform-internal*` indices using the Elasticsearch index API. If Elasticsearch security features are enabled, do not give users any privileges on `.transform-internal*` indices. If you used transforms prior to 7.5, also do not give users any privileges on `.data-frame-internal*` indices.

{ref}/put-transform.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: TransformPutTransformRequest, options?: TransportRequestOptions) => Promise<TransformPutTransformResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface TransformPutTransformRequest extends <<RequestBase>> {
  transform_id: <<Id>>
  defer_validation?: boolean
  timeout?: <<Duration>>
  dest: <<TransformDestination>>
  description?: string
  frequency?: <<Duration>>
  latest?: <<TransformLatest>>
  _meta?: <<Metadata>>
  pivot?: <<TransformPivot>>
  retention_policy?: <<TransformRetentionPolicyContainer>>
  settings?: <<TransformSettings>>
  source: <<TransformSource>>
  sync?: <<TransformSyncContainer>>
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
type TransformPutTransformResponse = <<AcknowledgedResponseBase>>

----


[discrete]
[[client.transform.resetTransform]]
== `client.transform.resetTransform()`

Reset a transform. Resets a transform. Before you can reset it, you must stop it; alternatively, use the `force` query parameter. If the destination index was created by the transform, it is deleted.

{ref}/reset-transform.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: TransformResetTransformRequest, options?: TransportRequestOptions) => Promise<TransformResetTransformResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface TransformResetTransformRequest extends <<RequestBase>> {
  transform_id: <<Id>>
  force?: boolean
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
type TransformResetTransformResponse = <<AcknowledgedResponseBase>>

----


[discrete]
[[client.transform.scheduleNowTransform]]
== `client.transform.scheduleNowTransform()`

Schedule a transform to start now. Instantly runs a transform to process data. If you _schedule_now a transform, it will process the new data instantly, without waiting for the configured frequency interval. After _schedule_now API is called, the transform will be processed again at now + frequency unless _schedule_now API is called again in the meantime.

{ref}/schedule-now-transform.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: TransformScheduleNowTransformRequest, options?: TransportRequestOptions) => Promise<TransformScheduleNowTransformResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface TransformScheduleNowTransformRequest extends <<RequestBase>> {
  transform_id: <<Id>>
  timeout?: <<Duration>>
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
type TransformScheduleNowTransformResponse = <<AcknowledgedResponseBase>>

----


[discrete]
[[client.transform.startTransform]]
== `client.transform.startTransform()`

Start a transform. Starts a transform. When you start a transform, it creates the destination index if it does not already exist. The `number_of_shards` is set to `1` and the `auto_expand_replicas` is set to `0-1`. If it is a pivot transform, it deduces the mapping definitions for the destination index from the source indices and the transform aggregations. If fields in the destination index are derived from scripts (as in the case of `scripted_metric` or `bucket_script` aggregations), the transform uses dynamic mappings unless an index template exists. If it is a latest transform, it does not deduce mapping definitions; it uses dynamic mappings. To use explicit mappings, create the destination index before you start the transform. Alternatively, you can create an index template, though it does not affect the deduced mappings in a pivot transform. When the transform starts, a series of validations occur to ensure its success. If you deferred validation when you created the transform, they occur when you start the transform—with the exception of privilege checks. When Elasticsearch security features are enabled, the transform remembers which roles the user that created it had at the time of creation and uses those same roles. If those roles do not have the required privileges on the source and destination indices, the transform fails when it attempts unauthorized operations.

{ref}/start-transform.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: TransformStartTransformRequest, options?: TransportRequestOptions) => Promise<TransformStartTransformResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface TransformStartTransformRequest extends <<RequestBase>> {
  transform_id: <<Id>>
  timeout?: <<Duration>>
  from?: string
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
type TransformStartTransformResponse = <<AcknowledgedResponseBase>>

----


[discrete]
[[client.transform.stopTransform]]
== `client.transform.stopTransform()`

Stop transforms. Stops one or more transforms.

{ref}/stop-transform.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: TransformStopTransformRequest, options?: TransportRequestOptions) => Promise<TransformStopTransformResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface TransformStopTransformRequest extends <<RequestBase>> {
  transform_id: <<Name>>
  allow_no_match?: boolean
  force?: boolean
  timeout?: <<Duration>>
  wait_for_checkpoint?: boolean
  wait_for_completion?: boolean
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
type TransformStopTransformResponse = <<AcknowledgedResponseBase>>

----


[discrete]
[[client.transform.updateTransform]]
== `client.transform.updateTransform()`

Update a transform. Updates certain properties of a transform. All updated properties except `description` do not take effect until after the transform starts the next checkpoint, thus there is data consistency in each checkpoint. To use this API, you must have `read` and `view_index_metadata` privileges for the source indices. You must also have `index` and `read` privileges for the destination index. When Elasticsearch security features are enabled, the transform remembers which roles the user who updated it had at the time of update and runs with those privileges.

{ref}/update-transform.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: TransformUpdateTransformRequest, options?: TransportRequestOptions) => Promise<TransformUpdateTransformResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface TransformUpdateTransformRequest extends <<RequestBase>> {
  transform_id: <<Id>>
  defer_validation?: boolean
  timeout?: <<Duration>>
  dest?: <<TransformDestination>>
  description?: string
  frequency?: <<Duration>>
  _meta?: <<Metadata>>
  source?: <<TransformSource>>
  settings?: <<TransformSettings>>
  sync?: <<TransformSyncContainer>>
  retention_policy?: <<TransformRetentionPolicyContainer>> | null
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
interface TransformUpdateTransformResponse {
  authorization?: <<MlTransformAuthorization>>
  create_time: <<long>>
  description: string
  dest: <<ReindexDestination>>
  frequency?: <<Duration>>
  id: <<Id>>
  latest?: <<TransformLatest>>
  pivot?: <<TransformPivot>>
  retention_policy?: <<TransformRetentionPolicyContainer>>
  settings: <<TransformSettings>>
  source: <<ReindexSource>>
  sync?: <<TransformSyncContainer>>
  version: <<VersionString>>
  _meta?: <<Metadata>>
}

----


[discrete]
[[client.transform.upgradeTransforms]]
== `client.transform.upgradeTransforms()`

Upgrades all transforms. This API identifies transforms that have a legacy configuration format and upgrades them to the latest version. It also cleans up the internal data structures that store the transform state and checkpoints. The upgrade does not affect the source and destination indices. The upgrade also does not affect the roles that transforms use when Elasticsearch security features are enabled; the role used to read source data and write to the destination index remains unchanged.

{ref}/upgrade-transforms.html[{es} documentation]
[discrete]
=== Function signature

[source,ts]
----
(request: TransformUpgradeTransformsRequest, options?: TransportRequestOptions) => Promise<TransformUpgradeTransformsResponse>
----

[discrete]
=== Request

[source,ts,subs=+macros]
----
interface TransformUpgradeTransformsRequest extends <<RequestBase>> {
  dry_run?: boolean
  timeout?: <<Duration>>
}

----


[discrete]
=== Response

[source,ts,subs=+macros]
----
interface TransformUpgradeTransformsResponse {
  needs_update: <<integer>>
  no_action: <<integer>>
  updated: <<integer>>
}

----


