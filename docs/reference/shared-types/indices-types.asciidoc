[[reference-shared-types-indices-types]]

=== `Indices` types

////////
===========================================================================================================================
||                                                                                                                       ||
||                                                                                                                       ||
||                                                                                                                       ||
||        ██████╗ ███████╗ █████╗ ██████╗ ███╗   ███╗███████╗                                                            ||
||        ██╔══██╗██╔════╝██╔══██╗██╔══██╗████╗ ████║██╔════╝                                                            ||
||        ██████╔╝█████╗  ███████║██║  ██║██╔████╔██║█████╗                                                              ||
||        ██╔══██╗██╔══╝  ██╔══██║██║  ██║██║╚██╔╝██║██╔══╝                                                              ||
||        ██║  ██║███████╗██║  ██║██████╔╝██║ ╚═╝ ██║███████╗                                                            ||
||        ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝     ╚═╝╚══════╝                                                            ||
||                                                                                                                       ||
||                                                                                                                       ||
||    This file is autogenerated, DO NOT send pull requests that changes this file directly.                             ||
||    You should update the script that does the generation, which can be found in:                                      ||
||    https://github.com/elastic/elastic-client-generator-js                                                             ||
||                                                                                                                       ||
||    You can run the script with the following command:                                                                 ||
||       npm run elasticsearch -- --version <version>                                                                    ||
||                                                                                                                       ||
||                                                                                                                       ||
||                                                                                                                       ||
===========================================================================================================================
////////
++++
<style>
.lang-ts a.xref {
  text-decoration: underline !important;
}
</style>
++++


[discrete]
[[IndicesAlias]]
=== IndicesAlias

[source,ts,subs=+macros]
----
interface IndicesAlias {
  pass:[/**] @property filter Query used to limit documents the alias can access. */
  filter?: <<QueryDslQueryContainer>>
  pass:[/**] @property index_routing Value used to route indexing operations to a specific shard. If specified, this overwrites the `routing` value for indexing operations. */
  index_routing?: <<Routing>>
  pass:[/**] @property is_hidden If `true`, the alias is hidden. All indices for the alias must have the same `is_hidden` value. */
  is_hidden?: boolean
  pass:[/**] @property is_write_index If `true`, the index is the write index for the alias. */
  is_write_index?: boolean
  pass:[/**] @property routing Value used to route indexing and search operations to a specific shard. */
  routing?: <<Routing>>
  pass:[/**] @property search_routing Value used to route search operations to a specific shard. If specified, this overwrites the `routing` value for search operations. */
  search_routing?: <<Routing>>
}
----


[discrete]
[[IndicesAliasDefinition]]
=== IndicesAliasDefinition

[source,ts,subs=+macros]
----
interface IndicesAliasDefinition {
  pass:[/**] @property filter Query used to limit documents the alias can access. */
  filter?: <<QueryDslQueryContainer>>
  pass:[/**] @property index_routing Value used to route indexing operations to a specific shard. If specified, this overwrites the `routing` value for indexing operations. */
  index_routing?: string
  pass:[/**] @property is_write_index If `true`, the index is the write index for the alias. */
  is_write_index?: boolean
  pass:[/**] @property routing Value used to route indexing and search operations to a specific shard. */
  routing?: string
  pass:[/**] @property search_routing Value used to route search operations to a specific shard. If specified, this overwrites the `routing` value for search operations. */
  search_routing?: string
  pass:[/**] @property is_hidden If `true`, the alias is hidden. All indices for the alias must have the same `is_hidden` value. */
  is_hidden?: boolean
}
----


[discrete]
[[IndicesCacheQueries]]
=== IndicesCacheQueries

[source,ts,subs=+macros]
----
interface IndicesCacheQueries {
  enabled: boolean
}
----


[discrete]
[[IndicesDataStream]]
=== IndicesDataStream

[source,ts,subs=+macros]
----
interface IndicesDataStream {
  pass:[/**] @property _meta Custom metadata for the stream, copied from the `_meta` object of the stream’s matching index template. If empty, the response omits this property. */
  _meta?: <<Metadata>>
  pass:[/**] @property allow_custom_routing If `true`, the data stream allows custom routing on write request. */
  allow_custom_routing?: boolean
  pass:[/**] @property failure_store Information about failure store backing indices */
  failure_store?: <<IndicesFailureStore>>
  pass:[/**] @property generation Current generation for the data stream. This number acts as a cumulative count of the stream’s rollovers, starting at 1. */
  generation: <<integer>>
  pass:[/**] @property hidden If `true`, the data stream is hidden. */
  hidden: boolean
  pass:[/**] @property ilm_policy <<Name>> of the current ILM lifecycle policy in the stream’s matching index template. This lifecycle policy is set in the `index.lifecycle.name` setting. If the template does not include a lifecycle policy, this property is not included in the response. NOTE: A data stream’s backing indices may be assigned different lifecycle policies. To retrieve the lifecycle policy for individual backing indices, use the get index settings API. */
  ilm_policy?: <<Name>>
  pass:[/**] @property next_generation_managed_by <<Name>> of the lifecycle system that'll manage the next generation of the data stream. */
  next_generation_managed_by: <<IndicesManagedBy>>
  pass:[/**] @property prefer_ilm Indicates if ILM should take precedence over DSL in case both are configured to managed this data stream. */
  prefer_ilm: boolean
  pass:[/**] @property indices Array of objects containing information about the data stream’s backing indices. The last item in this array contains information about the stream’s current write index. */
  indices: <<IndicesDataStreamIndex>>[]
  pass:[/**] @property lifecycle Contains the configuration for the data stream lifecycle of this data stream. */
  lifecycle?: <<IndicesDataStreamLifecycleWithRollover>>
  pass:[/**] @property name <<Name>> of the data stream. */
  name: <<DataStreamName>>
  pass:[/**] @property replicated If `true`, the data stream is created and managed by cross-cluster replication and the local cluster can not write into this data stream or change its mappings. */
  replicated?: boolean
  pass:[/**] @property rollover_on_write If `true`, the next write to this data stream will trigger a rollover first and the document will be indexed in the new backing index. If the rollover fails the indexing request will fail too. */
  rollover_on_write: boolean
  pass:[/**] @property status Health status of the data stream. This health status is based on the state of the primary and replica shards of the stream’s backing indices. */
  status: <<HealthStatus>>
  pass:[/**] @property system If `true`, the data stream is created and managed by an Elastic stack component and cannot be modified through normal user interaction. */
  system?: boolean
  pass:[/**] @property template <<Name>> of the index template used to create the data stream’s backing indices. The template’s index pattern must match the name of this data stream. */
  template: <<Name>>
  pass:[/**] @property timestamp_field Information about the `@timestamp` field in the data stream. */
  timestamp_field: <<IndicesDataStreamTimestampField>>
}
----


[discrete]
[[IndicesDataStreamIndex]]
=== IndicesDataStreamIndex

[source,ts,subs=+macros]
----
interface IndicesDataStreamIndex {
  pass:[/**] @property index_name <<Name>> of the backing index. */
  index_name: <<IndexName>>
  pass:[/**] @property index_uuid Universally unique identifier (UUID) for the index. */
  index_uuid: <<Uuid>>
  pass:[/**] @property ilm_policy <<Name>> of the current ILM lifecycle policy configured for this backing index. */
  ilm_policy?: <<Name>>
  pass:[/**] @property managed_by <<Name>> of the lifecycle system that's currently managing this backing index. */
  managed_by?: <<IndicesManagedBy>>
  pass:[/**] @property prefer_ilm Indicates if ILM should take precedence over DSL in case both are configured to manage this index. */
  prefer_ilm?: boolean
}
----


[discrete]
[[IndicesDataStreamLifecycle]]
=== IndicesDataStreamLifecycle

[source,ts,subs=+macros]
----
interface IndicesDataStreamLifecycle {
  pass:[/**] @property data_retention If defined, every document added to this data stream will be stored at least for this time frame. Any time after this duration the document could be deleted. When empty, every document in this data stream will be stored indefinitely. */
  data_retention?: <<Duration>>
  pass:[/**] @property downsampling The downsampling configuration to execute for the managed backing index after rollover. */
  downsampling?: <<IndicesDataStreamLifecycleDownsampling>>
  pass:[/**] @property enabled If defined, it turns data stream lifecycle on/off (`true`/`false`) for this data stream. A data stream lifecycle that's disabled (enabled: `false`) will have no effect on the data stream. */
  enabled?: boolean
}
----


[discrete]
[[IndicesDataStreamLifecycleDownsampling]]
=== IndicesDataStreamLifecycleDownsampling

[source,ts,subs=+macros]
----
interface IndicesDataStreamLifecycleDownsampling {
  pass:[/**] @property rounds The list of downsampling rounds to execute as part of this downsampling configuration */
  rounds: <<IndicesDownsamplingRound>>[]
}
----


[discrete]
[[IndicesDataStreamLifecycleRolloverConditions]]
=== IndicesDataStreamLifecycleRolloverConditions

[source,ts,subs=+macros]
----
interface IndicesDataStreamLifecycleRolloverConditions {
  min_age?: <<Duration>>
  max_age?: string
  min_docs?: <<long>>
  max_docs?: <<long>>
  min_size?: <<ByteSize>>
  max_size?: <<ByteSize>>
  min_primary_shard_size?: <<ByteSize>>
  max_primary_shard_size?: <<ByteSize>>
  min_primary_shard_docs?: <<long>>
  max_primary_shard_docs?: <<long>>
}
----


[discrete]
[[IndicesDataStreamLifecycleWithRollover]]
=== IndicesDataStreamLifecycleWithRollover

[source,ts,subs=+macros]
----
interface IndicesDataStreamLifecycleWithRollover extends <<IndicesDataStreamLifecycle>> {
  pass:[/**] @property rollover The conditions which will trigger the rollover of a backing index as configured by the cluster setting `cluster.lifecycle.default.rollover`. This property is an implementation detail and it will only be retrieved when the query param `include_defaults` is set to true. The contents of this field are subject to change. */
  rollover?: <<IndicesDataStreamLifecycleRolloverConditions>>
}
----


[discrete]
[[IndicesDataStreamTimestampField]]
=== IndicesDataStreamTimestampField

[source,ts,subs=+macros]
----
interface IndicesDataStreamTimestampField {
  pass:[/**] @property name <<Name>> of the timestamp field for the data stream, which must be `@timestamp`. The `@timestamp` field must be included in every document indexed to the data stream. */
  name: <<Field>>
}
----


[discrete]
[[IndicesDataStreamVisibility]]
=== IndicesDataStreamVisibility

[source,ts,subs=+macros]
----
interface IndicesDataStreamVisibility {
  hidden?: boolean
  allow_custom_routing?: boolean
}
----


[discrete]
[[IndicesDownsampleConfig]]
=== IndicesDownsampleConfig

[source,ts,subs=+macros]
----
interface IndicesDownsampleConfig {
  pass:[/**] @property fixed_interval The interval at which to aggregate the original time series index. */
  fixed_interval: <<DurationLarge>>
}
----


[discrete]
[[IndicesDownsamplingRound]]
=== IndicesDownsamplingRound

[source,ts,subs=+macros]
----
interface IndicesDownsamplingRound {
  pass:[/**] @property after The duration since rollover when this downsampling round should execute */
  after: <<Duration>>
  pass:[/**] @property config The downsample configuration to execute. */
  config: <<IndicesDownsampleConfig>>
}
----


[discrete]
[[IndicesFailureStore]]
=== IndicesFailureStore

[source,ts,subs=+macros]
----
interface IndicesFailureStore {
  enabled: boolean
  indices: <<IndicesDataStreamIndex>>[]
  rollover_on_write: boolean
}
----


[discrete]
[[IndicesFielddataFrequencyFilter]]
=== IndicesFielddataFrequencyFilter

[source,ts,subs=+macros]
----
interface IndicesFielddataFrequencyFilter {
  max: <<double>>
  min: <<double>>
  min_segment_size: <<integer>>
}
----


[discrete]
[[IndicesIndexCheckOnStartup]]
=== IndicesIndexCheckOnStartup

[source,ts,subs=+macros]
----
type IndicesIndexCheckOnStartup = boolean | 'true' | 'false' | 'checksum'
----


[discrete]
[[IndicesIndexRouting]]
=== IndicesIndexRouting

[source,ts,subs=+macros]
----
interface IndicesIndexRouting {
  allocation?: <<IndicesIndexRoutingAllocation>>
  rebalance?: <<IndicesIndexRoutingRebalance>>
}
----


[discrete]
[[IndicesIndexRoutingAllocation]]
=== IndicesIndexRoutingAllocation

[source,ts,subs=+macros]
----
interface IndicesIndexRoutingAllocation {
  enable?: <<IndicesIndexRoutingAllocationOptions>>
  include?: <<IndicesIndexRoutingAllocationInclude>>
  initial_recovery?: <<IndicesIndexRoutingAllocationInitialRecovery>>
  disk?: <<IndicesIndexRoutingAllocationDisk>>
}
----


[discrete]
[[IndicesIndexRoutingAllocationDisk]]
=== IndicesIndexRoutingAllocationDisk

[source,ts,subs=+macros]
----
interface IndicesIndexRoutingAllocationDisk {
  threshold_enabled?: boolean | string
}
----


[discrete]
[[IndicesIndexRoutingAllocationInclude]]
=== IndicesIndexRoutingAllocationInclude

[source,ts,subs=+macros]
----
interface IndicesIndexRoutingAllocationInclude {
  _tier_preference?: string
  _id?: <<Id>>
}
----


[discrete]
[[IndicesIndexRoutingAllocationInitialRecovery]]
=== IndicesIndexRoutingAllocationInitialRecovery

[source,ts,subs=+macros]
----
interface IndicesIndexRoutingAllocationInitialRecovery {
  _id?: <<Id>>
}
----


[discrete]
[[IndicesIndexRoutingAllocationOptions]]
=== IndicesIndexRoutingAllocationOptions

[source,ts,subs=+macros]
----
type IndicesIndexRoutingAllocationOptions = 'all' | 'primaries' | 'new_primaries' | 'none'
----


[discrete]
[[IndicesIndexRoutingRebalance]]
=== IndicesIndexRoutingRebalance

[source,ts,subs=+macros]
----
interface IndicesIndexRoutingRebalance {
  enable: <<IndicesIndexRoutingRebalanceOptions>>
}
----


[discrete]
[[IndicesIndexRoutingRebalanceOptions]]
=== IndicesIndexRoutingRebalanceOptions

[source,ts,subs=+macros]
----
type IndicesIndexRoutingRebalanceOptions = 'all' | 'primaries' | 'replicas' | 'none'
----


[discrete]
[[IndicesIndexSegmentSort]]
=== IndicesIndexSegmentSort

[source,ts,subs=+macros]
----
interface IndicesIndexSegmentSort {
  field?: <<Fields>>
  order?: <<IndicesSegmentSortOrder>> | <<IndicesSegmentSortOrder>>[]
  mode?: <<IndicesSegmentSortMode>> | <<IndicesSegmentSortMode>>[]
  missing?: <<IndicesSegmentSortMissing>> | <<IndicesSegmentSortMissing>>[]
}
----


[discrete]
[[IndicesIndexSettingBlocks]]
=== IndicesIndexSettingBlocks

[source,ts,subs=+macros]
----
interface IndicesIndexSettingBlocks {
  read_only?: <<SpecUtilsStringified>><boolean>
  read_only_allow_delete?: <<SpecUtilsStringified>><boolean>
  read?: <<SpecUtilsStringified>><boolean>
  write?: <<SpecUtilsStringified>><boolean>
  metadata?: <<SpecUtilsStringified>><boolean>
}
----


[discrete]
[[IndicesIndexSettings]]
=== IndicesIndexSettings

[source,ts,subs=+macros]
----
interface IndicesIndexSettingsKeys {
  index?: <<IndicesIndexSettings>>
  mode?: string
  routing_path?: string | string[]
  soft_deletes?: <<IndicesSoftDeletes>>
  sort?: <<IndicesIndexSegmentSort>>
  number_of_shards?: <<integer>> | string
  number_of_replicas?: <<integer>> | string
  number_of_routing_shards?: <<integer>>
  check_on_startup?: <<IndicesIndexCheckOnStartup>>
  codec?: string
  routing_partition_size?: <<SpecUtilsStringified>><<<integer>>>
  load_fixed_bitset_filters_eagerly?: boolean
  hidden?: boolean | string
  auto_expand_replicas?: string
  merge?: <<IndicesMerge>>
  search?: <<IndicesSettingsSearch>>
  refresh_interval?: <<Duration>>
  max_result_window?: <<integer>>
  max_inner_result_window?: <<integer>>
  max_rescore_window?: <<integer>>
  max_docvalue_fields_search?: <<integer>>
  max_script_fields?: <<integer>>
  max_ngram_diff?: <<integer>>
  max_shingle_diff?: <<integer>>
  blocks?: <<IndicesIndexSettingBlocks>>
  max_refresh_listeners?: <<integer>>
  analyze?: <<IndicesSettingsAnalyze>>
  highlight?: <<IndicesSettingsHighlight>>
  max_terms_count?: <<integer>>
  max_regex_length?: <<integer>>
  routing?: <<IndicesIndexRouting>>
  gc_deletes?: <<Duration>>
  default_pipeline?: <<PipelineName>>
  final_pipeline?: <<PipelineName>>
  lifecycle?: <<IndicesIndexSettingsLifecycle>>
  provided_name?: <<Name>>
  creation_date?: <<SpecUtilsStringified>><<<EpochTime>><<<UnitMillis>>>>
  creation_date_string?: <<DateTime>>
  uuid?: <<Uuid>>
  version?: <<IndicesIndexVersioning>>
  verified_before_close?: boolean | string
  format?: string | <<integer>>
  max_slices_per_scroll?: <<integer>>
  translog?: <<IndicesTranslog>>
  query_string?: <<IndicesSettingsQueryString>>
  priority?: <<integer>> | string
  top_metrics_max_size?: <<integer>>
  analysis?: <<IndicesIndexSettingsAnalysis>>
  settings?: <<IndicesIndexSettings>>
  time_series?: <<IndicesIndexSettingsTimeSeries>>
  queries?: <<IndicesQueries>>
  similarity?: Record<string, <<IndicesSettingsSimilarity>>>
  mapping?: <<IndicesMappingLimitSettings>>
  'indexing.slowlog'?: <<IndicesIndexingSlowlogSettings>>
  indexing_pressure?: <<IndicesIndexingPressure>>
  store?: <<IndicesStorage>>
}
type IndicesIndexSettings = IndicesIndexSettingsKeys
  & { [property: string]: any }
----


[discrete]
[[IndicesIndexSettingsAnalysis]]
=== IndicesIndexSettingsAnalysis

[source,ts,subs=+macros]
----
interface IndicesIndexSettingsAnalysis {
  analyzer?: Record<string, <<AnalysisAnalyzer>>>
  char_filter?: Record<string, <<AnalysisCharFilter>>>
  filter?: Record<string, <<AnalysisTokenFilter>>>
  normalizer?: Record<string, <<AnalysisNormalizer>>>
  tokenizer?: Record<string, <<AnalysisTokenizer>>>
}
----


[discrete]
[[IndicesIndexSettingsLifecycle]]
=== IndicesIndexSettingsLifecycle

[source,ts,subs=+macros]
----
interface IndicesIndexSettingsLifecycle {
  pass:[/**] @property name The name of the policy to use to manage the index. For information about how Elasticsearch applies policy changes, see Policy updates. */
  name?: <<Name>>
  pass:[/**] @property indexing_complete Indicates whether or not the index has been rolled over. Automatically set to true when ILM completes the rollover action. You can explicitly set it to skip rollover. */
  indexing_complete?: <<SpecUtilsStringified>><boolean>
  pass:[/**] @property origination_date If specified, this is the timestamp used to calculate the index age for its phase transitions. Use this setting if you create a new index that contains old data and want to use the original creation date to calculate the index age. Specified as a Unix epoch value in milliseconds. */
  origination_date?: <<long>>
  pass:[/**] @property parse_origination_date Set to true to parse the origination date from the index name. This origination date is used to calculate the index age for its phase transitions. The index name must match the pattern ^.*-{date_format}-\\d+, where the date_format is yyyy.MM.dd and the trailing digits are optional. An index that was rolled over would normally match the full format, for example logs-2016.10.31-000002). If the index name doesn’t match the pattern, index creation fails. */
  parse_origination_date?: boolean
  step?: <<IndicesIndexSettingsLifecycleStep>>
  pass:[/**] @property rollover_alias The index alias to update when the index rolls over. Specify when using a policy that contains a rollover action. When the index rolls over, the alias is updated to reflect that the index is no longer the write index. For more information about rolling indices, see Rollover. */
  rollover_alias?: string
}
----


[discrete]
[[IndicesIndexSettingsLifecycleStep]]
=== IndicesIndexSettingsLifecycleStep

[source,ts,subs=+macros]
----
interface IndicesIndexSettingsLifecycleStep {
  pass:[/**] @property wait_time_threshold Time to wait for the cluster to resolve allocation issues during an ILM shrink action. Must be greater than 1h (1 hour). See Shard allocation for shrink. */
  wait_time_threshold?: <<Duration>>
}
----


[discrete]
[[IndicesIndexSettingsTimeSeries]]
=== IndicesIndexSettingsTimeSeries

[source,ts,subs=+macros]
----
interface IndicesIndexSettingsTimeSeries {
  end_time?: <<DateTime>>
  start_time?: <<DateTime>>
}
----


[discrete]
[[IndicesIndexState]]
=== IndicesIndexState

[source,ts,subs=+macros]
----
interface IndicesIndexState {
  aliases?: Record<<<IndexName>>, <<IndicesAlias>>>
  mappings?: <<MappingTypeMapping>>
  settings?: <<IndicesIndexSettings>>
  pass:[/**] @property defaults Default settings, included when the request's `include_default` is `true`. */
  defaults?: <<IndicesIndexSettings>>
  data_stream?: <<DataStreamName>>
  pass:[/**] @property lifecycle Data stream lifecycle applicable if this is a data stream. */
  lifecycle?: <<IndicesDataStreamLifecycle>>
}
----


[discrete]
[[IndicesIndexTemplate]]
=== IndicesIndexTemplate

[source,ts,subs=+macros]
----
interface IndicesIndexTemplate {
  pass:[/**] @property index_patterns <<Name>> of the index template. */
  index_patterns: <<Names>>
  pass:[/**] @property composed_of An ordered list of component template names. Component templates are merged in the order specified, meaning that the last component template specified has the highest precedence. */
  composed_of: <<Name>>[]
  pass:[/**] @property template Template to be applied. It may optionally include an `aliases`, `mappings`, or `settings` configuration. */
  template?: <<IndicesIndexTemplateSummary>>
  pass:[/**] @property version Version number used to manage index templates externally. This number is not automatically generated by Elasticsearch. */
  version?: <<VersionNumber>>
  pass:[/**] @property priority Priority to determine index template precedence when a new data stream or index is created. The index template with the highest priority is chosen. If no priority is specified the template is treated as though it is of priority 0 (lowest priority). This number is not automatically generated by Elasticsearch. */
  priority?: <<long>>
  pass:[/**] @property _meta Optional user metadata about the index template. May have any contents. This map is not automatically generated by Elasticsearch. */
  _meta?: <<Metadata>>
  allow_auto_create?: boolean
  pass:[/**] @property data_stream If this object is included, the template is used to create data streams and their backing indices. Supports an empty object. Data streams require a matching index template with a `data_stream` object. */
  data_stream?: <<IndicesIndexTemplateDataStreamConfiguration>>
  pass:[/**] @property deprecated Marks this index template as deprecated. When creating or updating a non-deprecated index template that uses deprecated components, Elasticsearch will emit a deprecation warning. */
  deprecated?: boolean
  pass:[/**] @property ignore_missing_component_templates A list of component template names that are allowed to be absent. */
  ignore_missing_component_templates?: <<Names>>
}
----


[discrete]
[[IndicesIndexTemplateDataStreamConfiguration]]
=== IndicesIndexTemplateDataStreamConfiguration

[source,ts,subs=+macros]
----
interface IndicesIndexTemplateDataStreamConfiguration {
  pass:[/**] @property hidden If true, the data stream is hidden. */
  hidden?: boolean
  pass:[/**] @property allow_custom_routing If true, the data stream supports custom routing. */
  allow_custom_routing?: boolean
}
----


[discrete]
[[IndicesIndexTemplateSummary]]
=== IndicesIndexTemplateSummary

[source,ts,subs=+macros]
----
interface IndicesIndexTemplateSummary {
  pass:[/**] @property aliases Aliases to add. If the index template includes a `data_stream` object, these are data stream aliases. Otherwise, these are index aliases. Data stream aliases ignore the `index_routing`, `routing`, and `search_routing` options. */
  aliases?: Record<<<IndexName>>, <<IndicesAlias>>>
  pass:[/**] @property mappings Mapping for fields in the index. If specified, this mapping can include field names, field data types, and mapping parameters. */
  mappings?: <<MappingTypeMapping>>
  pass:[/**] @property settings Configuration options for the index. */
  settings?: <<IndicesIndexSettings>>
  lifecycle?: <<IndicesDataStreamLifecycleWithRollover>>
}
----


[discrete]
[[IndicesIndexVersioning]]
=== IndicesIndexVersioning

[source,ts,subs=+macros]
----
interface IndicesIndexVersioning {
  created?: <<VersionString>>
  created_string?: string
}
----


[discrete]
[[IndicesIndexingPressure]]
=== IndicesIndexingPressure

[source,ts,subs=+macros]
----
interface IndicesIndexingPressure {
  memory: <<IndicesIndexingPressureMemory>>
}
----


[discrete]
[[IndicesIndexingPressureMemory]]
=== IndicesIndexingPressureMemory

[source,ts,subs=+macros]
----
interface IndicesIndexingPressureMemory {
  pass:[/**] @property limit Number of outstanding bytes that may be consumed by indexing requests. When this limit is reached or exceeded, the node will reject new coordinating and primary operations. When replica operations consume 1.5x this limit, the node will reject new replica operations. Defaults to 10% of the heap. */
  limit?: <<integer>>
}
----


[discrete]
[[IndicesIndexingSlowlogSettings]]
=== IndicesIndexingSlowlogSettings

[source,ts,subs=+macros]
----
interface IndicesIndexingSlowlogSettings {
  level?: string
  source?: <<integer>>
  reformat?: boolean
  threshold?: <<IndicesIndexingSlowlogTresholds>>
}
----


[discrete]
[[IndicesIndexingSlowlogTresholds]]
=== IndicesIndexingSlowlogTresholds

[source,ts,subs=+macros]
----
interface IndicesIndexingSlowlogTresholds {
  pass:[/**] @property index The indexing slow log, similar in functionality to the search slow log. The log file name ends with `_index_indexing_slowlog.json`. Log and the thresholds are configured in the same way as the search slowlog. */
  index?: <<IndicesSlowlogTresholdLevels>>
}
----


[discrete]
[[IndicesManagedBy]]
=== IndicesManagedBy

[source,ts,subs=+macros]
----
type IndicesManagedBy = 'Index Lifecycle Management' | 'Data stream lifecycle' | 'Unmanaged'
----


[discrete]
[[IndicesMappingLimitSettings]]
=== IndicesMappingLimitSettings

[source,ts,subs=+macros]
----
interface IndicesMappingLimitSettings {
  coerce?: boolean
  total_fields?: <<IndicesMappingLimitSettingsTotalFields>>
  depth?: <<IndicesMappingLimitSettingsDepth>>
  nested_fields?: <<IndicesMappingLimitSettingsNestedFields>>
  nested_objects?: <<IndicesMappingLimitSettingsNestedObjects>>
  field_name_length?: <<IndicesMappingLimitSettingsFieldNameLength>>
  dimension_fields?: <<IndicesMappingLimitSettingsDimensionFields>>
  ignore_malformed?: boolean
}
----


[discrete]
[[IndicesMappingLimitSettingsDepth]]
=== IndicesMappingLimitSettingsDepth

[source,ts,subs=+macros]
----
interface IndicesMappingLimitSettingsDepth {
  pass:[/**] @property limit The maximum depth for a field, which is measured as the number of inner objects. For instance, if all fields are defined at the root object level, then the depth is 1. If there is one object mapping, then the depth is 2, etc. */
  limit?: <<long>>
}
----


[discrete]
[[IndicesMappingLimitSettingsDimensionFields]]
=== IndicesMappingLimitSettingsDimensionFields

[source,ts,subs=+macros]
----
interface IndicesMappingLimitSettingsDimensionFields {
  pass:[/**] @property limit [preview] This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features. */
  limit?: <<long>>
}
----


[discrete]
[[IndicesMappingLimitSettingsFieldNameLength]]
=== IndicesMappingLimitSettingsFieldNameLength

[source,ts,subs=+macros]
----
interface IndicesMappingLimitSettingsFieldNameLength {
  pass:[/**] @property limit Setting for the maximum length of a field name. This setting isn’t really something that addresses mappings explosion but might still be useful if you want to limit the field length. It usually shouldn’t be necessary to set this setting. The default is okay unless a user starts to add a huge number of fields with really <<long>> names. Default is `Long.MAX_VALUE` (no limit). */
  limit?: <<long>>
}
----


[discrete]
[[IndicesMappingLimitSettingsNestedFields]]
=== IndicesMappingLimitSettingsNestedFields

[source,ts,subs=+macros]
----
interface IndicesMappingLimitSettingsNestedFields {
  pass:[/**] @property limit The maximum number of distinct nested mappings in an index. The nested type should only be used in special cases, when arrays of objects need to be queried independently of each other. To safeguard against poorly designed mappings, this setting limits the number of unique nested types per index. */
  limit?: <<long>>
}
----


[discrete]
[[IndicesMappingLimitSettingsNestedObjects]]
=== IndicesMappingLimitSettingsNestedObjects

[source,ts,subs=+macros]
----
interface IndicesMappingLimitSettingsNestedObjects {
  pass:[/**] @property limit The maximum number of nested JSON objects that a single document can contain across all nested types. This limit helps to prevent out of memory errors when a document contains too many nested objects. */
  limit?: <<long>>
}
----


[discrete]
[[IndicesMappingLimitSettingsTotalFields]]
=== IndicesMappingLimitSettingsTotalFields

[source,ts,subs=+macros]
----
interface IndicesMappingLimitSettingsTotalFields {
  pass:[/**] @property limit The maximum number of fields in an index. <<Field>> and object mappings, as well as field aliases count towards this limit. The limit is in place to prevent mappings and searches from becoming too large. Higher values can lead to performance degradations and memory issues, especially in clusters with a high load or few resources. */
  limit?: <<long>> | string
  pass:[/**] @property ignore_dynamic_beyond_limit This setting determines what happens when a dynamically mapped field would exceed the total fields limit. When set to false (the default), the index request of the document that tries to add a dynamic field to the mapping will fail with the message Limit of total fields [X] has been exceeded. When set to true, the index request will not fail. Instead, fields that would exceed the limit are not added to the mapping, similar to dynamic: false. The fields that were not added to the mapping will be added to the _ignored field. */
  ignore_dynamic_beyond_limit?: boolean | string
}
----


[discrete]
[[IndicesMerge]]
=== IndicesMerge

[source,ts,subs=+macros]
----
interface IndicesMerge {
  scheduler?: <<IndicesMergeScheduler>>
}
----


[discrete]
[[IndicesMergeScheduler]]
=== IndicesMergeScheduler

[source,ts,subs=+macros]
----
interface IndicesMergeScheduler {
  max_thread_count?: <<SpecUtilsStringified>><<<integer>>>
  max_merge_count?: <<SpecUtilsStringified>><<<integer>>>
}
----


[discrete]
[[IndicesNumericFielddata]]
=== IndicesNumericFielddata

[source,ts,subs=+macros]
----
interface IndicesNumericFielddata {
  format: <<IndicesNumericFielddataFormat>>
}
----


[discrete]
[[IndicesNumericFielddataFormat]]
=== IndicesNumericFielddataFormat

[source,ts,subs=+macros]
----
type IndicesNumericFielddataFormat = 'array' | 'disabled'
----


[discrete]
[[IndicesQueries]]
=== IndicesQueries

[source,ts,subs=+macros]
----
interface IndicesQueries {
  cache?: <<IndicesCacheQueries>>
}
----


[discrete]
[[IndicesRetentionLease]]
=== IndicesRetentionLease

[source,ts,subs=+macros]
----
interface IndicesRetentionLease {
  period: <<Duration>>
}
----


[discrete]
[[IndicesSearchIdle]]
=== IndicesSearchIdle

[source,ts,subs=+macros]
----
interface IndicesSearchIdle {
  after?: <<Duration>>
}
----


[discrete]
[[IndicesSegmentSortMissing]]
=== IndicesSegmentSortMissing

[source,ts,subs=+macros]
----
type IndicesSegmentSortMissing = '_last' | '_first'
----


[discrete]
[[IndicesSegmentSortMode]]
=== IndicesSegmentSortMode

[source,ts,subs=+macros]
----
type IndicesSegmentSortMode = 'min' | 'MIN' | 'max' | 'MAX'
----


[discrete]
[[IndicesSegmentSortOrder]]
=== IndicesSegmentSortOrder

[source,ts,subs=+macros]
----
type IndicesSegmentSortOrder = 'asc' | 'ASC' | 'desc' | 'DESC'
----


[discrete]
[[IndicesSettingsAnalyze]]
=== IndicesSettingsAnalyze

[source,ts,subs=+macros]
----
interface IndicesSettingsAnalyze {
  max_token_count?: <<SpecUtilsStringified>><<<integer>>>
}
----


[discrete]
[[IndicesSettingsHighlight]]
=== IndicesSettingsHighlight

[source,ts,subs=+macros]
----
interface IndicesSettingsHighlight {
  max_analyzed_offset?: <<integer>>
}
----


[discrete]
[[IndicesSettingsQueryString]]
=== IndicesSettingsQueryString

[source,ts,subs=+macros]
----
interface IndicesSettingsQueryString {
  lenient: <<SpecUtilsStringified>><boolean>
}
----


[discrete]
[[IndicesSettingsSearch]]
=== IndicesSettingsSearch

[source,ts,subs=+macros]
----
interface IndicesSettingsSearch {
  idle?: <<IndicesSearchIdle>>
  slowlog?: <<IndicesSlowlogSettings>>
}
----


[discrete]
[[IndicesSettingsSimilarity]]
=== IndicesSettingsSimilarity

[source,ts,subs=+macros]
----
type IndicesSettingsSimilarity = IndicesSettingsSimilarityBm25 | <<IndicesSettingsSimilarityBoolean>> | <<IndicesSettingsSimilarityDfi>> | <<IndicesSettingsSimilarityDfr>> | <<IndicesSettingsSimilarityIb>> | <<IndicesSettingsSimilarityLmd>> | <<IndicesSettingsSimilarityLmj>> | <<IndicesSettingsSimilarityScripted>>
----


[discrete]
[[IndicesSettingsSimilarityBm25]]
=== IndicesSettingsSimilarityBm25

[source,ts,subs=+macros]
----
interface IndicesSettingsSimilarityBm25 {
  type: 'BM25'
  b?: <<double>>
  discount_overlaps?: boolean
  k1?: <<double>>
}
----


[discrete]
[[IndicesSettingsSimilarityBoolean]]
=== IndicesSettingsSimilarityBoolean

[source,ts,subs=+macros]
----
interface IndicesSettingsSimilarityBoolean {
  type: 'boolean'
}
----


[discrete]
[[IndicesSettingsSimilarityDfi]]
=== IndicesSettingsSimilarityDfi

[source,ts,subs=+macros]
----
interface IndicesSettingsSimilarityDfi {
  type: 'DFI'
  independence_measure: <<DFIIndependenceMeasure>>
}
----


[discrete]
[[IndicesSettingsSimilarityDfr]]
=== IndicesSettingsSimilarityDfr

[source,ts,subs=+macros]
----
interface IndicesSettingsSimilarityDfr {
  type: 'DFR'
  after_effect: <<DFRAfterEffect>>
  basic_model: <<DFRBasicModel>>
  normalization: <<Normalization>>
}
----


[discrete]
[[IndicesSettingsSimilarityIb]]
=== IndicesSettingsSimilarityIb

[source,ts,subs=+macros]
----
interface IndicesSettingsSimilarityIb {
  type: 'IB'
  distribution: <<IBDistribution>>
  lambda: <<IBLambda>>
  normalization: <<Normalization>>
}
----


[discrete]
[[IndicesSettingsSimilarityLmd]]
=== IndicesSettingsSimilarityLmd

[source,ts,subs=+macros]
----
interface IndicesSettingsSimilarityLmd {
  type: 'LMDirichlet'
  mu?: <<double>>
}
----


[discrete]
[[IndicesSettingsSimilarityLmj]]
=== IndicesSettingsSimilarityLmj

[source,ts,subs=+macros]
----
interface IndicesSettingsSimilarityLmj {
  type: 'LMJelinekMercer'
  lambda?: <<double>>
}
----


[discrete]
[[IndicesSettingsSimilarityScripted]]
=== IndicesSettingsSimilarityScripted

[source,ts,subs=+macros]
----
interface IndicesSettingsSimilarityScripted {
  type: 'scripted'
  script: <<Script>> | string
  weight_script?: <<Script>> | string
}
----


[discrete]
[[IndicesSlowlogSettings]]
=== IndicesSlowlogSettings

[source,ts,subs=+macros]
----
interface IndicesSlowlogSettings {
  level?: string
  source?: <<integer>>
  reformat?: boolean
  threshold?: <<IndicesSlowlogTresholds>>
}
----


[discrete]
[[IndicesSlowlogTresholdLevels]]
=== IndicesSlowlogTresholdLevels

[source,ts,subs=+macros]
----
interface IndicesSlowlogTresholdLevels {
  warn?: <<Duration>>
  info?: <<Duration>>
  debug?: <<Duration>>
  trace?: <<Duration>>
}
----


[discrete]
[[IndicesSlowlogTresholds]]
=== IndicesSlowlogTresholds

[source,ts,subs=+macros]
----
interface IndicesSlowlogTresholds {
  query?: <<IndicesSlowlogTresholdLevels>>
  fetch?: <<IndicesSlowlogTresholdLevels>>
}
----


[discrete]
[[IndicesSoftDeletes]]
=== IndicesSoftDeletes

[source,ts,subs=+macros]
----
interface IndicesSoftDeletes {
  pass:[/**] @property enabled Indicates whether soft deletes are enabled on the index. */
  enabled?: boolean
  pass:[/**] @property retention_lease The maximum period to retain a shard history retention lease before it is considered expired. Shard history retention leases ensure that soft deletes are retained during merges on the Lucene index. If a soft delete is merged away before it can be replicated to a follower the following process will fail due to incomplete history on the leader. */
  retention_lease?: <<IndicesRetentionLease>>
}
----


[discrete]
[[IndicesStorage]]
=== IndicesStorage

[source,ts,subs=+macros]
----
interface IndicesStorage {
  type: <<IndicesStorageType>>
  pass:[/**] @property allow_mmap You can restrict the use of the mmapfs and the related hybridfs store type via the setting node.store.allow_mmap. This is a boolean setting indicating whether or not memory-mapping is allowed. The default is to allow it. This setting is useful, for example, if you are in an environment where you can not control the ability to create a lot of memory maps so you need disable the ability to use memory-mapping. */
  allow_mmap?: boolean
}
----


[discrete]
[[IndicesStorageType]]
=== IndicesStorageType

[source,ts,subs=+macros]
----
type IndicesStorageType = 'fs' | 'niofs' | 'mmapfs' | 'hybridfs' | string
----


[discrete]
[[IndicesTemplateMapping]]
=== IndicesTemplateMapping

[source,ts,subs=+macros]
----
interface IndicesTemplateMapping {
  aliases: Record<<<IndexName>>, <<IndicesAlias>>>
  index_patterns: <<Name>>[]
  mappings: <<MappingTypeMapping>>
  order: <<integer>>
  settings: Record<string, any>
  version?: <<VersionNumber>>
}
----


[discrete]
[[IndicesTranslog]]
=== IndicesTranslog

[source,ts,subs=+macros]
----
interface IndicesTranslog {
  pass:[/**] @property sync_interval How often the translog is fsynced to disk and committed, regardless of write operations. Values less than 100ms are not allowed. */
  sync_interval?: <<Duration>>
  pass:[/**] @property durability Whether or not to `fsync` and commit the translog after every index, delete, update, or bulk request. */
  durability?: <<IndicesTranslogDurability>>
  pass:[/**] @property flush_threshold_size The translog stores all operations that are not yet safely persisted in Lucene (i.e., are not part of a Lucene commit point). Although these operations are available for reads, they will need to be replayed if the shard was stopped and had to be recovered. This setting controls the maximum total size of these operations, to prevent recoveries from taking too <<long>>. Once the maximum size has been reached a flush will happen, generating a new Lucene commit point. */
  flush_threshold_size?: <<ByteSize>>
  retention?: <<IndicesTranslogRetention>>
}
----


[discrete]
[[IndicesTranslogDurability]]
=== IndicesTranslogDurability

[source,ts,subs=+macros]
----
type IndicesTranslogDurability = 'request' | 'REQUEST' | 'async' | 'ASYNC'
----


[discrete]
[[IndicesTranslogRetention]]
=== IndicesTranslogRetention

[source,ts,subs=+macros]
----
interface IndicesTranslogRetention {
  pass:[/**] @property size This controls the total size of translog files to keep for each shard. Keeping more translog files increases the chance of performing an operation based sync when recovering a replica. If the translog files are not sufficient, replica recovery will fall back to a file based sync. This setting is ignored, and should not be set, if soft deletes are enabled. Soft deletes are enabled by default in indices created in Elasticsearch versions 7.0.0 and later. */
  size?: <<ByteSize>>
  pass:[/**] @property age This controls the maximum duration for which translog files are kept by each shard. Keeping more translog files increases the chance of performing an operation based sync when recovering replicas. If the translog files are not sufficient, replica recovery will fall back to a file based sync. This setting is ignored, and should not be set, if soft deletes are enabled. Soft deletes are enabled by default in indices created in Elasticsearch versions 7.0.0 and later. */
  age?: <<Duration>>
}
----


