[[reference-shared-types]]

////////
===========================================================================================================================
||                                                                                                                       ||
||                                                                                                                       ||
||                                                                                                                       ||
||        ██████╗ ███████╗ █████╗ ██████╗ ███╗   ███╗███████╗                                                            ||
||        ██╔══██╗██╔════╝██╔══██╗██╔══██╗████╗ ████║██╔════╝                                                            ||
||        ██████╔╝█████╗  ███████║██║  ██║██╔████╔██║█████╗                                                              ||
||        ██╔══██╗██╔══╝  ██╔══██║██║  ██║██║╚██╔╝██║██╔══╝                                                              ||
||        ██║  ██║███████╗██║  ██║██████╔╝██║ ╚═╝ ██║███████╗                                                            ||
||        ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝     ╚═╝╚══════╝                                                            ||
||                                                                                                                       ||
||                                                                                                                       ||
||    This file is autogenerated, DO NOT send pull requests that changes this file directly.                             ||
||    You should update the script that does the generation, which can be found in:                                      ||
||    https://github.com/elastic/elastic-client-generator-js                                                             ||
||                                                                                                                       ||
||    You can run the script with the following command:                                                                 ||
||       npm run elasticsearch -- --version <version>                                                                    ||
||                                                                                                                       ||
||                                                                                                                       ||
||                                                                                                                       ||
===========================================================================================================================
////////
++++
<style>
.lang-ts a.xref {
  text-decoration: underline !important;
}
</style>
++++



== Shared types


[discrete]
[[AcknowledgedResponseBase]]
=== AcknowledgedResponseBase

[source,ts,subs=+macros]
----
interface AcknowledgedResponseBase {
  pass:[/**] @property acknowledged For a successful response, this value is always true. On failure, an exception is returned instead. */
  acknowledged: boolean
}
----


[discrete]
[[AggregateName]]
=== AggregateName

[source,ts,subs=+macros]
----
type AggregateName = string
----


[discrete]
[[BulkIndexByScrollFailure]]
=== BulkIndexByScrollFailure

[source,ts,subs=+macros]
----
interface BulkIndexByScrollFailure {
  cause: <<ErrorCause>>
  id: <<Id>>
  index: <<IndexName>>
  status: <<integer>>
  type: string
}
----


[discrete]
[[BulkStats]]
=== BulkStats

[source,ts,subs=+macros]
----
interface BulkStats {
  total_operations: <<long>>
  total_time?: <<Duration>>
  total_time_in_millis: <<DurationValue>><<<UnitMillis>>>
  total_size?: <<ByteSize>>
  total_size_in_bytes: <<long>>
  avg_time?: <<Duration>>
  avg_time_in_millis: <<DurationValue>><<<UnitMillis>>>
  avg_size?: <<ByteSize>>
  avg_size_in_bytes: <<long>>
}
----


[discrete]
[[ByteSize]]
=== ByteSize

[source,ts,subs=+macros]
----
type ByteSize = <<long>> | string
----


[discrete]
[[Bytes]]
=== Bytes

[source,ts,subs=+macros]
----
type Bytes = 'b' | 'kb' | 'mb' | 'gb' | 'tb' | 'pb'
----


[discrete]
[[CategoryId]]
=== CategoryId

[source,ts,subs=+macros]
----
type CategoryId = string
----


[discrete]
[[ClusterAlias]]
=== ClusterAlias

[source,ts,subs=+macros]
----
type ClusterAlias = string
----


[discrete]
[[ClusterDetails]]
=== ClusterDetails

[source,ts,subs=+macros]
----
interface ClusterDetails {
  status: <<ClusterSearchStatus>>
  indices: string
  took?: <<DurationValue>><<<UnitMillis>>>
  timed_out: boolean
  _shards?: <<ShardStatistics>>
  failures?: <<ShardFailure>>[]
}
----


[discrete]
[[ClusterInfoTarget]]
=== ClusterInfoTarget

[source,ts,subs=+macros]
----
type ClusterInfoTarget = '_all' | 'http' | 'ingest' | 'thread_pool' | 'script'
----


[discrete]
[[ClusterInfoTargets]]
=== ClusterInfoTargets

[source,ts,subs=+macros]
----
type ClusterInfoTargets = <<ClusterInfoTarget>> | <<ClusterInfoTarget>>[]
----


[discrete]
[[ClusterSearchStatus]]
=== ClusterSearchStatus

[source,ts,subs=+macros]
----
type ClusterSearchStatus = 'running' | 'successful' | 'partial' | 'skipped' | 'failed'
----


[discrete]
[[ClusterStatistics]]
=== ClusterStatistics

[source,ts,subs=+macros]
----
interface ClusterStatistics {
  skipped: <<integer>>
  successful: <<integer>>
  total: <<integer>>
  running: <<integer>>
  partial: <<integer>>
  failed: <<integer>>
  details?: Record<<<ClusterAlias>>, <<ClusterDetails>>>
}
----


[discrete]
[[CompletionStats]]
=== CompletionStats

[source,ts,subs=+macros]
----
interface CompletionStats {
  pass:[/**] @property size_in_bytes Total amount, in bytes, of memory used for completion across all shards assigned to selected nodes. */
  size_in_bytes: <<long>>
  pass:[/**] @property size Total amount of memory used for completion across all shards assigned to selected nodes. */
  size?: <<ByteSize>>
  fields?: Record<<<Field>>, <<FieldSizeUsage>>>
}
----


[discrete]
[[Conflicts]]
=== Conflicts

[source,ts,subs=+macros]
----
type Conflicts = 'abort' | 'proceed'
----


[discrete]
[[CoordsGeoBounds]]
=== CoordsGeoBounds

[source,ts,subs=+macros]
----
interface CoordsGeoBounds {
  top: <<double>>
  bottom: <<double>>
  left: <<double>>
  right: <<double>>
}
----


[discrete]
[[DFIIndependenceMeasure]]
=== DFIIndependenceMeasure

[source,ts,subs=+macros]
----
type DFIIndependenceMeasure = 'standardized' | 'saturated' | 'chisquared'
----


[discrete]
[[DFRAfterEffect]]
=== DFRAfterEffect

[source,ts,subs=+macros]
----
type DFRAfterEffect = 'no' | 'b' | 'l'
----


[discrete]
[[DFRBasicModel]]
=== DFRBasicModel

[source,ts,subs=+macros]
----
type DFRBasicModel = 'be' | 'd' | 'g' | 'if' | 'in' | 'ine' | 'p'
----


[discrete]
[[DataStreamName]]
=== DataStreamName

[source,ts,subs=+macros]
----
type DataStreamName = string
----


[discrete]
[[DataStreamNames]]
=== DataStreamNames

[source,ts,subs=+macros]
----
type DataStreamNames = <<DataStreamName>> | <<DataStreamName>>[]
----


[discrete]
[[DateFormat]]
=== DateFormat

[source,ts,subs=+macros]
----
type DateFormat = string
----


[discrete]
[[DateMath]]
=== DateMath

[source,ts,subs=+macros]
----
type DateMath = string | Date
----


[discrete]
[[DateTime]]
=== DateTime

[source,ts,subs=+macros]
----
type DateTime = string | <<EpochTime>><<<UnitMillis>>> | Date
----


[discrete]
[[Distance]]
=== Distance

[source,ts,subs=+macros]
----
type Distance = string
----


[discrete]
[[DistanceUnit]]
=== DistanceUnit

[source,ts,subs=+macros]
----
type DistanceUnit = 'in' | 'ft' | 'yd' | 'mi' | 'nmi' | 'km' | 'm' | 'cm' | 'mm'
----


[discrete]
[[DocStats]]
=== DocStats

[source,ts,subs=+macros]
----
interface DocStats {
  pass:[/**] @property count Total number of non-deleted documents across all primary shards assigned to selected nodes. This number is based on documents in Lucene segments and may include documents from nested fields. */
  count: <<long>>
  pass:[/**] @property deleted Total number of deleted documents across all primary shards assigned to selected nodes. This number is based on documents in Lucene segments. Elasticsearch reclaims the disk space of deleted Lucene documents when a segment is merged. */
  deleted?: <<long>>
}
----


[discrete]
[[Duration]]
=== Duration

[source,ts,subs=+macros]
----
type Duration = string | -1 | 0
----


[discrete]
[[DurationLarge]]
=== DurationLarge

[source,ts,subs=+macros]
----
type DurationLarge = string
----


[discrete]
[[DurationValue]]
=== DurationValue

[source,ts,subs=+macros]
----
type DurationValue<Unit = unknown> = Unit
----


[discrete]
[[ElasticsearchVersionInfo]]
=== ElasticsearchVersionInfo

[source,ts,subs=+macros]
----
interface ElasticsearchVersionInfo {
  build_date: <<DateTime>>
  build_flavor: string
  build_hash: string
  build_snapshot: boolean
  build_type: string
  lucene_version: <<VersionString>>
  minimum_index_compatibility_version: <<VersionString>>
  minimum_wire_compatibility_version: <<VersionString>>
  number: string
}
----


[discrete]
[[ElasticsearchVersionMinInfo]]
=== ElasticsearchVersionMinInfo

[source,ts,subs=+macros]
----
interface ElasticsearchVersionMinInfo {
  build_flavor: string
  minimum_index_compatibility_version: <<VersionString>>
  minimum_wire_compatibility_version: <<VersionString>>
  number: string
}
----


[discrete]
[[EmptyObject]]
=== EmptyObject

[source,ts,subs=+macros]
----
interface EmptyObject {}
----


[discrete]
[[EpochTime]]
=== EpochTime

[source,ts,subs=+macros]
----
type EpochTime<Unit = unknown> = Unit
----


[discrete]
[[ErrorCause]]
=== ErrorCause

[source,ts,subs=+macros]
----
interface ErrorCauseKeys {
  type: string
  reason?: string
  stack_trace?: string
  caused_by?: <<ErrorCause>>
  root_cause?: <<ErrorCause>>[]
  suppressed?: <<ErrorCause>>[]
}
type ErrorCause = ErrorCauseKeys
  & { [property: string]: any }
----


[discrete]
[[ErrorResponseBase]]
=== ErrorResponseBase

[source,ts,subs=+macros]
----
interface ErrorResponseBase {
  error: <<ErrorCause>>
  status: <<integer>>
}
----


[discrete]
[[EsqlColumns]]
=== EsqlColumns

[source,ts,subs=+macros]
----
type EsqlColumns = ArrayBuffer
----


[discrete]
[[ExpandWildcard]]
=== ExpandWildcard

[source,ts,subs=+macros]
----
type ExpandWildcard = 'all' | 'open' | 'closed' | 'hidden' | 'none'
----


[discrete]
[[ExpandWildcards]]
=== ExpandWildcards

[source,ts,subs=+macros]
----
type ExpandWildcards = <<ExpandWildcard>> | <<ExpandWildcard>>[]
----


[discrete]
[[Field]]
=== Field

[source,ts,subs=+macros]
----
type Field = string
----


[discrete]
[[FieldMemoryUsage]]
=== FieldMemoryUsage

[source,ts,subs=+macros]
----
interface FieldMemoryUsage {
  memory_size?: <<ByteSize>>
  memory_size_in_bytes: <<long>>
}
----


[discrete]
[[FieldSizeUsage]]
=== FieldSizeUsage

[source,ts,subs=+macros]
----
interface FieldSizeUsage {
  size?: <<ByteSize>>
  size_in_bytes: <<long>>
}
----


[discrete]
[[FieldSort]]
=== FieldSort

[source,ts,subs=+macros]
----
interface FieldSort {
  missing?: <<AggregationsMissing>>
  mode?: <<SortMode>>
  nested?: <<NestedSortValue>>
  order?: <<SortOrder>>
  unmapped_type?: <<MappingFieldType>>
  numeric_type?: <<FieldSortNumericType>>
  format?: string
}
----


[discrete]
[[FieldSortNumericType]]
=== FieldSortNumericType

[source,ts,subs=+macros]
----
type FieldSortNumericType = '<<long>>' | '<<double>>' | 'date' | 'date_nanos'
----


[discrete]
[[FieldValue]]
=== FieldValue

[source,ts,subs=+macros]
----
type FieldValue = <<long>> | <<double>> | string | boolean | null | any
----


[discrete]
[[FielddataStats]]
=== FielddataStats

[source,ts,subs=+macros]
----
interface FielddataStats {
  evictions?: <<long>>
  memory_size?: <<ByteSize>>
  memory_size_in_bytes: <<long>>
  fields?: Record<<<Field>>, <<FieldMemoryUsage>>>
}
----


[discrete]
[[Fields]]
=== Fields

[source,ts,subs=+macros]
----
type Fields = <<Field>> | <<Field>>[]
----


[discrete]
[[FlushStats]]
=== FlushStats

[source,ts,subs=+macros]
----
interface FlushStats {
  periodic: <<long>>
  total: <<long>>
  total_time?: <<Duration>>
  total_time_in_millis: <<DurationValue>><<<UnitMillis>>>
}
----


[discrete]
[[Fuzziness]]
=== Fuzziness

[source,ts,subs=+macros]
----
type Fuzziness = string | <<integer>>
----


[discrete]
[[GeoBounds]]
=== GeoBounds

[source,ts,subs=+macros]
----
type GeoBounds = <<CoordsGeoBounds>> | <<TopLeftBottomRightGeoBounds>> | <<TopRightBottomLeftGeoBounds>> | <<WktGeoBounds>>
----


[discrete]
[[GeoDistanceSort]]
=== GeoDistanceSort

[source,ts,subs=+macros]
----
interface GeoDistanceSortKeys {
  mode?: <<SortMode>>
  distance_type?: <<GeoDistanceType>>
  ignore_unmapped?: boolean
  order?: <<SortOrder>>
  unit?: <<DistanceUnit>>
  nested?: <<NestedSortValue>>
}
type GeoDistanceSort = GeoDistanceSortKeys
  & { [property: string]: <<GeoLocation>> | <<GeoLocation>>[] | <<SortMode>> | <<GeoDistanceType>> | boolean | <<SortOrder>> | <<DistanceUnit>> | <<NestedSortValue>> }
----


[discrete]
[[GeoDistanceType]]
=== GeoDistanceType

[source,ts,subs=+macros]
----
type GeoDistanceType = 'arc' | 'plane'
----


[discrete]
[[GeoHash]]
=== GeoHash

[source,ts,subs=+macros]
----
type GeoHash = string
----


[discrete]
[[GeoHashLocation]]
=== GeoHashLocation

[source,ts,subs=+macros]
----
interface GeoHashLocation {
  geohash: <<GeoHash>>
}
----


[discrete]
[[GeoHashPrecision]]
=== GeoHashPrecision

[source,ts,subs=+macros]
----
type GeoHashPrecision = number | string
----


[discrete]
[[GeoHexCell]]
=== GeoHexCell

[source,ts,subs=+macros]
----
type GeoHexCell = string
----


[discrete]
[[GeoLine]]
=== GeoLine

[source,ts,subs=+macros]
----
interface GeoLine {
  pass:[/**] @property type Always `"LineString"` */
  type: string
  pass:[/**] @property coordinates Array of `[lon, lat]` coordinates */
  coordinates: <<double>>[][]
}
----


[discrete]
[[GeoLocation]]
=== GeoLocation

[source,ts,subs=+macros]
----
type GeoLocation = <<LatLonGeoLocation>> | <<GeoHashLocation>> | <<double>>[] | string
----


[discrete]
[[GeoShape]]
=== GeoShape

[source,ts,subs=+macros]
----
type GeoShape = any
----


[discrete]
[[GeoShapeRelation]]
=== GeoShapeRelation

[source,ts,subs=+macros]
----
type GeoShapeRelation = 'intersects' | 'disjoint' | 'within' | 'contains'
----


[discrete]
[[GeoTile]]
=== GeoTile

[source,ts,subs=+macros]
----
type GeoTile = string
----


[discrete]
[[GeoTilePrecision]]
=== GeoTilePrecision

[source,ts,subs=+macros]
----
type GeoTilePrecision = number
----


[discrete]
[[GetStats]]
=== GetStats

[source,ts,subs=+macros]
----
interface GetStats {
  current: <<long>>
  exists_time?: <<Duration>>
  exists_time_in_millis: <<DurationValue>><<<UnitMillis>>>
  exists_total: <<long>>
  missing_time?: <<Duration>>
  missing_time_in_millis: <<DurationValue>><<<UnitMillis>>>
  missing_total: <<long>>
  time?: <<Duration>>
  time_in_millis: <<DurationValue>><<<UnitMillis>>>
  total: <<long>>
}
----


[discrete]
[[GrokPattern]]
=== GrokPattern

[source,ts,subs=+macros]
----
type GrokPattern = string
----


[discrete]
[[HealthStatus]]
=== HealthStatus

[source,ts,subs=+macros]
----
type HealthStatus = 'green' | 'GREEN' | 'yellow' | 'YELLOW' | 'red' | 'RED'
----


[discrete]
[[Host]]
=== Host

[source,ts,subs=+macros]
----
type Host = string
----


[discrete]
[[HttpHeaders]]
=== HttpHeaders

[source,ts,subs=+macros]
----
type HttpHeaders = Record<string, string | string[]>
----


[discrete]
[[IBDistribution]]
=== IBDistribution

[source,ts,subs=+macros]
----
type IBDistribution = 'll' | 'spl'
----


[discrete]
[[IBLambda]]
=== IBLambda

[source,ts,subs=+macros]
----
type IBLambda = 'df' | 'ttf'
----


[discrete]
[[Id]]
=== Id

[source,ts,subs=+macros]
----
type Id = string
----


[discrete]
[[Ids]]
=== Ids

[source,ts,subs=+macros]
----
type Ids = <<Id>> | <<Id>>[]
----


[discrete]
[[IndexAlias]]
=== IndexAlias

[source,ts,subs=+macros]
----
type IndexAlias = string
----


[discrete]
[[IndexName]]
=== IndexName

[source,ts,subs=+macros]
----
type IndexName = string
----


[discrete]
[[IndexPattern]]
=== IndexPattern

[source,ts,subs=+macros]
----
type IndexPattern = string
----


[discrete]
[[IndexPatterns]]
=== IndexPatterns

[source,ts,subs=+macros]
----
type IndexPatterns = <<IndexPattern>>[]
----


[discrete]
[[IndexingStats]]
=== IndexingStats

[source,ts,subs=+macros]
----
interface IndexingStats {
  index_current: <<long>>
  delete_current: <<long>>
  delete_time?: <<Duration>>
  delete_time_in_millis: <<DurationValue>><<<UnitMillis>>>
  delete_total: <<long>>
  is_throttled: boolean
  noop_update_total: <<long>>
  throttle_time?: <<Duration>>
  throttle_time_in_millis: <<DurationValue>><<<UnitMillis>>>
  index_time?: <<Duration>>
  index_time_in_millis: <<DurationValue>><<<UnitMillis>>>
  index_total: <<long>>
  index_failed: <<long>>
  types?: Record<string, <<IndexingStats>>>
  write_load?: <<double>>
}
----


[discrete]
[[Indices]]
=== Indices

[source,ts,subs=+macros]
----
type Indices = <<IndexName>> | <<IndexName>>[]
----


[discrete]
[[IndicesOptions]]
=== IndicesOptions

[source,ts,subs=+macros]
----
interface IndicesOptions {
  pass:[/**] @property allow_no_indices If false, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`. */
  allow_no_indices?: boolean
  pass:[/**] @property expand_wildcards Type of index that wildcard patterns can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams. Supports comma-separated values, such as `open,hidden`. */
  expand_wildcards?: <<ExpandWildcards>>
  pass:[/**] @property ignore_unavailable If true, missing or closed indices are not included in the response. */
  ignore_unavailable?: boolean
  pass:[/**] @property ignore_throttled If true, concrete, expanded or aliased indices are ignored when frozen. */
  ignore_throttled?: boolean
}
----


[discrete]
[[IndicesResponseBase]]
=== IndicesResponseBase

[source,ts,subs=+macros]
----
interface IndicesResponseBase extends <<AcknowledgedResponseBase>> {
  _shards?: <<ShardStatistics>>
}
----


[discrete]
[[InlineGet]]
=== InlineGet

[source,ts,subs=+macros]
----
interface InlineGetKeys<TDocument = unknown> {
  fields?: Record<string, any>
  found: boolean
  _seq_no?: <<SequenceNumber>>
  _primary_term?: <<long>>
  _routing?: <<Routing>>
  _source?: TDocument
}
type InlineGet<TDocument = unknown> = InlineGetKeys<TDocument>
  & { [property: string]: any }
----


[discrete]
[[Ip]]
=== Ip

[source,ts,subs=+macros]
----
type Ip = string
----


[discrete]
[[KnnQuery]]
=== KnnQuery

[source,ts,subs=+macros]
----
interface KnnQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property field The name of the vector field to search against */
  field: <<Field>>
  pass:[/**] @property query_vector The query vector */
  query_vector?: <<QueryVector>>
  pass:[/**] @property query_vector_builder The query vector builder. You must provide a query_vector_builder or query_vector, but not both. */
  query_vector_builder?: <<QueryVectorBuilder>>
  pass:[/**] @property num_candidates The number of nearest neighbor candidates to consider per shard */
  num_candidates?: <<integer>>
  pass:[/**] @property k The final number of nearest neighbors to return as top hits */
  k?: <<integer>>
  pass:[/**] @property filter Filters for the kNN search query */
  filter?: <<QueryDslQueryContainer>> | <<QueryDslQueryContainer>>[]
  pass:[/**] @property similarity The minimum similarity for a vector to be considered a match */
  similarity?: <<float>>
}
----


[discrete]
[[KnnRetriever]]
=== KnnRetriever

[source,ts,subs=+macros]
----
interface KnnRetriever extends <<RetrieverBase>> {
  pass:[/**] @property field The name of the vector field to search against. */
  field: string
  pass:[/**] @property query_vector Query vector. Must have the same number of dimensions as the vector field you are searching against. You must provide a query_vector_builder or query_vector, but not both. */
  query_vector?: <<QueryVector>>
  pass:[/**] @property query_vector_builder Defines a model to build a query vector. */
  query_vector_builder?: <<QueryVectorBuilder>>
  pass:[/**] @property k Number of nearest neighbors to return as top hits. */
  k: <<integer>>
  pass:[/**] @property num_candidates Number of nearest neighbor candidates to consider per shard. */
  num_candidates: <<integer>>
  pass:[/**] @property similarity The minimum similarity required for a document to be considered a match. */
  similarity?: <<float>>
}
----


[discrete]
[[KnnSearch]]
=== KnnSearch

[source,ts,subs=+macros]
----
interface KnnSearch {
  pass:[/**] @property field The name of the vector field to search against */
  field: <<Field>>
  pass:[/**] @property query_vector The query vector */
  query_vector?: <<QueryVector>>
  pass:[/**] @property query_vector_builder The query vector builder. You must provide a query_vector_builder or query_vector, but not both. */
  query_vector_builder?: <<QueryVectorBuilder>>
  pass:[/**] @property k The final number of nearest neighbors to return as top hits */
  k?: <<integer>>
  pass:[/**] @property num_candidates The number of nearest neighbor candidates to consider per shard */
  num_candidates?: <<integer>>
  pass:[/**] @property boost Boost value to apply to kNN scores */
  boost?: <<float>>
  pass:[/**] @property filter Filters for the kNN search query */
  filter?: <<QueryDslQueryContainer>> | <<QueryDslQueryContainer>>[]
  pass:[/**] @property similarity The minimum similarity for a vector to be considered a match */
  similarity?: <<float>>
  pass:[/**] @property inner_hits If defined, each search hit will contain inner hits. */
  inner_hits?: <<SearchInnerHits>>
}
----


[discrete]
[[LatLonGeoLocation]]
=== LatLonGeoLocation

[source,ts,subs=+macros]
----
interface LatLonGeoLocation {
  pass:[/**] @property lat Latitude */
  lat: <<double>>
  pass:[/**] @property lon Longitude */
  lon: <<double>>
}
----


[discrete]
[[Level]]
=== Level

[source,ts,subs=+macros]
----
type Level = 'cluster' | 'indices' | 'shards'
----


[discrete]
[[LifecycleOperationMode]]
=== LifecycleOperationMode

[source,ts,subs=+macros]
----
type LifecycleOperationMode = 'RUNNING' | 'STOPPING' | 'STOPPED'
----


[discrete]
[[MapboxVectorTiles]]
=== MapboxVectorTiles

[source,ts,subs=+macros]
----
type MapboxVectorTiles = ArrayBuffer
----


[discrete]
[[MergesStats]]
=== MergesStats

[source,ts,subs=+macros]
----
interface MergesStats {
  current: <<long>>
  current_docs: <<long>>
  current_size?: string
  current_size_in_bytes: <<long>>
  total: <<long>>
  total_auto_throttle?: string
  total_auto_throttle_in_bytes: <<long>>
  total_docs: <<long>>
  total_size?: string
  total_size_in_bytes: <<long>>
  total_stopped_time?: <<Duration>>
  total_stopped_time_in_millis: <<DurationValue>><<<UnitMillis>>>
  total_throttled_time?: <<Duration>>
  total_throttled_time_in_millis: <<DurationValue>><<<UnitMillis>>>
  total_time?: <<Duration>>
  total_time_in_millis: <<DurationValue>><<<UnitMillis>>>
}
----


[discrete]
[[Metadata]]
=== Metadata

[source,ts,subs=+macros]
----
type Metadata = Record<string, any>
----


[discrete]
[[Metrics]]
=== Metrics

[source,ts,subs=+macros]
----
type Metrics = string | string[]
----


[discrete]
[[MinimumShouldMatch]]
=== MinimumShouldMatch

[source,ts,subs=+macros]
----
type MinimumShouldMatch = <<integer>> | string
----


[discrete]
[[MultiTermQueryRewrite]]
=== MultiTermQueryRewrite

[source,ts,subs=+macros]
----
type MultiTermQueryRewrite = string
----


[discrete]
[[Name]]
=== Name

[source,ts,subs=+macros]
----
type Name = string
----


[discrete]
[[Names]]
=== Names

[source,ts,subs=+macros]
----
type Names = <<Name>> | <<Name>>[]
----


[discrete]
[[Namespace]]
=== Namespace

[source,ts,subs=+macros]
----
type Namespace = string
----


[discrete]
[[NestedSortValue]]
=== NestedSortValue

[source,ts,subs=+macros]
----
interface NestedSortValue {
  filter?: <<QueryDslQueryContainer>>
  max_children?: <<integer>>
  nested?: <<NestedSortValue>>
  path: <<Field>>
}
----


[discrete]
[[NodeAttributes]]
=== NodeAttributes

[source,ts,subs=+macros]
----
interface NodeAttributes {
  pass:[/**] @property attributes Lists node attributes. */
  attributes: Record<string, string>
  pass:[/**] @property ephemeral_id The ephemeral ID of the node. */
  ephemeral_id: <<Id>>
  pass:[/**] @property id The unique identifier of the node. */
  id?: <<NodeId>>
  pass:[/**] @property name The unique identifier of the node. */
  name: <<NodeName>>
  pass:[/**] @property transport_address The host and port where transport HTTP connections are accepted. */
  transport_address: <<TransportAddress>>
}
----


[discrete]
[[NodeId]]
=== NodeId

[source,ts,subs=+macros]
----
type NodeId = string
----


[discrete]
[[NodeIds]]
=== NodeIds

[source,ts,subs=+macros]
----
type NodeIds = <<NodeId>> | <<NodeId>>[]
----


[discrete]
[[NodeName]]
=== NodeName

[source,ts,subs=+macros]
----
type NodeName = string
----


[discrete]
[[NodeRole]]
=== NodeRole

[source,ts,subs=+macros]
----
type NodeRole = 'master' | 'data' | 'data_cold' | 'data_content' | 'data_frozen' | 'data_hot' | 'data_warm' | 'client' | 'ingest' | 'ml' | 'voting_only' | 'transform' | 'remote_cluster_client' | 'coordinating_only'
----


[discrete]
[[NodeRoles]]
=== NodeRoles

[source,ts,subs=+macros]
----
type NodeRoles = <<NodeRole>>[]
----


[discrete]
[[NodeShard]]
=== NodeShard

[source,ts,subs=+macros]
----
interface NodeShard {
  state: IndicesStatsShardRoutingState
  primary: boolean
  node?: <<NodeName>>
  shard: <<integer>>
  index: <<IndexName>>
  allocation_id?: Record<string, <<Id>>>
  recovery_source?: Record<string, <<Id>>>
  unassigned_info?: ClusterAllocationExplainUnassignedInformation
  relocating_node?: <<NodeId>> | null
  relocation_failure_info?: <<RelocationFailureInfo>>
}
----


[discrete]
[[NodeStatistics]]
=== NodeStatistics

[source,ts,subs=+macros]
----
interface NodeStatistics {
  failures?: <<ErrorCause>>[]
  pass:[/**] @property total Total number of nodes selected by the request. */
  total: <<integer>>
  pass:[/**] @property successful Number of nodes that responded successfully to the request. */
  successful: <<integer>>
  pass:[/**] @property failed Number of nodes that rejected the request or failed to respond. If this value is not 0, a reason for the rejection or failure is included in the response. */
  failed: <<integer>>
}
----


[discrete]
[[Normalization]]
=== Normalization

[source,ts,subs=+macros]
----
type Normalization = 'no' | 'h1' | 'h2' | 'h3' | 'z'
----


[discrete]
[[OpType]]
=== OpType

[source,ts,subs=+macros]
----
type OpType = 'index' | 'create'
----


[discrete]
[[Password]]
=== Password

[source,ts,subs=+macros]
----
type Password = string
----


[discrete]
[[Percentage]]
=== Percentage

[source,ts,subs=+macros]
----
type Percentage = string | <<float>>
----


[discrete]
[[PipelineName]]
=== PipelineName

[source,ts,subs=+macros]
----
type PipelineName = string
----


[discrete]
[[PluginStats]]
=== PluginStats

[source,ts,subs=+macros]
----
interface PluginStats {
  classname: string
  description: string
  elasticsearch_version: <<VersionString>>
  extended_plugins: string[]
  has_native_controller: boolean
  java_version: <<VersionString>>
  name: <<Name>>
  version: <<VersionString>>
  licensed: boolean
}
----


[discrete]
[[PropertyName]]
=== PropertyName

[source,ts,subs=+macros]
----
type PropertyName = string
----


[discrete]
[[QueryCacheStats]]
=== QueryCacheStats

[source,ts,subs=+macros]
----
interface QueryCacheStats {
  pass:[/**] @property cache_count Total number of entries added to the query cache across all shards assigned to selected nodes. This number includes current and evicted entries. */
  cache_count: <<long>>
  pass:[/**] @property cache_size Total number of entries currently in the query cache across all shards assigned to selected nodes. */
  cache_size: <<long>>
  pass:[/**] @property evictions Total number of query cache evictions across all shards assigned to selected nodes. */
  evictions: <<long>>
  pass:[/**] @property hit_count Total count of query cache hits across all shards assigned to selected nodes. */
  hit_count: <<long>>
  pass:[/**] @property memory_size Total amount of memory used for the query cache across all shards assigned to selected nodes. */
  memory_size?: <<ByteSize>>
  pass:[/**] @property memory_size_in_bytes Total amount, in bytes, of memory used for the query cache across all shards assigned to selected nodes. */
  memory_size_in_bytes: <<long>>
  pass:[/**] @property miss_count Total count of query cache misses across all shards assigned to selected nodes. */
  miss_count: <<long>>
  pass:[/**] @property total_count Total count of hits and misses in the query cache across all shards assigned to selected nodes. */
  total_count: <<long>>
}
----


[discrete]
[[QueryVector]]
=== QueryVector

[source,ts,subs=+macros]
----
type QueryVector = <<float>>[]
----


[discrete]
[[QueryVectorBuilder]]
=== QueryVectorBuilder

[source,ts,subs=+macros]
----
interface QueryVectorBuilder {
  text_embedding?: <<TextEmbedding>>
}
----


[discrete]
[[RRFRetriever]]
=== RRFRetriever

[source,ts,subs=+macros]
----
interface RRFRetriever extends <<RetrieverBase>> {
  pass:[/**] @property retrievers A list of child retrievers to specify which sets of returned top documents will have the RRF formula applied to them. */
  retrievers: <<RetrieverContainer>>[]
  pass:[/**] @property rank_constant This value determines how much influence documents in individual result sets per query have over the final ranked result set. */
  rank_constant?: <<integer>>
  pass:[/**] @property rank_window_size This value determines the size of the individual result sets per query. */
  rank_window_size?: <<integer>>
}
----


[discrete]
[[RankBase]]
=== RankBase

[source,ts,subs=+macros]
----
interface RankBase {}
----


[discrete]
[[RankContainer]]
=== RankContainer

[source,ts,subs=+macros]
----
interface RankContainer {
  pass:[/**] @property rrf The reciprocal rank fusion parameters */
  rrf?: <<RrfRank>>
}
----


[discrete]
[[RecoveryStats]]
=== RecoveryStats

[source,ts,subs=+macros]
----
interface RecoveryStats {
  current_as_source: <<long>>
  current_as_target: <<long>>
  throttle_time?: <<Duration>>
  throttle_time_in_millis: <<DurationValue>><<<UnitMillis>>>
}
----


[discrete]
[[Refresh]]
=== Refresh

[source,ts,subs=+macros]
----
type Refresh = boolean | 'true' | 'false' | 'wait_for'
----


[discrete]
[[RefreshStats]]
=== RefreshStats

[source,ts,subs=+macros]
----
interface RefreshStats {
  external_total: <<long>>
  external_total_time_in_millis: <<DurationValue>><<<UnitMillis>>>
  listeners: <<long>>
  total: <<long>>
  total_time?: <<Duration>>
  total_time_in_millis: <<DurationValue>><<<UnitMillis>>>
}
----


[discrete]
[[RelationName]]
=== RelationName

[source,ts,subs=+macros]
----
type RelationName = string
----


[discrete]
[[RelocationFailureInfo]]
=== RelocationFailureInfo

[source,ts,subs=+macros]
----
interface RelocationFailureInfo {
  failed_attempts: <<integer>>
}
----


[discrete]
[[RequestBase]]
=== RequestBase

[source,ts,subs=+macros]
----
interface RequestBase extends <<SpecUtilsCommonQueryParameters>> {}
----


[discrete]
[[RequestCacheStats]]
=== RequestCacheStats

[source,ts,subs=+macros]
----
interface RequestCacheStats {
  evictions: <<long>>
  hit_count: <<long>>
  memory_size?: string
  memory_size_in_bytes: <<long>>
  miss_count: <<long>>
}
----


[discrete]
[[Result]]
=== Result

[source,ts,subs=+macros]
----
type Result = 'created' | 'updated' | 'deleted' | 'not_found' | 'noop'
----


[discrete]
[[Retries]]
=== Retries

[source,ts,subs=+macros]
----
interface Retries {
  bulk: <<long>>
  search: <<long>>
}
----


[discrete]
[[RetrieverBase]]
=== RetrieverBase

[source,ts,subs=+macros]
----
interface RetrieverBase {
  pass:[/**] @property filter Query to filter the documents that can match. */
  filter?: <<QueryDslQueryContainer>> | <<QueryDslQueryContainer>>[]
  pass:[/**] @property min_score Minimum _score for matching documents. Documents with a lower _score are not included in the top documents. */
  min_score?: <<float>>
}
----


[discrete]
[[RetrieverContainer]]
=== RetrieverContainer

[source,ts,subs=+macros]
----
interface RetrieverContainer {
  pass:[/**] @property standard A retriever that replaces the functionality of a traditional query. */
  standard?: <<StandardRetriever>>
  pass:[/**] @property knn A retriever that replaces the functionality of a knn search. */
  knn?: <<KnnRetriever>>
  pass:[/**] @property rrf A retriever that produces top documents from reciprocal rank fusion (RRF). */
  rrf?: <<RRFRetriever>>
  pass:[/**] @property text_similarity_reranker A retriever that reranks the top documents based on a reranking model using the InferenceAPI */
  text_similarity_reranker?: <<TextSimilarityReranker>>
}
----


[discrete]
[[Routing]]
=== Routing

[source,ts,subs=+macros]
----
type Routing = string
----


[discrete]
[[RrfRank]]
=== RrfRank

[source,ts,subs=+macros]
----
interface RrfRank {
  pass:[/**] @property rank_constant How much influence documents in individual result sets per query have over the final ranked result set */
  rank_constant?: <<long>>
  pass:[/**] @property rank_window_size Size of the individual result sets per query */
  rank_window_size?: <<long>>
}
----


[discrete]
[[ScalarValue]]
=== ScalarValue

[source,ts,subs=+macros]
----
type ScalarValue = <<long>> | <<double>> | string | boolean | null
----


[discrete]
[[ScoreSort]]
=== ScoreSort

[source,ts,subs=+macros]
----
interface ScoreSort {
  order?: <<SortOrder>>
}
----


[discrete]
[[Script]]
=== Script

[source,ts,subs=+macros]
----
interface Script {
  pass:[/**] @property source The script source. */
  source?: string
  pass:[/**] @property id The `id` for a stored script. */
  id?: <<Id>>
  pass:[/**] @property params Specifies any named parameters that are passed into the script as variables. Use parameters instead of hard-coded values to decrease compile time. */
  params?: Record<string, any>
  pass:[/**] @property lang Specifies the language the script is written in. */
  lang?: <<ScriptLanguage>>
  options?: Record<string, string>
}
----


[discrete]
[[ScriptField]]
=== ScriptField

[source,ts,subs=+macros]
----
interface ScriptField {
  script: <<Script>> | string
  ignore_failure?: boolean
}
----


[discrete]
[[ScriptLanguage]]
=== ScriptLanguage

[source,ts,subs=+macros]
----
type ScriptLanguage = 'painless' | 'expression' | 'mustache' | 'java' | string
----


[discrete]
[[ScriptSort]]
=== ScriptSort

[source,ts,subs=+macros]
----
interface ScriptSort {
  order?: <<SortOrder>>
  script: <<Script>> | string
  type?: <<ScriptSortType>>
  mode?: <<SortMode>>
  nested?: <<NestedSortValue>>
}
----


[discrete]
[[ScriptSortType]]
=== ScriptSortType

[source,ts,subs=+macros]
----
type ScriptSortType = 'string' | 'number' | 'version'
----


[discrete]
[[ScriptTransform]]
=== ScriptTransform

[source,ts,subs=+macros]
----
interface ScriptTransform {
  lang?: string
  params?: Record<string, any>
  source?: string
  id?: string
}
----


[discrete]
[[ScrollId]]
=== ScrollId

[source,ts,subs=+macros]
----
type ScrollId = string
----


[discrete]
[[ScrollIds]]
=== ScrollIds

[source,ts,subs=+macros]
----
type ScrollIds = <<ScrollId>> | <<ScrollId>>[]
----


[discrete]
[[SearchStats]]
=== SearchStats

[source,ts,subs=+macros]
----
interface SearchStats {
  fetch_current: <<long>>
  fetch_time?: <<Duration>>
  fetch_time_in_millis: <<DurationValue>><<<UnitMillis>>>
  fetch_total: <<long>>
  open_contexts?: <<long>>
  query_current: <<long>>
  query_time?: <<Duration>>
  query_time_in_millis: <<DurationValue>><<<UnitMillis>>>
  query_total: <<long>>
  scroll_current: <<long>>
  scroll_time?: <<Duration>>
  scroll_time_in_millis: <<DurationValue>><<<UnitMillis>>>
  scroll_total: <<long>>
  suggest_current: <<long>>
  suggest_time?: <<Duration>>
  suggest_time_in_millis: <<DurationValue>><<<UnitMillis>>>
  suggest_total: <<long>>
  groups?: Record<string, <<SearchStats>>>
}
----


[discrete]
[[SearchTransform]]
=== SearchTransform

[source,ts,subs=+macros]
----
interface SearchTransform {
  request: <<WatcherSearchInputRequestDefinition>>
  timeout: <<Duration>>
}
----


[discrete]
[[SearchType]]
=== SearchType

[source,ts,subs=+macros]
----
type SearchType = 'query_then_fetch' | 'dfs_query_then_fetch'
----


[discrete]
[[SegmentsStats]]
=== SegmentsStats

[source,ts,subs=+macros]
----
interface SegmentsStats {
  pass:[/**] @property count Total number of segments across all shards assigned to selected nodes. */
  count: <<integer>>
  pass:[/**] @property doc_values_memory Total amount of memory used for doc values across all shards assigned to selected nodes. */
  doc_values_memory?: <<ByteSize>>
  pass:[/**] @property doc_values_memory_in_bytes Total amount, in bytes, of memory used for doc values across all shards assigned to selected nodes. */
  doc_values_memory_in_bytes: <<long>>
  pass:[/**] @property file_sizes This object is not populated by the cluster stats API. To get information on segment files, use the node stats API. */
  file_sizes: Record<string, IndicesStatsShardFileSizeInfo>
  pass:[/**] @property fixed_bit_set Total amount of memory used by fixed bit sets across all shards assigned to selected nodes. Fixed bit sets are used for nested object field types and type filters for join fields. */
  fixed_bit_set?: <<ByteSize>>
  pass:[/**] @property fixed_bit_set_memory_in_bytes Total amount of memory, in bytes, used by fixed bit sets across all shards assigned to selected nodes. */
  fixed_bit_set_memory_in_bytes: <<long>>
  pass:[/**] @property index_writer_memory Total amount of memory used by all index writers across all shards assigned to selected nodes. */
  index_writer_memory?: <<ByteSize>>
  index_writer_max_memory_in_bytes?: <<long>>
  pass:[/**] @property index_writer_memory_in_bytes Total amount, in bytes, of memory used by all index writers across all shards assigned to selected nodes. */
  index_writer_memory_in_bytes: <<long>>
  pass:[/**] @property max_unsafe_auto_id_timestamp Unix timestamp, in milliseconds, of the most recently retried indexing request. */
  max_unsafe_auto_id_timestamp: <<long>>
  pass:[/**] @property memory Total amount of memory used for segments across all shards assigned to selected nodes. */
  memory?: <<ByteSize>>
  pass:[/**] @property memory_in_bytes Total amount, in bytes, of memory used for segments across all shards assigned to selected nodes. */
  memory_in_bytes: <<long>>
  pass:[/**] @property norms_memory Total amount of memory used for normalization factors across all shards assigned to selected nodes. */
  norms_memory?: <<ByteSize>>
  pass:[/**] @property norms_memory_in_bytes Total amount, in bytes, of memory used for normalization factors across all shards assigned to selected nodes. */
  norms_memory_in_bytes: <<long>>
  pass:[/**] @property points_memory Total amount of memory used for points across all shards assigned to selected nodes. */
  points_memory?: <<ByteSize>>
  pass:[/**] @property points_memory_in_bytes Total amount, in bytes, of memory used for points across all shards assigned to selected nodes. */
  points_memory_in_bytes: <<long>>
  stored_memory?: <<ByteSize>>
  pass:[/**] @property stored_fields_memory_in_bytes Total amount, in bytes, of memory used for stored fields across all shards assigned to selected nodes. */
  stored_fields_memory_in_bytes: <<long>>
  pass:[/**] @property terms_memory_in_bytes Total amount, in bytes, of memory used for terms across all shards assigned to selected nodes. */
  terms_memory_in_bytes: <<long>>
  pass:[/**] @property terms_memory Total amount of memory used for terms across all shards assigned to selected nodes. */
  terms_memory?: <<ByteSize>>
  pass:[/**] @property term_vectory_memory Total amount of memory used for term vectors across all shards assigned to selected nodes. */
  term_vectory_memory?: <<ByteSize>>
  pass:[/**] @property term_vectors_memory_in_bytes Total amount, in bytes, of memory used for term vectors across all shards assigned to selected nodes. */
  term_vectors_memory_in_bytes: <<long>>
  pass:[/**] @property version_map_memory Total amount of memory used by all version maps across all shards assigned to selected nodes. */
  version_map_memory?: <<ByteSize>>
  pass:[/**] @property version_map_memory_in_bytes Total amount, in bytes, of memory used by all version maps across all shards assigned to selected nodes. */
  version_map_memory_in_bytes: <<long>>
}
----


[discrete]
[[SequenceNumber]]
=== SequenceNumber

[source,ts,subs=+macros]
----
type SequenceNumber = <<long>>
----


[discrete]
[[Service]]
=== Service

[source,ts,subs=+macros]
----
type Service = string
----


[discrete]
[[ShardFailure]]
=== ShardFailure

[source,ts,subs=+macros]
----
interface ShardFailure {
  index?: <<IndexName>>
  node?: string
  reason: <<ErrorCause>>
  shard: <<integer>>
  status?: string
}
----


[discrete]
[[ShardStatistics]]
=== ShardStatistics

[source,ts,subs=+macros]
----
interface ShardStatistics {
  failed: <<uint>>
  pass:[/**] @property successful Indicates how many shards have successfully run the search. */
  successful: <<uint>>
  pass:[/**] @property total Indicates how many shards the search will run on overall. */
  total: <<uint>>
  failures?: <<ShardFailure>>[]
  skipped?: <<uint>>
}
----


[discrete]
[[ShardsOperationResponseBase]]
=== ShardsOperationResponseBase

[source,ts,subs=+macros]
----
interface ShardsOperationResponseBase {
  _shards?: <<ShardStatistics>>
}
----


[discrete]
[[SlicedScroll]]
=== SlicedScroll

[source,ts,subs=+macros]
----
interface SlicedScroll {
  field?: <<Field>>
  id: <<Id>>
  max: <<integer>>
}
----


[discrete]
[[Slices]]
=== Slices

[source,ts,subs=+macros]
----
type Slices = <<integer>> | <<SlicesCalculation>>
----


[discrete]
[[SlicesCalculation]]
=== SlicesCalculation

[source,ts,subs=+macros]
----
type SlicesCalculation = 'auto'
----


[discrete]
[[Sort]]
=== Sort

[source,ts,subs=+macros]
----
type Sort = <<SortCombinations>> | <<SortCombinations>>[]
----


[discrete]
[[SortCombinations]]
=== SortCombinations

[source,ts,subs=+macros]
----
type SortCombinations = <<Field>> | <<SortOptions>>
----


[discrete]
[[SortMode]]
=== SortMode

[source,ts,subs=+macros]
----
type SortMode = 'min' | 'max' | 'sum' | 'avg' | 'median'
----


[discrete]
[[SortOptions]]
=== SortOptions

[source,ts,subs=+macros]
----
interface SortOptionsKeys {
  _score?: <<ScoreSort>>
  _doc?: <<ScoreSort>>
  _geo_distance?: <<GeoDistanceSort>>
  _script?: <<ScriptSort>>
}
type SortOptions = SortOptionsKeys
  & { [property: string]: <<FieldSort>> | <<SortOrder>> | <<ScoreSort>> | <<GeoDistanceSort>> | <<ScriptSort>> }
----


[discrete]
[[SortOrder]]
=== SortOrder

[source,ts,subs=+macros]
----
type SortOrder = 'asc' | 'desc'
----


[discrete]
[[SortResults]]
=== SortResults

[source,ts,subs=+macros]
----
type SortResults = <<FieldValue>>[]
----


[discrete]
[[StandardRetriever]]
=== StandardRetriever

[source,ts,subs=+macros]
----
interface StandardRetriever extends <<RetrieverBase>> {
  pass:[/**] @property query Defines a query to retrieve a set of top documents. */
  query?: <<QueryDslQueryContainer>>
  pass:[/**] @property search_after Defines a search after object parameter used for pagination. */
  search_after?: <<SortResults>>
  pass:[/**] @property terminate_after Maximum number of documents to collect for each shard. */
  terminate_after?: <<integer>>
  pass:[/**] @property sort A sort object that that specifies the order of matching documents. */
  sort?: <<Sort>>
  pass:[/**] @property collapse Collapses the top documents by a specified key into a single top document per key. */
  collapse?: <<SearchFieldCollapse>>
}
----


[discrete]
[[StoreStats]]
=== StoreStats

[source,ts,subs=+macros]
----
interface StoreStats {
  pass:[/**] @property size Total size of all shards assigned to selected nodes. */
  size?: <<ByteSize>>
  pass:[/**] @property size_in_bytes Total size, in bytes, of all shards assigned to selected nodes. */
  size_in_bytes: <<long>>
  pass:[/**] @property reserved A prediction of how much larger the shard stores will eventually grow due to ongoing peer recoveries, restoring snapshots, and similar activities. */
  reserved?: <<ByteSize>>
  pass:[/**] @property reserved_in_bytes A prediction, in bytes, of how much larger the shard stores will eventually grow due to ongoing peer recoveries, restoring snapshots, and similar activities. */
  reserved_in_bytes: <<long>>
  pass:[/**] @property total_data_set_size Total data set size of all shards assigned to selected nodes. This includes the size of shards not stored fully on the nodes, such as the cache for partially mounted indices. */
  total_data_set_size?: <<ByteSize>>
  pass:[/**] @property total_data_set_size_in_bytes Total data set size, in bytes, of all shards assigned to selected nodes. This includes the size of shards not stored fully on the nodes, such as the cache for partially mounted indices. */
  total_data_set_size_in_bytes?: <<long>>
}
----


[discrete]
[[StoredScript]]
=== StoredScript

[source,ts,subs=+macros]
----
interface StoredScript {
  pass:[/**] @property lang Specifies the language the script is written in. */
  lang: <<ScriptLanguage>>
  options?: Record<string, string>
  pass:[/**] @property source The script source. */
  source: string
}
----


[discrete]
[[SuggestMode]]
=== SuggestMode

[source,ts,subs=+macros]
----
type SuggestMode = 'missing' | 'popular' | 'always'
----


[discrete]
[[SuggestionName]]
=== SuggestionName

[source,ts,subs=+macros]
----
type SuggestionName = string
----


[discrete]
[[TaskFailure]]
=== TaskFailure

[source,ts,subs=+macros]
----
interface TaskFailure {
  task_id: <<long>>
  node_id: <<NodeId>>
  status: string
  reason: <<ErrorCause>>
}
----


[discrete]
[[TaskId]]
=== TaskId

[source,ts,subs=+macros]
----
type TaskId = string | <<integer>>
----


[discrete]
[[TextEmbedding]]
=== TextEmbedding

[source,ts,subs=+macros]
----
interface TextEmbedding {
  model_id: string
  model_text: string
}
----


[discrete]
[[TextSimilarityReranker]]
=== TextSimilarityReranker

[source,ts,subs=+macros]
----
interface TextSimilarityReranker extends <<RetrieverBase>> {
  pass:[/**] @property retriever The nested retriever which will produce the first-level results, that will later be used for reranking. */
  retriever: <<RetrieverContainer>>
  pass:[/**] @property rank_window_size This value determines how many documents we will consider from the nested retriever. */
  rank_window_size?: <<integer>>
  pass:[/**] @property inference_id Unique identifier of the inference endpoint created using the inference API. */
  inference_id?: string
  pass:[/**] @property inference_text The text snippet used as the basis for similarity comparison */
  inference_text?: string
  pass:[/**] @property field The document field to be used for text similarity comparisons. This field should contain the text that will be evaluated against the inference_text */
  field?: string
}
----


[discrete]
[[ThreadType]]
=== ThreadType

[source,ts,subs=+macros]
----
type ThreadType = 'cpu' | 'wait' | 'block' | 'gpu' | 'mem'
----


[discrete]
[[TimeOfDay]]
=== TimeOfDay

[source,ts,subs=+macros]
----
type TimeOfDay = string
----


[discrete]
[[TimeUnit]]
=== TimeUnit

[source,ts,subs=+macros]
----
type TimeUnit = 'nanos' | 'micros' | 'ms' | 's' | 'm' | 'h' | 'd'
----


[discrete]
[[TimeZone]]
=== TimeZone

[source,ts,subs=+macros]
----
type TimeZone = string
----


[discrete]
[[TopLeftBottomRightGeoBounds]]
=== TopLeftBottomRightGeoBounds

[source,ts,subs=+macros]
----
interface TopLeftBottomRightGeoBounds {
  top_left: <<GeoLocation>>
  bottom_right: <<GeoLocation>>
}
----


[discrete]
[[TopRightBottomLeftGeoBounds]]
=== TopRightBottomLeftGeoBounds

[source,ts,subs=+macros]
----
interface TopRightBottomLeftGeoBounds {
  top_right: <<GeoLocation>>
  bottom_left: <<GeoLocation>>
}
----


[discrete]
[[TransformContainer]]
=== TransformContainer

[source,ts,subs=+macros]
----
interface TransformContainer {
  chain?: <<TransformContainer>>[]
  script?: <<ScriptTransform>>
  search?: <<SearchTransform>>
}
----


[discrete]
[[TranslogStats]]
=== TranslogStats

[source,ts,subs=+macros]
----
interface TranslogStats {
  earliest_last_modified_age: <<long>>
  operations: <<long>>
  size?: string
  size_in_bytes: <<long>>
  uncommitted_operations: <<integer>>
  uncommitted_size?: string
  uncommitted_size_in_bytes: <<long>>
}
----


[discrete]
[[TransportAddress]]
=== TransportAddress

[source,ts,subs=+macros]
----
type TransportAddress = string
----


[discrete]
[[UnitFloatMillis]]
=== UnitFloatMillis

[source,ts,subs=+macros]
----
type UnitFloatMillis = <<double>>
----


[discrete]
[[UnitMillis]]
=== UnitMillis

[source,ts,subs=+macros]
----
type UnitMillis = <<long>>
----


[discrete]
[[UnitNanos]]
=== UnitNanos

[source,ts,subs=+macros]
----
type UnitNanos = <<long>>
----


[discrete]
[[UnitSeconds]]
=== UnitSeconds

[source,ts,subs=+macros]
----
type UnitSeconds = <<long>>
----


[discrete]
[[Username]]
=== Username

[source,ts,subs=+macros]
----
type Username = string
----


[discrete]
[[Uuid]]
=== Uuid

[source,ts,subs=+macros]
----
type Uuid = string
----


[discrete]
[[VersionNumber]]
=== VersionNumber

[source,ts,subs=+macros]
----
type VersionNumber = <<long>>
----


[discrete]
[[VersionString]]
=== VersionString

[source,ts,subs=+macros]
----
type VersionString = string
----


[discrete]
[[VersionType]]
=== VersionType

[source,ts,subs=+macros]
----
type VersionType = 'internal' | 'external' | 'external_gte' | 'force'
----


[discrete]
[[WaitForActiveShardOptions]]
=== WaitForActiveShardOptions

[source,ts,subs=+macros]
----
type WaitForActiveShardOptions = 'all' | 'index-setting'
----


[discrete]
[[WaitForActiveShards]]
=== WaitForActiveShards

[source,ts,subs=+macros]
----
type WaitForActiveShards = <<integer>> | <<WaitForActiveShardOptions>>
----


[discrete]
[[WaitForEvents]]
=== WaitForEvents

[source,ts,subs=+macros]
----
type WaitForEvents = 'immediate' | 'urgent' | 'high' | 'normal' | 'low' | 'languid'
----


[discrete]
[[WarmerStats]]
=== WarmerStats

[source,ts,subs=+macros]
----
interface WarmerStats {
  current: <<long>>
  total: <<long>>
  total_time?: <<Duration>>
  total_time_in_millis: <<DurationValue>><<<UnitMillis>>>
}
----


[discrete]
[[WktGeoBounds]]
=== WktGeoBounds

[source,ts,subs=+macros]
----
interface WktGeoBounds {
  wkt: string
}
----


[discrete]
[[WriteResponseBase]]
=== WriteResponseBase

[source,ts,subs=+macros]
----
interface WriteResponseBase {
  _id: <<Id>>
  _index: <<IndexName>>
  _primary_term?: <<long>>
  result: <<Result>>
  _seq_no?: <<SequenceNumber>>
  _shards: <<ShardStatistics>>
  _version: <<VersionNumber>>
  forced_refresh?: boolean
}
----


[discrete]
[[byte]]
=== byte

[source,ts,subs=+macros]
----
type byte = number
----


[discrete]
[[double]]
=== double

[source,ts,subs=+macros]
----
type double = number
----


[discrete]
[[float]]
=== float

[source,ts,subs=+macros]
----
type float = number
----


[discrete]
[[integer]]
=== integer

[source,ts,subs=+macros]
----
type integer = number
----


[discrete]
[[long]]
=== long

[source,ts,subs=+macros]
----
type long = number
----


[discrete]
[[short]]
=== short

[source,ts,subs=+macros]
----
type short = number
----


[discrete]
[[uint]]
=== uint

[source,ts,subs=+macros]
----
type uint = number
----


[discrete]
[[ulong]]
=== ulong

[source,ts,subs=+macros]
----
type ulong = number
----


[discrete]
[[SpecUtilsBaseNode]]
=== SpecUtilsBaseNode

[source,ts,subs=+macros]
----
interface SpecUtilsBaseNode {
  attributes: Record<string, string>
  host: <<Host>>
  ip: <<Ip>>
  name: <<Name>>
  roles?: <<NodeRoles>>
  transport_address: <<TransportAddress>>
}
----


[discrete]
[[SpecUtilsNullValue]]
=== SpecUtilsNullValue

[source,ts,subs=+macros]
----
type SpecUtilsNullValue = null
----


[discrete]
[[SpecUtilsPipeSeparatedFlags]]
=== SpecUtilsPipeSeparatedFlags

[source,ts,subs=+macros]
----
type SpecUtilsPipeSeparatedFlags<T = unknown> = T | string
----


[discrete]
[[SpecUtilsStringified]]
=== SpecUtilsStringified

[source,ts,subs=+macros]
----
type SpecUtilsStringified<T = unknown> = T | string
----


[discrete]
[[SpecUtilsVoid]]
=== SpecUtilsVoid

[source,ts,subs=+macros]
----

----


[discrete]
[[SpecUtilsWithNullValue]]
=== SpecUtilsWithNullValue

[source,ts,subs=+macros]
----
type SpecUtilsWithNullValue<T = unknown> = T | <<SpecUtilsNullValue>>
----


[discrete]
[[SpecUtilsAdditionalProperties]]
=== SpecUtilsAdditionalProperties

[source,ts,subs=+macros]
----
interface SpecUtilsAdditionalProperties<TKey = unknown, TValue = unknown> {}
----


[discrete]
[[SpecUtilsAdditionalProperty]]
=== SpecUtilsAdditionalProperty

[source,ts,subs=+macros]
----
interface SpecUtilsAdditionalProperty<TKey = unknown, TValue = unknown> {}
----


[discrete]
[[SpecUtilsCommonQueryParameters]]
=== SpecUtilsCommonQueryParameters

[source,ts,subs=+macros]
----
interface SpecUtilsCommonQueryParameters {
  pass:[/**] @property error_trace When set to `true` Elasticsearch will include the full stack trace of errors when they occur. */
  error_trace?: boolean
  pass:[/**] @property filter_path Comma-separated list of filters in dot notation which reduce the response returned by Elasticsearch. */
  filter_path?: string | string[]
  pass:[/**] @property human When set to `true` will return statistics in a format suitable for humans. For example `"exists_time": "1h"` for humans and `"eixsts_time_in_millis": 3600000` for computers. When disabled the human readable values will be omitted. This makes sense for responses being consumed only by machines. */
  human?: boolean
  pass:[/**] @property pretty If set to `true` the returned JSON will be "pretty-formatted". Only use this option for debugging only. */
  pretty?: boolean
}
----


[discrete]
[[SpecUtilsCommonCatQueryParameters]]
=== SpecUtilsCommonCatQueryParameters

[source,ts,subs=+macros]
----
interface SpecUtilsCommonCatQueryParameters {
  pass:[/**] @property format Specifies the format to return the columnar data in, can be set to `text`, `json`, `cbor`, `yaml`, or `smile`. */
  format?: string
  pass:[/**] @property h List of columns to appear in the response. Supports simple wildcards. */
  h?: <<Names>>
  pass:[/**] @property help When set to `true` will output available columns. This option can't be combined with any other query string option. */
  help?: boolean
  pass:[/**] @property local If `true`, the request computes the list of selected nodes from the local cluster state. If `false` the list of selected nodes are computed from the cluster state of the master node. In both cases the coordinating node will send requests for further information to each selected node. */
  local?: boolean
  pass:[/**] @property master_timeout Period to wait for a connection to the master node. */
  master_timeout?: <<Duration>>
  pass:[/**] @property s List of columns that determine how the table should be sorted. Sorting defaults to ascending and can be changed by setting `:asc` or `:desc` as a suffix to the column name. */
  s?: <<Names>>
  pass:[/**] @property v When set to `true` will enable verbose output. */
  v?: boolean
}
----


[discrete]
[[SpecUtilsOverloadOf]]
=== SpecUtilsOverloadOf

[source,ts,subs=+macros]
----
interface SpecUtilsOverloadOf<TDefinition = unknown> {}
----


[discrete]
[[AggregationsAdjacencyMatrixAggregate]]
=== AggregationsAdjacencyMatrixAggregate

[source,ts,subs=+macros]
----
interface AggregationsAdjacencyMatrixAggregate extends <<AggregationsMultiBucketAggregateBase>><<<AggregationsAdjacencyMatrixBucket>>> {}
----


[discrete]
[[AggregationsAdjacencyMatrixAggregation]]
=== AggregationsAdjacencyMatrixAggregation

[source,ts,subs=+macros]
----
interface AggregationsAdjacencyMatrixAggregation extends <<AggregationsBucketAggregationBase>> {
  pass:[/**] @property filters Filters used to create buckets. At least one filter is required. */
  filters?: Record<string, <<QueryDslQueryContainer>>>
  pass:[/**] @property separator Separator used to concatenate filter names. Defaults to &. */
  separator?: string
}
----


[discrete]
[[AggregationsAdjacencyMatrixBucket]]
=== AggregationsAdjacencyMatrixBucket

[source,ts,subs=+macros]
----
interface AggregationsAdjacencyMatrixBucketKeys extends <<AggregationsMultiBucketBase>> {
  key: string
}
type AggregationsAdjacencyMatrixBucket = AggregationsAdjacencyMatrixBucketKeys
  & { [property: string]: <<AggregationsAggregate>> | string | <<long>> }
----


[discrete]
[[AggregationsAggregate]]
=== AggregationsAggregate

[source,ts,subs=+macros]
----
type AggregationsAggregate = <<AggregationsCardinalityAggregate>> | <<AggregationsHdrPercentilesAggregate>> | <<AggregationsHdrPercentileRanksAggregate>> | <<AggregationsTDigestPercentilesAggregate>> | <<AggregationsTDigestPercentileRanksAggregate>> | <<AggregationsPercentilesBucketAggregate>> | <<AggregationsMedianAbsoluteDeviationAggregate>> | <<AggregationsMinAggregate>> | <<AggregationsMaxAggregate>> | <<AggregationsSumAggregate>> | <<AggregationsAvgAggregate>> | <<AggregationsWeightedAvgAggregate>> | <<AggregationsValueCountAggregate>> | <<AggregationsSimpleValueAggregate>> | <<AggregationsDerivativeAggregate>> | <<AggregationsBucketMetricValueAggregate>> | <<AggregationsStatsAggregate>> | <<AggregationsStatsBucketAggregate>> | <<AggregationsExtendedStatsAggregate>> | <<AggregationsExtendedStatsBucketAggregate>> | <<AggregationsGeoBoundsAggregate>> | <<AggregationsGeoCentroidAggregate>> | <<AggregationsHistogramAggregate>> | <<AggregationsDateHistogramAggregate>> | <<AggregationsAutoDateHistogramAggregate>> | <<AggregationsVariableWidthHistogramAggregate>> | <<AggregationsStringTermsAggregate>> | <<AggregationsLongTermsAggregate>> | <<AggregationsDoubleTermsAggregate>> | <<AggregationsUnmappedTermsAggregate>> | <<AggregationsLongRareTermsAggregate>> | <<AggregationsStringRareTermsAggregate>> | <<AggregationsUnmappedRareTermsAggregate>> | <<AggregationsMultiTermsAggregate>> | <<AggregationsMissingAggregate>> | <<AggregationsNestedAggregate>> | <<AggregationsReverseNestedAggregate>> | <<AggregationsGlobalAggregate>> | <<AggregationsFilterAggregate>> | <<AggregationsChildrenAggregate>> | <<AggregationsParentAggregate>> | <<AggregationsSamplerAggregate>> | <<AggregationsUnmappedSamplerAggregate>> | <<AggregationsGeoHashGridAggregate>> | <<AggregationsGeoTileGridAggregate>> | <<AggregationsGeoHexGridAggregate>> | <<AggregationsRangeAggregate>> | <<AggregationsDateRangeAggregate>> | <<AggregationsGeoDistanceAggregate>> | <<AggregationsIpRangeAggregate>> | <<AggregationsIpPrefixAggregate>> | <<AggregationsFiltersAggregate>> | <<AggregationsAdjacencyMatrixAggregate>> | <<AggregationsSignificantLongTermsAggregate>> | <<AggregationsSignificantStringTermsAggregate>> | <<AggregationsUnmappedSignificantTermsAggregate>> | <<AggregationsCompositeAggregate>> | <<AggregationsFrequentItemSetsAggregate>> | <<AggregationsTimeSeriesAggregate>> | <<AggregationsScriptedMetricAggregate>> | <<AggregationsTopHitsAggregate>> | <<AggregationsInferenceAggregate>> | <<AggregationsStringStatsAggregate>> | <<AggregationsBoxPlotAggregate>> | <<AggregationsTopMetricsAggregate>> | <<AggregationsTTestAggregate>> | <<AggregationsRateAggregate>> | <<AggregationsCumulativeCardinalityAggregate>> | <<AggregationsMatrixStatsAggregate>> | <<AggregationsGeoLineAggregate>>
----


[discrete]
[[AggregationsAggregateBase]]
=== AggregationsAggregateBase

[source,ts,subs=+macros]
----
interface AggregationsAggregateBase {
  meta?: <<Metadata>>
}
----


[discrete]
[[AggregationsAggregateOrder]]
=== AggregationsAggregateOrder

[source,ts,subs=+macros]
----
type AggregationsAggregateOrder = Partial<Record<<<Field>>, <<SortOrder>>>> | Partial<Record<<<Field>>, <<SortOrder>>>>[]
----


[discrete]
[[AggregationsAggregation]]
=== AggregationsAggregation

[source,ts,subs=+macros]
----
interface AggregationsAggregation {}
----


[discrete]
[[AggregationsAggregationContainer]]
=== AggregationsAggregationContainer

[source,ts,subs=+macros]
----
interface AggregationsAggregationContainer {
  pass:[/**] @property aggregations Sub-aggregations for this aggregation. Only applies to bucket aggregations. */
  aggregations?: Record<string, <<AggregationsAggregationContainer>>>
  pass:[/**] @property aggs Sub-aggregations for this aggregation. Only applies to bucket aggregations. */
  aggs?: Record<string, <<AggregationsAggregationContainer>>>
  meta?: <<Metadata>>
  pass:[/**] @property adjacency_matrix A bucket aggregation returning a form of adjacency matrix. The request provides a collection of named filter expressions, similar to the `filters` aggregation. Each bucket in the response represents a non-empty cell in the matrix of intersecting filters. */
  adjacency_matrix?: <<AggregationsAdjacencyMatrixAggregation>>
  pass:[/**] @property auto_date_histogram A multi-bucket aggregation similar to the date histogram, except instead of providing an interval to use as the width of each bucket, a target number of buckets is provided. */
  auto_date_histogram?: <<AggregationsAutoDateHistogramAggregation>>
  pass:[/**] @property avg A single-value metrics aggregation that computes the average of numeric values that are extracted from the aggregated documents. */
  avg?: <<AggregationsAverageAggregation>>
  pass:[/**] @property avg_bucket A sibling pipeline aggregation which calculates the mean value of a specified metric in a sibling aggregation. The specified metric must be numeric and the sibling aggregation must be a multi-bucket aggregation. */
  avg_bucket?: <<AggregationsAverageBucketAggregation>>
  pass:[/**] @property boxplot A metrics aggregation that computes a box plot of numeric values extracted from the aggregated documents. */
  boxplot?: <<AggregationsBoxplotAggregation>>
  pass:[/**] @property bucket_script A parent pipeline aggregation which runs a script which can perform per bucket computations on metrics in the parent multi-bucket aggregation. */
  bucket_script?: <<AggregationsBucketScriptAggregation>>
  pass:[/**] @property bucket_selector A parent pipeline aggregation which runs a script to determine whether the current bucket will be retained in the parent multi-bucket aggregation. */
  bucket_selector?: <<AggregationsBucketSelectorAggregation>>
  pass:[/**] @property bucket_sort A parent pipeline aggregation which sorts the buckets of its parent multi-bucket aggregation. */
  bucket_sort?: <<AggregationsBucketSortAggregation>>
  pass:[/**] @property bucket_count_ks_test A sibling pipeline aggregation which runs a two sample Kolmogorov–Smirnov test ("K-S test") against a provided distribution and the distribution implied by the documents counts in the configured sibling aggregation. */
  bucket_count_ks_test?: <<AggregationsBucketKsAggregation>>
  pass:[/**] @property bucket_correlation A sibling pipeline aggregation which runs a correlation function on the configured sibling multi-bucket aggregation. */
  bucket_correlation?: <<AggregationsBucketCorrelationAggregation>>
  pass:[/**] @property cardinality A single-value metrics aggregation that calculates an approximate count of distinct values. */
  cardinality?: <<AggregationsCardinalityAggregation>>
  pass:[/**] @property categorize_text A multi-bucket aggregation that groups semi-structured text into buckets. */
  categorize_text?: <<AggregationsCategorizeTextAggregation>>
  pass:[/**] @property children A single bucket aggregation that selects child documents that have the specified type, as defined in a `join` field. */
  children?: <<AggregationsChildrenAggregation>>
  pass:[/**] @property composite A multi-bucket aggregation that creates composite buckets from different sources. Unlike the other multi-bucket aggregations, you can use the `composite` aggregation to paginate *all* buckets from a multi-level aggregation efficiently. */
  composite?: <<AggregationsCompositeAggregation>>
  pass:[/**] @property cumulative_cardinality A parent pipeline aggregation which calculates the cumulative cardinality in a parent `histogram` or `date_histogram` aggregation. */
  cumulative_cardinality?: <<AggregationsCumulativeCardinalityAggregation>>
  pass:[/**] @property cumulative_sum A parent pipeline aggregation which calculates the cumulative sum of a specified metric in a parent `histogram` or `date_histogram` aggregation. */
  cumulative_sum?: <<AggregationsCumulativeSumAggregation>>
  pass:[/**] @property date_histogram A multi-bucket values source based aggregation that can be applied on date values or date range values extracted from the documents. It dynamically builds fixed size (interval) buckets over the values. */
  date_histogram?: <<AggregationsDateHistogramAggregation>>
  pass:[/**] @property date_range A multi-bucket value source based aggregation that enables the user to define a set of date ranges - each representing a bucket. */
  date_range?: <<AggregationsDateRangeAggregation>>
  pass:[/**] @property derivative A parent pipeline aggregation which calculates the derivative of a specified metric in a parent `histogram` or `date_histogram` aggregation. */
  derivative?: <<AggregationsDerivativeAggregation>>
  pass:[/**] @property diversified_sampler A filtering aggregation used to limit any sub aggregations' processing to a sample of the top-scoring documents. Similar to the `sampler` aggregation, but adds the ability to limit the number of matches that share a common value. */
  diversified_sampler?: <<AggregationsDiversifiedSamplerAggregation>>
  pass:[/**] @property extended_stats A multi-value metrics aggregation that computes stats over numeric values extracted from the aggregated documents. */
  extended_stats?: <<AggregationsExtendedStatsAggregation>>
  pass:[/**] @property extended_stats_bucket A sibling pipeline aggregation which calculates a variety of stats across all bucket of a specified metric in a sibling aggregation. */
  extended_stats_bucket?: <<AggregationsExtendedStatsBucketAggregation>>
  pass:[/**] @property frequent_item_sets A bucket aggregation which finds frequent item sets, a form of association rules mining that identifies items that often occur together. */
  frequent_item_sets?: <<AggregationsFrequentItemSetsAggregation>>
  pass:[/**] @property filter A single bucket aggregation that narrows the set of documents to those that match a query. */
  filter?: <<QueryDslQueryContainer>>
  pass:[/**] @property filters A multi-bucket aggregation where each bucket contains the documents that match a query. */
  filters?: <<AggregationsFiltersAggregation>>
  pass:[/**] @property geo_bounds A metric aggregation that computes the geographic bounding box containing all values for a Geopoint or Geoshape field. */
  geo_bounds?: <<AggregationsGeoBoundsAggregation>>
  pass:[/**] @property geo_centroid A metric aggregation that computes the weighted centroid from all coordinate values for geo fields. */
  geo_centroid?: <<AggregationsGeoCentroidAggregation>>
  pass:[/**] @property geo_distance A multi-bucket aggregation that works on `geo_point` fields. Evaluates the distance of each document value from an origin point and determines the buckets it belongs to, based on ranges defined in the request. */
  geo_distance?: <<AggregationsGeoDistanceAggregation>>
  pass:[/**] @property geohash_grid A multi-bucket aggregation that groups `geo_point` and `geo_shape` values into buckets that represent a grid. Each cell is labeled using a geohash which is of user-definable precision. */
  geohash_grid?: <<AggregationsGeoHashGridAggregation>>
  pass:[/**] @property geo_line Aggregates all `geo_point` values within a bucket into a `LineString` ordered by the chosen sort field. */
  geo_line?: <<AggregationsGeoLineAggregation>>
  pass:[/**] @property geotile_grid A multi-bucket aggregation that groups `geo_point` and `geo_shape` values into buckets that represent a grid. Each cell corresponds to a map tile as used by many online map sites. */
  geotile_grid?: <<AggregationsGeoTileGridAggregation>>
  pass:[/**] @property geohex_grid A multi-bucket aggregation that groups `geo_point` and `geo_shape` values into buckets that represent a grid. Each cell corresponds to a H3 cell index and is labeled using the H3Index representation. */
  geohex_grid?: <<AggregationsGeohexGridAggregation>>
  pass:[/**] @property global Defines a single bucket of all the documents within the search execution context. This context is defined by the indices and the document types you’re searching on, but is not influenced by the search query itself. */
  global?: <<AggregationsGlobalAggregation>>
  pass:[/**] @property histogram A multi-bucket values source based aggregation that can be applied on numeric values or numeric range values extracted from the documents. It dynamically builds fixed size (interval) buckets over the values. */
  histogram?: <<AggregationsHistogramAggregation>>
  pass:[/**] @property ip_range A multi-bucket value source based aggregation that enables the user to define a set of IP ranges - each representing a bucket. */
  ip_range?: <<AggregationsIpRangeAggregation>>
  pass:[/**] @property ip_prefix A bucket aggregation that groups documents based on the network or sub-network of an IP address. */
  ip_prefix?: <<AggregationsIpPrefixAggregation>>
  pass:[/**] @property inference A parent pipeline aggregation which loads a pre-trained model and performs inference on the collated result fields from the parent bucket aggregation. */
  inference?: <<AggregationsInferenceAggregation>>
  line?: <<AggregationsGeoLineAggregation>>
  pass:[/**] @property matrix_stats A numeric aggregation that computes the following statistics over a set of document fields: `count`, `mean`, `variance`, `skewness`, `kurtosis`, `covariance`, and `covariance`. */
  matrix_stats?: <<AggregationsMatrixStatsAggregation>>
  pass:[/**] @property max A single-value metrics aggregation that returns the maximum value among the numeric values extracted from the aggregated documents. */
  max?: <<AggregationsMaxAggregation>>
  pass:[/**] @property max_bucket A sibling pipeline aggregation which identifies the bucket(s) with the maximum value of a specified metric in a sibling aggregation and outputs both the value and the key(s) of the bucket(s). */
  max_bucket?: <<AggregationsMaxBucketAggregation>>
  pass:[/**] @property median_absolute_deviation A single-value aggregation that approximates the median absolute deviation of its search results. */
  median_absolute_deviation?: <<AggregationsMedianAbsoluteDeviationAggregation>>
  pass:[/**] @property min A single-value metrics aggregation that returns the minimum value among numeric values extracted from the aggregated documents. */
  min?: <<AggregationsMinAggregation>>
  pass:[/**] @property min_bucket A sibling pipeline aggregation which identifies the bucket(s) with the minimum value of a specified metric in a sibling aggregation and outputs both the value and the key(s) of the bucket(s). */
  min_bucket?: <<AggregationsMinBucketAggregation>>
  pass:[/**] @property missing A field data based single bucket aggregation, that creates a bucket of all documents in the current document set context that are missing a field value (effectively, missing a field or having the configured NULL value set). */
  missing?: <<AggregationsMissingAggregation>>
  moving_avg?: <<AggregationsMovingAverageAggregation>>
  pass:[/**] @property moving_percentiles Given an ordered series of percentiles, "slides" a window across those percentiles and computes cumulative percentiles. */
  moving_percentiles?: <<AggregationsMovingPercentilesAggregation>>
  pass:[/**] @property moving_fn Given an ordered series of data, "slides" a window across the data and runs a custom script on each window of data. For convenience, a number of common functions are predefined such as `min`, `max`, and moving averages. */
  moving_fn?: <<AggregationsMovingFunctionAggregation>>
  pass:[/**] @property multi_terms A multi-bucket value source based aggregation where buckets are dynamically built - one per unique set of values. */
  multi_terms?: <<AggregationsMultiTermsAggregation>>
  pass:[/**] @property nested A special single bucket aggregation that enables aggregating nested documents. */
  nested?: <<AggregationsNestedAggregation>>
  pass:[/**] @property normalize A parent pipeline aggregation which calculates the specific normalized/rescaled value for a specific bucket value. */
  normalize?: <<AggregationsNormalizeAggregation>>
  pass:[/**] @property parent A special single bucket aggregation that selects parent documents that have the specified type, as defined in a `join` field. */
  parent?: <<AggregationsParentAggregation>>
  pass:[/**] @property percentile_ranks A multi-value metrics aggregation that calculates one or more percentile ranks over numeric values extracted from the aggregated documents. */
  percentile_ranks?: <<AggregationsPercentileRanksAggregation>>
  pass:[/**] @property percentiles A multi-value metrics aggregation that calculates one or more percentiles over numeric values extracted from the aggregated documents. */
  percentiles?: <<AggregationsPercentilesAggregation>>
  pass:[/**] @property percentiles_bucket A sibling pipeline aggregation which calculates percentiles across all bucket of a specified metric in a sibling aggregation. */
  percentiles_bucket?: <<AggregationsPercentilesBucketAggregation>>
  pass:[/**] @property range A multi-bucket value source based aggregation that enables the user to define a set of ranges - each representing a bucket. */
  range?: <<AggregationsRangeAggregation>>
  pass:[/**] @property rare_terms A multi-bucket value source based aggregation which finds "rare" terms — terms that are at the <<long>>-tail of the distribution and are not frequent. */
  rare_terms?: <<AggregationsRareTermsAggregation>>
  pass:[/**] @property rate Calculates a rate of documents or a field in each bucket. Can only be used inside a `date_histogram` or `composite` aggregation. */
  rate?: <<AggregationsRateAggregation>>
  pass:[/**] @property reverse_nested A special single bucket aggregation that enables aggregating on parent documents from nested documents. Should only be defined inside a `nested` aggregation. */
  reverse_nested?: <<AggregationsReverseNestedAggregation>>
  pass:[/**] @property random_sampler A single bucket aggregation that randomly includes documents in the aggregated results. Sampling provides significant speed improvement at the cost of accuracy. */
  random_sampler?: <<AggregationsRandomSamplerAggregation>>
  pass:[/**] @property sampler A filtering aggregation used to limit any sub aggregations' processing to a sample of the top-scoring documents. */
  sampler?: <<AggregationsSamplerAggregation>>
  pass:[/**] @property scripted_metric A metric aggregation that uses scripts to provide a metric output. */
  scripted_metric?: <<AggregationsScriptedMetricAggregation>>
  pass:[/**] @property serial_diff An aggregation that subtracts values in a time series from themselves at different time lags or periods. */
  serial_diff?: <<AggregationsSerialDifferencingAggregation>>
  pass:[/**] @property significant_terms Returns interesting or unusual occurrences of terms in a set. */
  significant_terms?: <<AggregationsSignificantTermsAggregation>>
  pass:[/**] @property significant_text Returns interesting or unusual occurrences of free-text terms in a set. */
  significant_text?: <<AggregationsSignificantTextAggregation>>
  pass:[/**] @property stats A multi-value metrics aggregation that computes stats over numeric values extracted from the aggregated documents. */
  stats?: <<AggregationsStatsAggregation>>
  pass:[/**] @property stats_bucket A sibling pipeline aggregation which calculates a variety of stats across all bucket of a specified metric in a sibling aggregation. */
  stats_bucket?: <<AggregationsStatsBucketAggregation>>
  pass:[/**] @property string_stats A multi-value metrics aggregation that computes statistics over string values extracted from the aggregated documents. */
  string_stats?: <<AggregationsStringStatsAggregation>>
  pass:[/**] @property sum A single-value metrics aggregation that sums numeric values that are extracted from the aggregated documents. */
  sum?: <<AggregationsSumAggregation>>
  pass:[/**] @property sum_bucket A sibling pipeline aggregation which calculates the sum of a specified metric across all buckets in a sibling aggregation. */
  sum_bucket?: <<AggregationsSumBucketAggregation>>
  pass:[/**] @property terms A multi-bucket value source based aggregation where buckets are dynamically built - one per unique value. */
  terms?: <<AggregationsTermsAggregation>>
  pass:[/**] @property time_series The time series aggregation queries data created using a time series index. This is typically data such as metrics or other data streams with a time component, and requires creating an index using the time series mode. */
  time_series?: <<AggregationsTimeSeriesAggregation>>
  pass:[/**] @property top_hits A metric aggregation that returns the top matching documents per bucket. */
  top_hits?: <<AggregationsTopHitsAggregation>>
  pass:[/**] @property t_test A metrics aggregation that performs a statistical hypothesis test in which the test statistic follows a Student’s t-distribution under the null hypothesis on numeric values extracted from the aggregated documents. */
  t_test?: <<AggregationsTTestAggregation>>
  pass:[/**] @property top_metrics A metric aggregation that selects metrics from the document with the largest or smallest sort value. */
  top_metrics?: <<AggregationsTopMetricsAggregation>>
  pass:[/**] @property value_count A single-value metrics aggregation that counts the number of values that are extracted from the aggregated documents. */
  value_count?: <<AggregationsValueCountAggregation>>
  pass:[/**] @property weighted_avg A single-value metrics aggregation that computes the weighted average of numeric values that are extracted from the aggregated documents. */
  weighted_avg?: <<AggregationsWeightedAverageAggregation>>
  pass:[/**] @property variable_width_histogram A multi-bucket aggregation similar to the histogram, except instead of providing an interval to use as the width of each bucket, a target number of buckets is provided. */
  variable_width_histogram?: <<AggregationsVariableWidthHistogramAggregation>>
}
----


[discrete]
[[AggregationsAggregationRange]]
=== AggregationsAggregationRange

[source,ts,subs=+macros]
----
interface AggregationsAggregationRange {
  pass:[/**] @property from Start of the range (inclusive). */
  from?: <<double>> | null
  pass:[/**] @property key Custom key to return the range with. */
  key?: string
  pass:[/**] @property to End of the range (exclusive). */
  to?: <<double>> | null
}
----


[discrete]
[[AggregationsArrayPercentilesItem]]
=== AggregationsArrayPercentilesItem

[source,ts,subs=+macros]
----
interface AggregationsArrayPercentilesItem {
  key: string
  value: <<double>> | null
  value_as_string?: string
}
----


[discrete]
[[AggregationsAutoDateHistogramAggregate]]
=== AggregationsAutoDateHistogramAggregate

[source,ts,subs=+macros]
----
interface AggregationsAutoDateHistogramAggregate extends <<AggregationsMultiBucketAggregateBase>><<<AggregationsDateHistogramBucket>>> {
  interval: <<DurationLarge>>
}
----


[discrete]
[[AggregationsAutoDateHistogramAggregation]]
=== AggregationsAutoDateHistogramAggregation

[source,ts,subs=+macros]
----
interface AggregationsAutoDateHistogramAggregation extends <<AggregationsBucketAggregationBase>> {
  pass:[/**] @property buckets The target number of buckets. */
  buckets?: <<integer>>
  pass:[/**] @property field The field on which to run the aggregation. */
  field?: <<Field>>
  pass:[/**] @property format The date format used to format `key_as_string` in the response. If no `format` is specified, the first date format specified in the field mapping is used. */
  format?: string
  pass:[/**] @property minimum_interval The minimum rounding interval. This can make the collection process more efficient, as the aggregation will not attempt to round at any interval lower than `minimum_interval`. */
  minimum_interval?: <<AggregationsMinimumInterval>>
  pass:[/**] @property missing The value to apply to documents that do not have a value. By default, documents without a value are ignored. */
  missing?: <<DateTime>>
  pass:[/**] @property offset Time zone specified as a ISO 8601 UTC offset. */
  offset?: string
  params?: Record<string, any>
  script?: <<Script>> | string
  pass:[/**] @property time_zone Time zone ID. */
  time_zone?: <<TimeZone>>
}
----


[discrete]
[[AggregationsAverageAggregation]]
=== AggregationsAverageAggregation

[source,ts,subs=+macros]
----
interface AggregationsAverageAggregation extends <<AggregationsFormatMetricAggregationBase>> {}
----


[discrete]
[[AggregationsAverageBucketAggregation]]
=== AggregationsAverageBucketAggregation

[source,ts,subs=+macros]
----
interface AggregationsAverageBucketAggregation extends <<AggregationsPipelineAggregationBase>> {}
----


[discrete]
[[AggregationsAvgAggregate]]
=== AggregationsAvgAggregate

[source,ts,subs=+macros]
----
interface AggregationsAvgAggregate extends <<AggregationsSingleMetricAggregateBase>> {}
----


[discrete]
[[AggregationsBoxPlotAggregate]]
=== AggregationsBoxPlotAggregate

[source,ts,subs=+macros]
----
interface AggregationsBoxPlotAggregate extends <<AggregationsAggregateBase>> {
  min: <<double>>
  max: <<double>>
  q1: <<double>>
  q2: <<double>>
  q3: <<double>>
  lower: <<double>>
  upper: <<double>>
  min_as_string?: string
  max_as_string?: string
  q1_as_string?: string
  q2_as_string?: string
  q3_as_string?: string
  lower_as_string?: string
  upper_as_string?: string
}
----


[discrete]
[[AggregationsBoxplotAggregation]]
=== AggregationsBoxplotAggregation

[source,ts,subs=+macros]
----
interface AggregationsBoxplotAggregation extends <<AggregationsMetricAggregationBase>> {
  pass:[/**] @property compression Limits the maximum number of nodes used by the underlying TDigest algorithm to `20 * compression`, enabling control of memory usage and approximation error. */
  compression?: <<double>>
}
----


[discrete]
[[AggregationsBucketAggregationBase]]
=== AggregationsBucketAggregationBase

[source,ts,subs=+macros]
----
interface AggregationsBucketAggregationBase {}
----


[discrete]
[[AggregationsBucketCorrelationAggregation]]
=== AggregationsBucketCorrelationAggregation

[source,ts,subs=+macros]
----
interface AggregationsBucketCorrelationAggregation extends <<AggregationsBucketPathAggregation>> {
  pass:[/**] @property function The correlation function to execute. */
  function: <<AggregationsBucketCorrelationFunction>>
}
----


[discrete]
[[AggregationsBucketCorrelationFunction]]
=== AggregationsBucketCorrelationFunction

[source,ts,subs=+macros]
----
interface AggregationsBucketCorrelationFunction {
  pass:[/**] @property count_correlation The configuration to calculate a count correlation. This function is designed for determining the correlation of a term value and a given metric. */
  count_correlation: <<AggregationsBucketCorrelationFunctionCountCorrelation>>
}
----


[discrete]
[[AggregationsBucketCorrelationFunctionCountCorrelation]]
=== AggregationsBucketCorrelationFunctionCountCorrelation

[source,ts,subs=+macros]
----
interface AggregationsBucketCorrelationFunctionCountCorrelation {
  pass:[/**] @property indicator The indicator with which to correlate the configured `bucket_path` values. */
  indicator: <<AggregationsBucketCorrelationFunctionCountCorrelationIndicator>>
}
----


[discrete]
[[AggregationsBucketCorrelationFunctionCountCorrelationIndicator]]
=== AggregationsBucketCorrelationFunctionCountCorrelationIndicator

[source,ts,subs=+macros]
----
interface AggregationsBucketCorrelationFunctionCountCorrelationIndicator {
  pass:[/**] @property doc_count The total number of documents that initially created the expectations. It’s required to be greater than or equal to the sum of all values in the buckets_path as this is the originating superset of data to which the term values are correlated. */
  doc_count: <<integer>>
  pass:[/**] @property expectations An array of numbers with which to correlate the configured `bucket_path` values. The length of this value must always equal the number of buckets returned by the `bucket_path`. */
  expectations: <<double>>[]
  pass:[/**] @property fractions An array of fractions to use when averaging and calculating variance. This should be used if the pre-calculated data and the buckets_path have known gaps. The length of fractions, if provided, must equal expectations. */
  fractions?: <<double>>[]
}
----


[discrete]
[[AggregationsBucketKsAggregation]]
=== AggregationsBucketKsAggregation

[source,ts,subs=+macros]
----
interface AggregationsBucketKsAggregation extends <<AggregationsBucketPathAggregation>> {
  pass:[/**] @property alternative A list of string values indicating which K-S test alternative to calculate. The valid values are: "greater", "less", "two_sided". This parameter is key for determining the K-S statistic used when calculating the K-S test. Default value is all possible alternative hypotheses. */
  alternative?: string[]
  pass:[/**] @property fractions A list of doubles indicating the distribution of the samples with which to compare to the `buckets_path` results. In typical usage this is the overall proportion of documents in each bucket, which is compared with the actual document proportions in each bucket from the sibling aggregation counts. The default is to assume that overall documents are uniformly distributed on these buckets, which they would be if one used equal percentiles of a metric to define the bucket end points. */
  fractions?: <<double>>[]
  pass:[/**] @property sampling_method Indicates the sampling methodology when calculating the K-S test. Note, this is sampling of the returned values. This determines the cumulative distribution function (CDF) points used comparing the two samples. Default is `upper_tail`, which emphasizes the upper end of the CDF points. Valid options are: `upper_tail`, `uniform`, and `lower_tail`. */
  sampling_method?: string
}
----


[discrete]
[[AggregationsBucketMetricValueAggregate]]
=== AggregationsBucketMetricValueAggregate

[source,ts,subs=+macros]
----
interface AggregationsBucketMetricValueAggregate extends <<AggregationsSingleMetricAggregateBase>> {
  keys: string[]
}
----


[discrete]
[[AggregationsBucketPathAggregation]]
=== AggregationsBucketPathAggregation

[source,ts,subs=+macros]
----
interface AggregationsBucketPathAggregation {
  pass:[/**] @property buckets_path Path to the buckets that contain one set of values to correlate. */
  buckets_path?: <<AggregationsBucketsPath>>
}
----


[discrete]
[[AggregationsBucketScriptAggregation]]
=== AggregationsBucketScriptAggregation

[source,ts,subs=+macros]
----
interface AggregationsBucketScriptAggregation extends <<AggregationsPipelineAggregationBase>> {
  pass:[/**] @property script The script to run for this aggregation. */
  script?: <<Script>> | string
}
----


[discrete]
[[AggregationsBucketSelectorAggregation]]
=== AggregationsBucketSelectorAggregation

[source,ts,subs=+macros]
----
interface AggregationsBucketSelectorAggregation extends <<AggregationsPipelineAggregationBase>> {
  pass:[/**] @property script The script to run for this aggregation. */
  script?: <<Script>> | string
}
----


[discrete]
[[AggregationsBucketSortAggregation]]
=== AggregationsBucketSortAggregation

[source,ts,subs=+macros]
----
interface AggregationsBucketSortAggregation {
  pass:[/**] @property from Buckets in positions prior to `from` will be truncated. */
  from?: <<integer>>
  pass:[/**] @property gap_policy The policy to apply when gaps are found in the data. */
  gap_policy?: <<AggregationsGapPolicy>>
  pass:[/**] @property size The number of buckets to return. Defaults to all buckets of the parent aggregation. */
  size?: <<integer>>
  pass:[/**] @property sort The list of fields to sort on. */
  sort?: <<Sort>>
}
----


[discrete]
[[AggregationsBuckets]]
=== AggregationsBuckets

[source,ts,subs=+macros]
----
type AggregationsBuckets<TBucket = unknown> = Record<string, TBucket> | TBucket[]
----


[discrete]
[[AggregationsBucketsPath]]
=== AggregationsBucketsPath

[source,ts,subs=+macros]
----
type AggregationsBucketsPath = string | string[] | Record<string, string>
----


[discrete]
[[AggregationsCalendarInterval]]
=== AggregationsCalendarInterval

[source,ts,subs=+macros]
----
type AggregationsCalendarInterval = 'second' | '1s' | 'minute' | '1m' | 'hour' | '1h' | 'day' | '1d' | 'week' | '1w' | 'month' | '1M' | 'quarter' | '1q' | 'year' | '1y'
----


[discrete]
[[AggregationsCardinalityAggregate]]
=== AggregationsCardinalityAggregate

[source,ts,subs=+macros]
----
interface AggregationsCardinalityAggregate extends <<AggregationsAggregateBase>> {
  value: <<long>>
}
----


[discrete]
[[AggregationsCardinalityAggregation]]
=== AggregationsCardinalityAggregation

[source,ts,subs=+macros]
----
interface AggregationsCardinalityAggregation extends <<AggregationsMetricAggregationBase>> {
  pass:[/**] @property precision_threshold A unique count below which counts are expected to be close to accurate. This allows to trade memory for accuracy. */
  precision_threshold?: <<integer>>
  rehash?: boolean
  pass:[/**] @property execution_hint Mechanism by which cardinality aggregations is run. */
  execution_hint?: <<AggregationsCardinalityExecutionMode>>
}
----


[discrete]
[[AggregationsCardinalityExecutionMode]]
=== AggregationsCardinalityExecutionMode

[source,ts,subs=+macros]
----
type AggregationsCardinalityExecutionMode = 'global_ordinals' | 'segment_ordinals' | 'direct' | 'save_memory_heuristic' | 'save_time_heuristic'
----


[discrete]
[[AggregationsCategorizeTextAggregation]]
=== AggregationsCategorizeTextAggregation

[source,ts,subs=+macros]
----
interface AggregationsCategorizeTextAggregation {
  pass:[/**] @property field The semi-structured text field to categorize. */
  field: <<Field>>
  pass:[/**] @property max_unique_tokens The maximum number of unique tokens at any position up to max_matched_tokens. Must be larger than 1. Smaller values use less memory and create fewer categories. Larger values will use more memory and create narrower categories. Max allowed value is 100. */
  max_unique_tokens?: <<integer>>
  pass:[/**] @property max_matched_tokens The maximum number of token positions to match on before attempting to merge categories. Larger values will use more memory and create narrower categories. Max allowed value is 100. */
  max_matched_tokens?: <<integer>>
  pass:[/**] @property similarity_threshold The minimum percentage of tokens that must match for text to be added to the category bucket. Must be between 1 and 100. The larger the value the narrower the categories. Larger values will increase memory usage and create narrower categories. */
  similarity_threshold?: <<integer>>
  pass:[/**] @property categorization_filters This property expects an array of regular expressions. The expressions are used to filter out matching sequences from the categorization field values. You can use this functionality to fine tune the categorization by excluding sequences from consideration when categories are defined. For example, you can exclude SQL statements that appear in your log files. This property cannot be used at the same time as categorization_analyzer. If you only want to define simple regular expression filters that are applied prior to tokenization, setting this property is the easiest method. If you also want to customize the tokenizer or post-tokenization filtering, use the categorization_analyzer property instead and include the filters as pattern_replace character filters. */
  categorization_filters?: string[]
  pass:[/**] @property categorization_analyzer The categorization analyzer specifies how the text is analyzed and tokenized before being categorized. The syntax is very similar to that used to define the analyzer in the [Analyze endpoint](https://www.elastic.co/guide/en/elasticsearch/reference/8.0/indices-analyze.html). This property cannot be used at the same time as categorization_filters. */
  categorization_analyzer?: <<AggregationsCategorizeTextAnalyzer>>
  pass:[/**] @property shard_size The number of categorization buckets to return from each shard before merging all the results. */
  shard_size?: <<integer>>
  pass:[/**] @property size The number of buckets to return. */
  size?: <<integer>>
  pass:[/**] @property min_doc_count The minimum number of documents in a bucket to be returned to the results. */
  min_doc_count?: <<integer>>
  pass:[/**] @property shard_min_doc_count The minimum number of documents in a bucket to be returned from the shard before merging. */
  shard_min_doc_count?: <<integer>>
}
----


[discrete]
[[AggregationsCategorizeTextAnalyzer]]
=== AggregationsCategorizeTextAnalyzer

[source,ts,subs=+macros]
----
type AggregationsCategorizeTextAnalyzer = string | <<AggregationsCustomCategorizeTextAnalyzer>>
----


[discrete]
[[AggregationsChiSquareHeuristic]]
=== AggregationsChiSquareHeuristic

[source,ts,subs=+macros]
----
interface AggregationsChiSquareHeuristic {
  pass:[/**] @property background_is_superset Set to `false` if you defined a custom background filter that represents a different set of documents that you want to compare to. */
  background_is_superset: boolean
  pass:[/**] @property include_negatives Set to `false` to filter out the terms that appear less often in the subset than in documents outside the subset. */
  include_negatives: boolean
}
----


[discrete]
[[AggregationsChildrenAggregate]]
=== AggregationsChildrenAggregate

[source,ts,subs=+macros]
----
interface AggregationsChildrenAggregateKeys extends <<AggregationsSingleBucketAggregateBase>> {}
type AggregationsChildrenAggregate = AggregationsChildrenAggregateKeys
  & { [property: string]: <<AggregationsAggregate>> | <<long>> | <<Metadata>> }
----


[discrete]
[[AggregationsChildrenAggregation]]
=== AggregationsChildrenAggregation

[source,ts,subs=+macros]
----
interface AggregationsChildrenAggregation extends <<AggregationsBucketAggregationBase>> {
  pass:[/**] @property type The child type that should be selected. */
  type?: <<RelationName>>
}
----


[discrete]
[[AggregationsCompositeAggregate]]
=== AggregationsCompositeAggregate

[source,ts,subs=+macros]
----
interface AggregationsCompositeAggregate extends <<AggregationsMultiBucketAggregateBase>><<<AggregationsCompositeBucket>>> {
  after_key?: <<AggregationsCompositeAggregateKey>>
}
----


[discrete]
[[AggregationsCompositeAggregateKey]]
=== AggregationsCompositeAggregateKey

[source,ts,subs=+macros]
----
type AggregationsCompositeAggregateKey = Record<<<Field>>, <<FieldValue>>>
----


[discrete]
[[AggregationsCompositeAggregation]]
=== AggregationsCompositeAggregation

[source,ts,subs=+macros]
----
interface AggregationsCompositeAggregation extends <<AggregationsBucketAggregationBase>> {
  pass:[/**] @property after When paginating, use the `after_key` value returned in the previous response to retrieve the next page. */
  after?: <<AggregationsCompositeAggregateKey>>
  pass:[/**] @property size The number of composite buckets that should be returned. */
  size?: <<integer>>
  pass:[/**] @property sources The value sources used to build composite buckets. Keys are returned in the order of the `sources` definition. */
  sources?: Record<string, <<AggregationsCompositeAggregationSource>>>[]
}
----


[discrete]
[[AggregationsCompositeAggregationBase]]
=== AggregationsCompositeAggregationBase

[source,ts,subs=+macros]
----
interface AggregationsCompositeAggregationBase {
  pass:[/**] @property field Either `field` or `script` must be present */
  field?: <<Field>>
  missing_bucket?: boolean
  missing_order?: <<AggregationsMissingOrder>>
  pass:[/**] @property script Either `field` or `script` must be present */
  script?: <<Script>> | string
  value_type?: <<AggregationsValueType>>
  order?: <<SortOrder>>
}
----


[discrete]
[[AggregationsCompositeAggregationSource]]
=== AggregationsCompositeAggregationSource

[source,ts,subs=+macros]
----
interface AggregationsCompositeAggregationSource {
  pass:[/**] @property terms A terms aggregation. */
  terms?: <<AggregationsCompositeTermsAggregation>>
  pass:[/**] @property histogram A histogram aggregation. */
  histogram?: <<AggregationsCompositeHistogramAggregation>>
  pass:[/**] @property date_histogram A date histogram aggregation. */
  date_histogram?: <<AggregationsCompositeDateHistogramAggregation>>
  pass:[/**] @property geotile_grid A geotile grid aggregation. */
  geotile_grid?: <<AggregationsCompositeGeoTileGridAggregation>>
}
----


[discrete]
[[AggregationsCompositeBucket]]
=== AggregationsCompositeBucket

[source,ts,subs=+macros]
----
interface AggregationsCompositeBucketKeys extends <<AggregationsMultiBucketBase>> {
  key: <<AggregationsCompositeAggregateKey>>
}
type AggregationsCompositeBucket = AggregationsCompositeBucketKeys
  & { [property: string]: <<AggregationsAggregate>> | <<AggregationsCompositeAggregateKey>> | <<long>> }
----


[discrete]
[[AggregationsCompositeDateHistogramAggregation]]
=== AggregationsCompositeDateHistogramAggregation

[source,ts,subs=+macros]
----
interface AggregationsCompositeDateHistogramAggregation extends <<AggregationsCompositeAggregationBase>> {
  format?: string
  pass:[/**] @property calendar_interval Either `calendar_interval` or `fixed_interval` must be present */
  calendar_interval?: <<DurationLarge>>
  pass:[/**] @property fixed_interval Either `calendar_interval` or `fixed_interval` must be present */
  fixed_interval?: <<DurationLarge>>
  offset?: <<Duration>>
  time_zone?: <<TimeZone>>
}
----


[discrete]
[[AggregationsCompositeGeoTileGridAggregation]]
=== AggregationsCompositeGeoTileGridAggregation

[source,ts,subs=+macros]
----
interface AggregationsCompositeGeoTileGridAggregation extends <<AggregationsCompositeAggregationBase>> {
  precision?: <<integer>>
  bounds?: <<GeoBounds>>
}
----


[discrete]
[[AggregationsCompositeHistogramAggregation]]
=== AggregationsCompositeHistogramAggregation

[source,ts,subs=+macros]
----
interface AggregationsCompositeHistogramAggregation extends <<AggregationsCompositeAggregationBase>> {
  interval: <<double>>
}
----


[discrete]
[[AggregationsCompositeTermsAggregation]]
=== AggregationsCompositeTermsAggregation

[source,ts,subs=+macros]
----
interface AggregationsCompositeTermsAggregation extends <<AggregationsCompositeAggregationBase>> {}
----


[discrete]
[[AggregationsCumulativeCardinalityAggregate]]
=== AggregationsCumulativeCardinalityAggregate

[source,ts,subs=+macros]
----
interface AggregationsCumulativeCardinalityAggregate extends <<AggregationsAggregateBase>> {
  value: <<long>>
  value_as_string?: string
}
----


[discrete]
[[AggregationsCumulativeCardinalityAggregation]]
=== AggregationsCumulativeCardinalityAggregation

[source,ts,subs=+macros]
----
interface AggregationsCumulativeCardinalityAggregation extends <<AggregationsPipelineAggregationBase>> {}
----


[discrete]
[[AggregationsCumulativeSumAggregation]]
=== AggregationsCumulativeSumAggregation

[source,ts,subs=+macros]
----
interface AggregationsCumulativeSumAggregation extends <<AggregationsPipelineAggregationBase>> {}
----


[discrete]
[[AggregationsCustomCategorizeTextAnalyzer]]
=== AggregationsCustomCategorizeTextAnalyzer

[source,ts,subs=+macros]
----
interface AggregationsCustomCategorizeTextAnalyzer {
  char_filter?: string[]
  tokenizer?: string
  filter?: string[]
}
----


[discrete]
[[AggregationsDateHistogramAggregate]]
=== AggregationsDateHistogramAggregate

[source,ts,subs=+macros]
----
interface AggregationsDateHistogramAggregate extends <<AggregationsMultiBucketAggregateBase>><<<AggregationsDateHistogramBucket>>> {}
----


[discrete]
[[AggregationsDateHistogramAggregation]]
=== AggregationsDateHistogramAggregation

[source,ts,subs=+macros]
----
interface AggregationsDateHistogramAggregation extends <<AggregationsBucketAggregationBase>> {
  pass:[/**] @property calendar_interval Calendar-aware interval. Can be specified using the unit name, such as `month`, or as a single unit quantity, such as `1M`. */
  calendar_interval?: <<AggregationsCalendarInterval>>
  pass:[/**] @property extended_bounds Enables extending the bounds of the histogram beyond the data itself. */
  extended_bounds?: <<AggregationsExtendedBounds>><<<AggregationsFieldDateMath>>>
  pass:[/**] @property hard_bounds Limits the histogram to specified bounds. */
  hard_bounds?: <<AggregationsExtendedBounds>><<<AggregationsFieldDateMath>>>
  pass:[/**] @property field The date field whose values are use to build a histogram. */
  field?: <<Field>>
  pass:[/**] @property fixed_interval Fixed intervals: a fixed number of SI units and never deviate, regardless of where they fall on the calendar. */
  fixed_interval?: <<Duration>>
  pass:[/**] @property format The date format used to format `key_as_string` in the response. If no `format` is specified, the first date format specified in the field mapping is used. */
  format?: string
  interval?: <<Duration>>
  pass:[/**] @property min_doc_count Only returns buckets that have `min_doc_count` number of documents. By default, all buckets between the first bucket that matches documents and the last one are returned. */
  min_doc_count?: <<integer>>
  pass:[/**] @property missing The value to apply to documents that do not have a value. By default, documents without a value are ignored. */
  missing?: <<DateTime>>
  pass:[/**] @property offset Changes the start value of each bucket by the specified positive (`+`) or negative offset (`-`) duration. */
  offset?: <<Duration>>
  pass:[/**] @property order The sort order of the returned buckets. */
  order?: <<AggregationsAggregateOrder>>
  params?: Record<string, any>
  script?: <<Script>> | string
  pass:[/**] @property time_zone Time zone used for bucketing and rounding. Defaults to Coordinated Universal Time (UTC). */
  time_zone?: <<TimeZone>>
  pass:[/**] @property keyed Set to `true` to associate a unique string key with each bucket and return the ranges as a hash rather than an array. */
  keyed?: boolean
}
----


[discrete]
[[AggregationsDateHistogramBucket]]
=== AggregationsDateHistogramBucket

[source,ts,subs=+macros]
----
interface AggregationsDateHistogramBucketKeys extends <<AggregationsMultiBucketBase>> {
  key_as_string?: string
  key: <<EpochTime>><<<UnitMillis>>>
}
type AggregationsDateHistogramBucket = AggregationsDateHistogramBucketKeys
  & { [property: string]: <<AggregationsAggregate>> | string | <<EpochTime>><<<UnitMillis>>> | <<long>> }
----


[discrete]
[[AggregationsDateRangeAggregate]]
=== AggregationsDateRangeAggregate

[source,ts,subs=+macros]
----
interface AggregationsDateRangeAggregate extends <<AggregationsRangeAggregate>> {}
----


[discrete]
[[AggregationsDateRangeAggregation]]
=== AggregationsDateRangeAggregation

[source,ts,subs=+macros]
----
interface AggregationsDateRangeAggregation extends <<AggregationsBucketAggregationBase>> {
  pass:[/**] @property field The date field whose values are use to build ranges. */
  field?: <<Field>>
  pass:[/**] @property format The date format used to format `from` and `to` in the response. */
  format?: string
  pass:[/**] @property missing The value to apply to documents that do not have a value. By default, documents without a value are ignored. */
  missing?: <<AggregationsMissing>>
  pass:[/**] @property ranges Array of date ranges. */
  ranges?: <<AggregationsDateRangeExpression>>[]
  pass:[/**] @property time_zone Time zone used to convert dates from another time zone to UTC. */
  time_zone?: <<TimeZone>>
  pass:[/**] @property keyed Set to `true` to associate a unique string key with each bucket and returns the ranges as a hash rather than an array. */
  keyed?: boolean
}
----


[discrete]
[[AggregationsDateRangeExpression]]
=== AggregationsDateRangeExpression

[source,ts,subs=+macros]
----
interface AggregationsDateRangeExpression {
  pass:[/**] @property from Start of the range (inclusive). */
  from?: <<AggregationsFieldDateMath>>
  pass:[/**] @property key Custom key to return the range with. */
  key?: string
  pass:[/**] @property to End of the range (exclusive). */
  to?: <<AggregationsFieldDateMath>>
}
----


[discrete]
[[AggregationsDerivativeAggregate]]
=== AggregationsDerivativeAggregate

[source,ts,subs=+macros]
----
interface AggregationsDerivativeAggregate extends <<AggregationsSingleMetricAggregateBase>> {
  normalized_value?: <<double>>
  normalized_value_as_string?: string
}
----


[discrete]
[[AggregationsDerivativeAggregation]]
=== AggregationsDerivativeAggregation

[source,ts,subs=+macros]
----
interface AggregationsDerivativeAggregation extends <<AggregationsPipelineAggregationBase>> {}
----


[discrete]
[[AggregationsDiversifiedSamplerAggregation]]
=== AggregationsDiversifiedSamplerAggregation

[source,ts,subs=+macros]
----
interface AggregationsDiversifiedSamplerAggregation extends <<AggregationsBucketAggregationBase>> {
  pass:[/**] @property execution_hint The type of value used for de-duplication. */
  execution_hint?: <<AggregationsSamplerAggregationExecutionHint>>
  pass:[/**] @property max_docs_per_value Limits how many documents are permitted per choice of de-duplicating value. */
  max_docs_per_value?: <<integer>>
  script?: <<Script>> | string
  pass:[/**] @property shard_size Limits how many top-scoring documents are collected in the sample processed on each shard. */
  shard_size?: <<integer>>
  pass:[/**] @property field The field used to provide values used for de-duplication. */
  field?: <<Field>>
}
----


[discrete]
[[AggregationsDoubleTermsAggregate]]
=== AggregationsDoubleTermsAggregate

[source,ts,subs=+macros]
----
interface AggregationsDoubleTermsAggregate extends <<AggregationsTermsAggregateBase>><<<AggregationsDoubleTermsBucket>>> {}
----


[discrete]
[[AggregationsDoubleTermsBucket]]
=== AggregationsDoubleTermsBucket

[source,ts,subs=+macros]
----
interface AggregationsDoubleTermsBucketKeys extends <<AggregationsTermsBucketBase>> {
  key: <<double>>
  key_as_string?: string
}
type AggregationsDoubleTermsBucket = AggregationsDoubleTermsBucketKeys
  & { [property: string]: <<AggregationsAggregate>> | <<double>> | string | <<long>> }
----


[discrete]
[[AggregationsEwmaModelSettings]]
=== AggregationsEwmaModelSettings

[source,ts,subs=+macros]
----
interface AggregationsEwmaModelSettings {
  alpha?: <<float>>
}
----


[discrete]
[[AggregationsEwmaMovingAverageAggregation]]
=== AggregationsEwmaMovingAverageAggregation

[source,ts,subs=+macros]
----
interface AggregationsEwmaMovingAverageAggregation extends <<AggregationsMovingAverageAggregationBase>> {
  model: 'ewma'
  settings: <<AggregationsEwmaModelSettings>>
}
----


[discrete]
[[AggregationsExtendedBounds]]
=== AggregationsExtendedBounds

[source,ts,subs=+macros]
----
interface AggregationsExtendedBounds<T = unknown> {
  pass:[/**] @property max Maximum value for the bound. */
  max?: T
  pass:[/**] @property min Minimum value for the bound. */
  min?: T
}
----


[discrete]
[[AggregationsExtendedStatsAggregate]]
=== AggregationsExtendedStatsAggregate

[source,ts,subs=+macros]
----
interface AggregationsExtendedStatsAggregate extends <<AggregationsStatsAggregate>> {
  sum_of_squares: <<double>> | null
  variance: <<double>> | null
  variance_population: <<double>> | null
  variance_sampling: <<double>> | null
  std_deviation: <<double>> | null
  std_deviation_population: <<double>> | null
  std_deviation_sampling: <<double>> | null
  std_deviation_bounds?: <<AggregationsStandardDeviationBounds>>
  sum_of_squares_as_string?: string
  variance_as_string?: string
  variance_population_as_string?: string
  variance_sampling_as_string?: string
  std_deviation_as_string?: string
  std_deviation_bounds_as_string?: <<AggregationsStandardDeviationBoundsAsString>>
}
----


[discrete]
[[AggregationsExtendedStatsAggregation]]
=== AggregationsExtendedStatsAggregation

[source,ts,subs=+macros]
----
interface AggregationsExtendedStatsAggregation extends <<AggregationsFormatMetricAggregationBase>> {
  pass:[/**] @property sigma The number of standard deviations above/below the mean to display. */
  sigma?: <<double>>
}
----


[discrete]
[[AggregationsExtendedStatsBucketAggregate]]
=== AggregationsExtendedStatsBucketAggregate

[source,ts,subs=+macros]
----
interface AggregationsExtendedStatsBucketAggregate extends <<AggregationsExtendedStatsAggregate>> {}
----


[discrete]
[[AggregationsExtendedStatsBucketAggregation]]
=== AggregationsExtendedStatsBucketAggregation

[source,ts,subs=+macros]
----
interface AggregationsExtendedStatsBucketAggregation extends <<AggregationsPipelineAggregationBase>> {
  pass:[/**] @property sigma The number of standard deviations above/below the mean to display. */
  sigma?: <<double>>
}
----


[discrete]
[[AggregationsFieldDateMath]]
=== AggregationsFieldDateMath

[source,ts,subs=+macros]
----
type AggregationsFieldDateMath = <<DateMath>> | <<double>>
----


[discrete]
[[AggregationsFilterAggregate]]
=== AggregationsFilterAggregate

[source,ts,subs=+macros]
----
interface AggregationsFilterAggregateKeys extends <<AggregationsSingleBucketAggregateBase>> {}
type AggregationsFilterAggregate = AggregationsFilterAggregateKeys
  & { [property: string]: <<AggregationsAggregate>> | <<long>> | <<Metadata>> }
----


[discrete]
[[AggregationsFiltersAggregate]]
=== AggregationsFiltersAggregate

[source,ts,subs=+macros]
----
interface AggregationsFiltersAggregate extends <<AggregationsMultiBucketAggregateBase>><<<AggregationsFiltersBucket>>> {}
----


[discrete]
[[AggregationsFiltersAggregation]]
=== AggregationsFiltersAggregation

[source,ts,subs=+macros]
----
interface AggregationsFiltersAggregation extends <<AggregationsBucketAggregationBase>> {
  pass:[/**] @property filters Collection of queries from which to build buckets. */
  filters?: <<AggregationsBuckets>><<<QueryDslQueryContainer>>>
  pass:[/**] @property other_bucket Set to `true` to add a bucket to the response which will contain all documents that do not match any of the given filters. */
  other_bucket?: boolean
  pass:[/**] @property other_bucket_key The key with which the other bucket is returned. */
  other_bucket_key?: string
  pass:[/**] @property keyed By default, the named filters aggregation returns the buckets as an object. Set to `false` to return the buckets as an array of objects. */
  keyed?: boolean
}
----


[discrete]
[[AggregationsFiltersBucket]]
=== AggregationsFiltersBucket

[source,ts,subs=+macros]
----
interface AggregationsFiltersBucketKeys extends <<AggregationsMultiBucketBase>> {}
type AggregationsFiltersBucket = AggregationsFiltersBucketKeys
  & { [property: string]: <<AggregationsAggregate>> | <<long>> }
----


[discrete]
[[AggregationsFormatMetricAggregationBase]]
=== AggregationsFormatMetricAggregationBase

[source,ts,subs=+macros]
----
interface AggregationsFormatMetricAggregationBase extends <<AggregationsMetricAggregationBase>> {
  format?: string
}
----


[discrete]
[[AggregationsFormattableMetricAggregation]]
=== AggregationsFormattableMetricAggregation

[source,ts,subs=+macros]
----
interface AggregationsFormattableMetricAggregation extends <<AggregationsMetricAggregationBase>> {
  format?: string
}
----


[discrete]
[[AggregationsFrequentItemSetsAggregate]]
=== AggregationsFrequentItemSetsAggregate

[source,ts,subs=+macros]
----
interface AggregationsFrequentItemSetsAggregate extends <<AggregationsMultiBucketAggregateBase>><<<AggregationsFrequentItemSetsBucket>>> {}
----


[discrete]
[[AggregationsFrequentItemSetsAggregation]]
=== AggregationsFrequentItemSetsAggregation

[source,ts,subs=+macros]
----
interface AggregationsFrequentItemSetsAggregation {
  pass:[/**] @property fields <<Fields>> to analyze. */
  fields: <<AggregationsFrequentItemSetsField>>[]
  pass:[/**] @property minimum_set_size The minimum size of one item set. */
  minimum_set_size?: <<integer>>
  pass:[/**] @property minimum_support The minimum support of one item set. */
  minimum_support?: <<double>>
  pass:[/**] @property size The number of top item sets to return. */
  size?: <<integer>>
  pass:[/**] @property filter Query that filters documents from analysis. */
  filter?: <<QueryDslQueryContainer>>
}
----


[discrete]
[[AggregationsFrequentItemSetsBucket]]
=== AggregationsFrequentItemSetsBucket

[source,ts,subs=+macros]
----
interface AggregationsFrequentItemSetsBucketKeys extends <<AggregationsMultiBucketBase>> {
  key: Record<<<Field>>, string[]>
  support: <<double>>
}
type AggregationsFrequentItemSetsBucket = AggregationsFrequentItemSetsBucketKeys
  & { [property: string]: <<AggregationsAggregate>> | Record<<<Field>>, string[]> | <<double>> | <<long>> }
----


[discrete]
[[AggregationsFrequentItemSetsField]]
=== AggregationsFrequentItemSetsField

[source,ts,subs=+macros]
----
interface AggregationsFrequentItemSetsField {
  field: <<Field>>
  pass:[/**] @property exclude Values to exclude. Can be regular expression strings or arrays of strings of exact terms. */
  exclude?: <<AggregationsTermsExclude>>
  pass:[/**] @property include Values to include. Can be regular expression strings or arrays of strings of exact terms. */
  include?: <<AggregationsTermsInclude>>
}
----


[discrete]
[[AggregationsGapPolicy]]
=== AggregationsGapPolicy

[source,ts,subs=+macros]
----
type AggregationsGapPolicy = 'skip' | 'insert_zeros' | 'keep_values'
----


[discrete]
[[AggregationsGeoBoundsAggregate]]
=== AggregationsGeoBoundsAggregate

[source,ts,subs=+macros]
----
interface AggregationsGeoBoundsAggregate extends <<AggregationsAggregateBase>> {
  bounds?: <<GeoBounds>>
}
----


[discrete]
[[AggregationsGeoBoundsAggregation]]
=== AggregationsGeoBoundsAggregation

[source,ts,subs=+macros]
----
interface AggregationsGeoBoundsAggregation extends <<AggregationsMetricAggregationBase>> {
  pass:[/**] @property wrap_longitude Specifies whether the bounding box should be allowed to overlap the international date line. */
  wrap_longitude?: boolean
}
----


[discrete]
[[AggregationsGeoCentroidAggregate]]
=== AggregationsGeoCentroidAggregate

[source,ts,subs=+macros]
----
interface AggregationsGeoCentroidAggregate extends <<AggregationsAggregateBase>> {
  count: <<long>>
  location?: <<GeoLocation>>
}
----


[discrete]
[[AggregationsGeoCentroidAggregation]]
=== AggregationsGeoCentroidAggregation

[source,ts,subs=+macros]
----
interface AggregationsGeoCentroidAggregation extends <<AggregationsMetricAggregationBase>> {
  count?: <<long>>
  location?: <<GeoLocation>>
}
----


[discrete]
[[AggregationsGeoDistanceAggregate]]
=== AggregationsGeoDistanceAggregate

[source,ts,subs=+macros]
----
interface AggregationsGeoDistanceAggregate extends <<AggregationsRangeAggregate>> {}
----


[discrete]
[[AggregationsGeoDistanceAggregation]]
=== AggregationsGeoDistanceAggregation

[source,ts,subs=+macros]
----
interface AggregationsGeoDistanceAggregation extends <<AggregationsBucketAggregationBase>> {
  pass:[/**] @property distance_type The distance calculation type. */
  distance_type?: <<GeoDistanceType>>
  pass:[/**] @property field A field of type `geo_point` used to evaluate the distance. */
  field?: <<Field>>
  pass:[/**] @property origin The origin used to evaluate the distance. */
  origin?: <<GeoLocation>>
  pass:[/**] @property ranges An array of ranges used to bucket documents. */
  ranges?: <<AggregationsAggregationRange>>[]
  pass:[/**] @property unit The distance unit. */
  unit?: <<DistanceUnit>>
}
----


[discrete]
[[AggregationsGeoHashGridAggregate]]
=== AggregationsGeoHashGridAggregate

[source,ts,subs=+macros]
----
interface AggregationsGeoHashGridAggregate extends <<AggregationsMultiBucketAggregateBase>><<<AggregationsGeoHashGridBucket>>> {}
----


[discrete]
[[AggregationsGeoHashGridAggregation]]
=== AggregationsGeoHashGridAggregation

[source,ts,subs=+macros]
----
interface AggregationsGeoHashGridAggregation extends <<AggregationsBucketAggregationBase>> {
  pass:[/**] @property bounds The bounding box to filter the points in each bucket. */
  bounds?: <<GeoBounds>>
  pass:[/**] @property field <<Field>> containing indexed `geo_point` or `geo_shape` values. If the field contains an array, `geohash_grid` aggregates all array values. */
  field?: <<Field>>
  pass:[/**] @property precision The string length of the geohashes used to define cells/buckets in the results. */
  precision?: <<GeoHashPrecision>>
  pass:[/**] @property shard_size Allows for more accurate counting of the top cells returned in the final result the aggregation. Defaults to returning `max(10,(size x number-of-shards))` buckets from each shard. */
  shard_size?: <<integer>>
  pass:[/**] @property size The maximum number of geohash buckets to return. */
  size?: <<integer>>
}
----


[discrete]
[[AggregationsGeoHashGridBucket]]
=== AggregationsGeoHashGridBucket

[source,ts,subs=+macros]
----
interface AggregationsGeoHashGridBucketKeys extends <<AggregationsMultiBucketBase>> {
  key: <<GeoHash>>
}
type AggregationsGeoHashGridBucket = AggregationsGeoHashGridBucketKeys
  & { [property: string]: <<AggregationsAggregate>> | <<GeoHash>> | <<long>> }
----


[discrete]
[[AggregationsGeoHexGridAggregate]]
=== AggregationsGeoHexGridAggregate

[source,ts,subs=+macros]
----
interface AggregationsGeoHexGridAggregate extends <<AggregationsMultiBucketAggregateBase>><<<AggregationsGeoHexGridBucket>>> {}
----


[discrete]
[[AggregationsGeoHexGridBucket]]
=== AggregationsGeoHexGridBucket

[source,ts,subs=+macros]
----
interface AggregationsGeoHexGridBucketKeys extends <<AggregationsMultiBucketBase>> {
  key: <<GeoHexCell>>
}
type AggregationsGeoHexGridBucket = AggregationsGeoHexGridBucketKeys
  & { [property: string]: <<AggregationsAggregate>> | <<GeoHexCell>> | <<long>> }
----


[discrete]
[[AggregationsGeoLineAggregate]]
=== AggregationsGeoLineAggregate

[source,ts,subs=+macros]
----
interface AggregationsGeoLineAggregate extends <<AggregationsAggregateBase>> {
  type: string
  geometry: <<GeoLine>>
  properties: any
}
----


[discrete]
[[AggregationsGeoLineAggregation]]
=== AggregationsGeoLineAggregation

[source,ts,subs=+macros]
----
interface AggregationsGeoLineAggregation {
  pass:[/**] @property point The name of the geo_point field. */
  point: <<AggregationsGeoLinePoint>>
  pass:[/**] @property sort The name of the numeric field to use as the sort key for ordering the points. When the `geo_line` aggregation is nested inside a `time_series` aggregation, this field defaults to `@timestamp`, and any other value will result in error. */
  sort: <<AggregationsGeoLineSort>>
  pass:[/**] @property include_sort When `true`, returns an additional array of the sort values in the feature properties. */
  include_sort?: boolean
  pass:[/**] @property sort_order The order in which the line is sorted (ascending or descending). */
  sort_order?: <<SortOrder>>
  pass:[/**] @property size The maximum length of the line represented in the aggregation. Valid sizes are between 1 and 10000. */
  size?: <<integer>>
}
----


[discrete]
[[AggregationsGeoLinePoint]]
=== AggregationsGeoLinePoint

[source,ts,subs=+macros]
----
interface AggregationsGeoLinePoint {
  pass:[/**] @property field The name of the geo_point field. */
  field: <<Field>>
}
----


[discrete]
[[AggregationsGeoLineSort]]
=== AggregationsGeoLineSort

[source,ts,subs=+macros]
----
interface AggregationsGeoLineSort {
  pass:[/**] @property field The name of the numeric field to use as the sort key for ordering the points. */
  field: <<Field>>
}
----


[discrete]
[[AggregationsGeoTileGridAggregate]]
=== AggregationsGeoTileGridAggregate

[source,ts,subs=+macros]
----
interface AggregationsGeoTileGridAggregate extends <<AggregationsMultiBucketAggregateBase>><<<AggregationsGeoTileGridBucket>>> {}
----


[discrete]
[[AggregationsGeoTileGridAggregation]]
=== AggregationsGeoTileGridAggregation

[source,ts,subs=+macros]
----
interface AggregationsGeoTileGridAggregation extends <<AggregationsBucketAggregationBase>> {
  pass:[/**] @property field <<Field>> containing indexed `geo_point` or `geo_shape` values. If the field contains an array, `geotile_grid` aggregates all array values. */
  field?: <<Field>>
  pass:[/**] @property precision Integer zoom of the key used to define cells/buckets in the results. Values outside of the range [0,29] will be rejected. */
  precision?: <<GeoTilePrecision>>
  pass:[/**] @property shard_size Allows for more accurate counting of the top cells returned in the final result the aggregation. Defaults to returning `max(10,(size x number-of-shards))` buckets from each shard. */
  shard_size?: <<integer>>
  pass:[/**] @property size The maximum number of buckets to return. */
  size?: <<integer>>
  pass:[/**] @property bounds A bounding box to filter the geo-points or geo-shapes in each bucket. */
  bounds?: <<GeoBounds>>
}
----


[discrete]
[[AggregationsGeoTileGridBucket]]
=== AggregationsGeoTileGridBucket

[source,ts,subs=+macros]
----
interface AggregationsGeoTileGridBucketKeys extends <<AggregationsMultiBucketBase>> {
  key: <<GeoTile>>
}
type AggregationsGeoTileGridBucket = AggregationsGeoTileGridBucketKeys
  & { [property: string]: <<AggregationsAggregate>> | <<GeoTile>> | <<long>> }
----


[discrete]
[[AggregationsGeohexGridAggregation]]
=== AggregationsGeohexGridAggregation

[source,ts,subs=+macros]
----
interface AggregationsGeohexGridAggregation extends <<AggregationsBucketAggregationBase>> {
  pass:[/**] @property field <<Field>> containing indexed `geo_point` or `geo_shape` values. If the field contains an array, `geohex_grid` aggregates all array values. */
  field: <<Field>>
  pass:[/**] @property precision Integer zoom of the key used to defined cells or buckets in the results. Value should be between 0-15. */
  precision?: <<integer>>
  pass:[/**] @property bounds Bounding box used to filter the geo-points in each bucket. */
  bounds?: <<GeoBounds>>
  pass:[/**] @property size Maximum number of buckets to return. */
  size?: <<integer>>
  pass:[/**] @property shard_size Number of buckets returned from each shard. */
  shard_size?: <<integer>>
}
----


[discrete]
[[AggregationsGlobalAggregate]]
=== AggregationsGlobalAggregate

[source,ts,subs=+macros]
----
interface AggregationsGlobalAggregateKeys extends <<AggregationsSingleBucketAggregateBase>> {}
type AggregationsGlobalAggregate = AggregationsGlobalAggregateKeys
  & { [property: string]: <<AggregationsAggregate>> | <<long>> | <<Metadata>> }
----


[discrete]
[[AggregationsGlobalAggregation]]
=== AggregationsGlobalAggregation

[source,ts,subs=+macros]
----
interface AggregationsGlobalAggregation extends <<AggregationsBucketAggregationBase>> {}
----


[discrete]
[[AggregationsGoogleNormalizedDistanceHeuristic]]
=== AggregationsGoogleNormalizedDistanceHeuristic

[source,ts,subs=+macros]
----
interface AggregationsGoogleNormalizedDistanceHeuristic {
  pass:[/**] @property background_is_superset Set to `false` if you defined a custom background filter that represents a different set of documents that you want to compare to. */
  background_is_superset?: boolean
}
----


[discrete]
[[AggregationsHdrMethod]]
=== AggregationsHdrMethod

[source,ts,subs=+macros]
----
interface AggregationsHdrMethod {
  pass:[/**] @property number_of_significant_value_digits Specifies the resolution of values for the histogram in number of significant digits. */
  number_of_significant_value_digits?: <<integer>>
}
----


[discrete]
[[AggregationsHdrPercentileRanksAggregate]]
=== AggregationsHdrPercentileRanksAggregate

[source,ts,subs=+macros]
----
interface AggregationsHdrPercentileRanksAggregate extends <<AggregationsPercentilesAggregateBase>> {}
----


[discrete]
[[AggregationsHdrPercentilesAggregate]]
=== AggregationsHdrPercentilesAggregate

[source,ts,subs=+macros]
----
interface AggregationsHdrPercentilesAggregate extends <<AggregationsPercentilesAggregateBase>> {}
----


[discrete]
[[AggregationsHistogramAggregate]]
=== AggregationsHistogramAggregate

[source,ts,subs=+macros]
----
interface AggregationsHistogramAggregate extends <<AggregationsMultiBucketAggregateBase>><<<AggregationsHistogramBucket>>> {}
----


[discrete]
[[AggregationsHistogramAggregation]]
=== AggregationsHistogramAggregation

[source,ts,subs=+macros]
----
interface AggregationsHistogramAggregation extends <<AggregationsBucketAggregationBase>> {
  pass:[/**] @property extended_bounds Enables extending the bounds of the histogram beyond the data itself. */
  extended_bounds?: <<AggregationsExtendedBounds>><<<double>>>
  pass:[/**] @property hard_bounds Limits the range of buckets in the histogram. It is particularly useful in the case of open data ranges that can result in a very large number of buckets. */
  hard_bounds?: <<AggregationsExtendedBounds>><<<double>>>
  pass:[/**] @property field The name of the field to aggregate on. */
  field?: <<Field>>
  pass:[/**] @property interval The interval for the buckets. Must be a positive decimal. */
  interval?: <<double>>
  pass:[/**] @property min_doc_count Only returns buckets that have `min_doc_count` number of documents. By default, the response will fill gaps in the histogram with empty buckets. */
  min_doc_count?: <<integer>>
  pass:[/**] @property missing The value to apply to documents that do not have a value. By default, documents without a value are ignored. */
  missing?: <<double>>
  pass:[/**] @property offset By default, the bucket keys start with 0 and then continue in even spaced steps of `interval`. The bucket boundaries can be shifted by using the `offset` option. */
  offset?: <<double>>
  pass:[/**] @property order The sort order of the returned buckets. By default, the returned buckets are sorted by their key ascending. */
  order?: <<AggregationsAggregateOrder>>
  script?: <<Script>> | string
  format?: string
  pass:[/**] @property keyed If `true`, returns buckets as a hash instead of an array, keyed by the bucket keys. */
  keyed?: boolean
}
----


[discrete]
[[AggregationsHistogramBucket]]
=== AggregationsHistogramBucket

[source,ts,subs=+macros]
----
interface AggregationsHistogramBucketKeys extends <<AggregationsMultiBucketBase>> {
  key_as_string?: string
  key: <<double>>
}
type AggregationsHistogramBucket = AggregationsHistogramBucketKeys
  & { [property: string]: <<AggregationsAggregate>> | string | <<double>> | <<long>> }
----


[discrete]
[[AggregationsHoltLinearModelSettings]]
=== AggregationsHoltLinearModelSettings

[source,ts,subs=+macros]
----
interface AggregationsHoltLinearModelSettings {
  alpha?: <<float>>
  beta?: <<float>>
}
----


[discrete]
[[AggregationsHoltMovingAverageAggregation]]
=== AggregationsHoltMovingAverageAggregation

[source,ts,subs=+macros]
----
interface AggregationsHoltMovingAverageAggregation extends <<AggregationsMovingAverageAggregationBase>> {
  model: 'holt'
  settings: <<AggregationsHoltLinearModelSettings>>
}
----


[discrete]
[[AggregationsHoltWintersModelSettings]]
=== AggregationsHoltWintersModelSettings

[source,ts,subs=+macros]
----
interface AggregationsHoltWintersModelSettings {
  alpha?: <<float>>
  beta?: <<float>>
  gamma?: <<float>>
  pad?: boolean
  period?: <<integer>>
  type?: <<AggregationsHoltWintersType>>
}
----


[discrete]
[[AggregationsHoltWintersMovingAverageAggregation]]
=== AggregationsHoltWintersMovingAverageAggregation

[source,ts,subs=+macros]
----
interface AggregationsHoltWintersMovingAverageAggregation extends <<AggregationsMovingAverageAggregationBase>> {
  model: 'holt_winters'
  settings: <<AggregationsHoltWintersModelSettings>>
}
----


[discrete]
[[AggregationsHoltWintersType]]
=== AggregationsHoltWintersType

[source,ts,subs=+macros]
----
type AggregationsHoltWintersType = 'add' | 'mult'
----


[discrete]
[[AggregationsInferenceAggregate]]
=== AggregationsInferenceAggregate

[source,ts,subs=+macros]
----
interface AggregationsInferenceAggregateKeys extends <<AggregationsAggregateBase>> {
  value?: <<FieldValue>>
  feature_importance?: <<AggregationsInferenceFeatureImportance>>[]
  top_classes?: <<AggregationsInferenceTopClassEntry>>[]
  warning?: string
}
type AggregationsInferenceAggregate = AggregationsInferenceAggregateKeys
  & { [property: string]: any }
----


[discrete]
[[AggregationsInferenceAggregation]]
=== AggregationsInferenceAggregation

[source,ts,subs=+macros]
----
interface AggregationsInferenceAggregation extends <<AggregationsPipelineAggregationBase>> {
  pass:[/**] @property model_id The ID or alias for the trained model. */
  model_id: <<Name>>
  pass:[/**] @property inference_config Contains the inference type and its options. */
  inference_config?: <<AggregationsInferenceConfigContainer>>
}
----


[discrete]
[[AggregationsInferenceClassImportance]]
=== AggregationsInferenceClassImportance

[source,ts,subs=+macros]
----
interface AggregationsInferenceClassImportance {
  class_name: string
  importance: <<double>>
}
----


[discrete]
[[AggregationsInferenceConfigContainer]]
=== AggregationsInferenceConfigContainer

[source,ts,subs=+macros]
----
interface AggregationsInferenceConfigContainer {
  pass:[/**] @property regression Regression configuration for inference. */
  regression?: <<MlRegressionInferenceOptions>>
  pass:[/**] @property classification Classification configuration for inference. */
  classification?: <<MlClassificationInferenceOptions>>
}
----


[discrete]
[[AggregationsInferenceFeatureImportance]]
=== AggregationsInferenceFeatureImportance

[source,ts,subs=+macros]
----
interface AggregationsInferenceFeatureImportance {
  feature_name: string
  importance?: <<double>>
  classes?: <<AggregationsInferenceClassImportance>>[]
}
----


[discrete]
[[AggregationsInferenceTopClassEntry]]
=== AggregationsInferenceTopClassEntry

[source,ts,subs=+macros]
----
interface AggregationsInferenceTopClassEntry {
  class_name: <<FieldValue>>
  class_probability: <<double>>
  class_score: <<double>>
}
----


[discrete]
[[AggregationsIpPrefixAggregate]]
=== AggregationsIpPrefixAggregate

[source,ts,subs=+macros]
----
interface AggregationsIpPrefixAggregate extends <<AggregationsMultiBucketAggregateBase>><<<AggregationsIpPrefixBucket>>> {}
----


[discrete]
[[AggregationsIpPrefixAggregation]]
=== AggregationsIpPrefixAggregation

[source,ts,subs=+macros]
----
interface AggregationsIpPrefixAggregation extends <<AggregationsBucketAggregationBase>> {
  pass:[/**] @property field The IP address field to aggregation on. The field mapping type must be `ip`. */
  field: <<Field>>
  pass:[/**] @property prefix_length Length of the network prefix. For IPv4 addresses the accepted range is [0, 32]. For IPv6 addresses the accepted range is [0, 128]. */
  prefix_length: <<integer>>
  pass:[/**] @property is_ipv6 Defines whether the prefix applies to IPv6 addresses. */
  is_ipv6?: boolean
  pass:[/**] @property append_prefix_length Defines whether the prefix length is appended to IP address keys in the response. */
  append_prefix_length?: boolean
  pass:[/**] @property keyed Defines whether buckets are returned as a hash rather than an array in the response. */
  keyed?: boolean
  pass:[/**] @property min_doc_count Minimum number of documents in a bucket for it to be included in the response. */
  min_doc_count?: <<long>>
}
----


[discrete]
[[AggregationsIpPrefixBucket]]
=== AggregationsIpPrefixBucket

[source,ts,subs=+macros]
----
interface AggregationsIpPrefixBucketKeys extends <<AggregationsMultiBucketBase>> {
  is_ipv6: boolean
  key: string
  prefix_length: <<integer>>
  netmask?: string
}
type AggregationsIpPrefixBucket = AggregationsIpPrefixBucketKeys
  & { [property: string]: <<AggregationsAggregate>> | boolean | string | <<integer>> | <<long>> }
----


[discrete]
[[AggregationsIpRangeAggregate]]
=== AggregationsIpRangeAggregate

[source,ts,subs=+macros]
----
interface AggregationsIpRangeAggregate extends <<AggregationsMultiBucketAggregateBase>><<<AggregationsIpRangeBucket>>> {}
----


[discrete]
[[AggregationsIpRangeAggregation]]
=== AggregationsIpRangeAggregation

[source,ts,subs=+macros]
----
interface AggregationsIpRangeAggregation extends <<AggregationsBucketAggregationBase>> {
  pass:[/**] @property field The date field whose values are used to build ranges. */
  field?: <<Field>>
  pass:[/**] @property ranges Array of IP ranges. */
  ranges?: <<AggregationsIpRangeAggregationRange>>[]
}
----


[discrete]
[[AggregationsIpRangeAggregationRange]]
=== AggregationsIpRangeAggregationRange

[source,ts,subs=+macros]
----
interface AggregationsIpRangeAggregationRange {
  pass:[/**] @property from Start of the range. */
  from?: string | null
  pass:[/**] @property mask IP range defined as a CIDR mask. */
  mask?: string
  pass:[/**] @property to End of the range. */
  to?: string | null
}
----


[discrete]
[[AggregationsIpRangeBucket]]
=== AggregationsIpRangeBucket

[source,ts,subs=+macros]
----
interface AggregationsIpRangeBucketKeys extends <<AggregationsMultiBucketBase>> {
  key?: string
  from?: string
  to?: string
}
type AggregationsIpRangeBucket = AggregationsIpRangeBucketKeys
  & { [property: string]: <<AggregationsAggregate>> | string | <<long>> }
----


[discrete]
[[AggregationsKeyedPercentiles]]
=== AggregationsKeyedPercentiles

[source,ts,subs=+macros]
----
type AggregationsKeyedPercentiles = Record<string, string | <<long>> | null>
----


[discrete]
[[AggregationsLinearMovingAverageAggregation]]
=== AggregationsLinearMovingAverageAggregation

[source,ts,subs=+macros]
----
interface AggregationsLinearMovingAverageAggregation extends <<AggregationsMovingAverageAggregationBase>> {
  model: 'linear'
  settings: <<EmptyObject>>
}
----


[discrete]
[[AggregationsLongRareTermsAggregate]]
=== AggregationsLongRareTermsAggregate

[source,ts,subs=+macros]
----
interface AggregationsLongRareTermsAggregate extends <<AggregationsMultiBucketAggregateBase>><<<AggregationsLongRareTermsBucket>>> {}
----


[discrete]
[[AggregationsLongRareTermsBucket]]
=== AggregationsLongRareTermsBucket

[source,ts,subs=+macros]
----
interface AggregationsLongRareTermsBucketKeys extends <<AggregationsMultiBucketBase>> {
  key: <<long>>
  key_as_string?: string
}
type AggregationsLongRareTermsBucket = AggregationsLongRareTermsBucketKeys
  & { [property: string]: <<AggregationsAggregate>> | <<long>> | string }
----


[discrete]
[[AggregationsLongTermsAggregate]]
=== AggregationsLongTermsAggregate

[source,ts,subs=+macros]
----
interface AggregationsLongTermsAggregate extends <<AggregationsTermsAggregateBase>><<<AggregationsLongTermsBucket>>> {}
----


[discrete]
[[AggregationsLongTermsBucket]]
=== AggregationsLongTermsBucket

[source,ts,subs=+macros]
----
interface AggregationsLongTermsBucketKeys extends <<AggregationsTermsBucketBase>> {
  key: <<long>>
  key_as_string?: string
}
type AggregationsLongTermsBucket = AggregationsLongTermsBucketKeys
  & { [property: string]: <<AggregationsAggregate>> | <<long>> | string }
----


[discrete]
[[AggregationsMatrixAggregation]]
=== AggregationsMatrixAggregation

[source,ts,subs=+macros]
----
interface AggregationsMatrixAggregation {
  pass:[/**] @property fields An array of fields for computing the statistics. */
  fields?: <<Fields>>
  pass:[/**] @property missing The value to apply to documents that do not have a value. By default, documents without a value are ignored. */
  missing?: Record<<<Field>>, <<double>>>
}
----


[discrete]
[[AggregationsMatrixStatsAggregate]]
=== AggregationsMatrixStatsAggregate

[source,ts,subs=+macros]
----
interface AggregationsMatrixStatsAggregate extends <<AggregationsAggregateBase>> {
  doc_count: <<long>>
  fields?: <<AggregationsMatrixStatsFields>>[]
}
----


[discrete]
[[AggregationsMatrixStatsAggregation]]
=== AggregationsMatrixStatsAggregation

[source,ts,subs=+macros]
----
interface AggregationsMatrixStatsAggregation extends <<AggregationsMatrixAggregation>> {
  pass:[/**] @property mode Array value the aggregation will use for array or multi-valued fields. */
  mode?: <<SortMode>>
}
----


[discrete]
[[AggregationsMatrixStatsFields]]
=== AggregationsMatrixStatsFields

[source,ts,subs=+macros]
----
interface AggregationsMatrixStatsFields {
  name: <<Field>>
  count: <<long>>
  mean: <<double>>
  variance: <<double>>
  skewness: <<double>>
  kurtosis: <<double>>
  covariance: Record<<<Field>>, <<double>>>
  correlation: Record<<<Field>>, <<double>>>
}
----


[discrete]
[[AggregationsMaxAggregate]]
=== AggregationsMaxAggregate

[source,ts,subs=+macros]
----
interface AggregationsMaxAggregate extends <<AggregationsSingleMetricAggregateBase>> {}
----


[discrete]
[[AggregationsMaxAggregation]]
=== AggregationsMaxAggregation

[source,ts,subs=+macros]
----
interface AggregationsMaxAggregation extends <<AggregationsFormatMetricAggregationBase>> {}
----


[discrete]
[[AggregationsMaxBucketAggregation]]
=== AggregationsMaxBucketAggregation

[source,ts,subs=+macros]
----
interface AggregationsMaxBucketAggregation extends <<AggregationsPipelineAggregationBase>> {}
----


[discrete]
[[AggregationsMedianAbsoluteDeviationAggregate]]
=== AggregationsMedianAbsoluteDeviationAggregate

[source,ts,subs=+macros]
----
interface AggregationsMedianAbsoluteDeviationAggregate extends <<AggregationsSingleMetricAggregateBase>> {}
----


[discrete]
[[AggregationsMedianAbsoluteDeviationAggregation]]
=== AggregationsMedianAbsoluteDeviationAggregation

[source,ts,subs=+macros]
----
interface AggregationsMedianAbsoluteDeviationAggregation extends <<AggregationsFormatMetricAggregationBase>> {
  pass:[/**] @property compression Limits the maximum number of nodes used by the underlying TDigest algorithm to `20 * compression`, enabling control of memory usage and approximation error. */
  compression?: <<double>>
}
----


[discrete]
[[AggregationsMetricAggregationBase]]
=== AggregationsMetricAggregationBase

[source,ts,subs=+macros]
----
interface AggregationsMetricAggregationBase {
  pass:[/**] @property field The field on which to run the aggregation. */
  field?: <<Field>>
  pass:[/**] @property missing The value to apply to documents that do not have a value. By default, documents without a value are ignored. */
  missing?: <<AggregationsMissing>>
  script?: <<Script>> | string
}
----


[discrete]
[[AggregationsMinAggregate]]
=== AggregationsMinAggregate

[source,ts,subs=+macros]
----
interface AggregationsMinAggregate extends <<AggregationsSingleMetricAggregateBase>> {}
----


[discrete]
[[AggregationsMinAggregation]]
=== AggregationsMinAggregation

[source,ts,subs=+macros]
----
interface AggregationsMinAggregation extends <<AggregationsFormatMetricAggregationBase>> {}
----


[discrete]
[[AggregationsMinBucketAggregation]]
=== AggregationsMinBucketAggregation

[source,ts,subs=+macros]
----
interface AggregationsMinBucketAggregation extends <<AggregationsPipelineAggregationBase>> {}
----


[discrete]
[[AggregationsMinimumInterval]]
=== AggregationsMinimumInterval

[source,ts,subs=+macros]
----
type AggregationsMinimumInterval = 'second' | 'minute' | 'hour' | 'day' | 'month' | 'year'
----


[discrete]
[[AggregationsMissing]]
=== AggregationsMissing

[source,ts,subs=+macros]
----
type AggregationsMissing = string | <<integer>> | <<double>> | boolean
----


[discrete]
[[AggregationsMissingAggregate]]
=== AggregationsMissingAggregate

[source,ts,subs=+macros]
----
interface AggregationsMissingAggregateKeys extends <<AggregationsSingleBucketAggregateBase>> {}
type AggregationsMissingAggregate = AggregationsMissingAggregateKeys
  & { [property: string]: <<AggregationsAggregate>> | <<long>> | <<Metadata>> }
----


[discrete]
[[AggregationsMissingAggregation]]
=== AggregationsMissingAggregation

[source,ts,subs=+macros]
----
interface AggregationsMissingAggregation extends <<AggregationsBucketAggregationBase>> {
  pass:[/**] @property field The name of the field. */
  field?: <<Field>>
  missing?: <<AggregationsMissing>>
}
----


[discrete]
[[AggregationsMissingOrder]]
=== AggregationsMissingOrder

[source,ts,subs=+macros]
----
type AggregationsMissingOrder = 'first' | 'last' | 'default'
----


[discrete]
[[AggregationsMovingAverageAggregation]]
=== AggregationsMovingAverageAggregation

[source,ts,subs=+macros]
----
type AggregationsMovingAverageAggregation = <<AggregationsLinearMovingAverageAggregation>> | <<AggregationsSimpleMovingAverageAggregation>> | <<AggregationsEwmaMovingAverageAggregation>> | <<AggregationsHoltMovingAverageAggregation>> | <<AggregationsHoltWintersMovingAverageAggregation>>
----


[discrete]
[[AggregationsMovingAverageAggregationBase]]
=== AggregationsMovingAverageAggregationBase

[source,ts,subs=+macros]
----
interface AggregationsMovingAverageAggregationBase extends <<AggregationsPipelineAggregationBase>> {
  minimize?: boolean
  predict?: <<integer>>
  window?: <<integer>>
}
----


[discrete]
[[AggregationsMovingFunctionAggregation]]
=== AggregationsMovingFunctionAggregation

[source,ts,subs=+macros]
----
interface AggregationsMovingFunctionAggregation extends <<AggregationsPipelineAggregationBase>> {
  pass:[/**] @property script The script that should be executed on each window of data. */
  script?: string
  pass:[/**] @property shift By default, the window consists of the last n values excluding the current bucket. Increasing `shift` by 1, moves the starting window position by 1 to the right. */
  shift?: <<integer>>
  pass:[/**] @property window The size of window to "slide" across the histogram. */
  window?: <<integer>>
}
----


[discrete]
[[AggregationsMovingPercentilesAggregation]]
=== AggregationsMovingPercentilesAggregation

[source,ts,subs=+macros]
----
interface AggregationsMovingPercentilesAggregation extends <<AggregationsPipelineAggregationBase>> {
  pass:[/**] @property window The size of window to "slide" across the histogram. */
  window?: <<integer>>
  pass:[/**] @property shift By default, the window consists of the last n values excluding the current bucket. Increasing `shift` by 1, moves the starting window position by 1 to the right. */
  shift?: <<integer>>
  keyed?: boolean
}
----


[discrete]
[[AggregationsMultiBucketAggregateBase]]
=== AggregationsMultiBucketAggregateBase

[source,ts,subs=+macros]
----
interface AggregationsMultiBucketAggregateBase<TBucket = unknown> extends <<AggregationsAggregateBase>> {
  buckets: <<AggregationsBuckets>><TBucket>
}
----


[discrete]
[[AggregationsMultiBucketBase]]
=== AggregationsMultiBucketBase

[source,ts,subs=+macros]
----
interface AggregationsMultiBucketBase {
  doc_count: <<long>>
}
----


[discrete]
[[AggregationsMultiTermLookup]]
=== AggregationsMultiTermLookup

[source,ts,subs=+macros]
----
interface AggregationsMultiTermLookup {
  pass:[/**] @property field A fields from which to retrieve terms. */
  field: <<Field>>
  pass:[/**] @property missing The value to apply to documents that do not have a value. By default, documents without a value are ignored. */
  missing?: <<AggregationsMissing>>
}
----


[discrete]
[[AggregationsMultiTermsAggregate]]
=== AggregationsMultiTermsAggregate

[source,ts,subs=+macros]
----
interface AggregationsMultiTermsAggregate extends <<AggregationsTermsAggregateBase>><<<AggregationsMultiTermsBucket>>> {}
----


[discrete]
[[AggregationsMultiTermsAggregation]]
=== AggregationsMultiTermsAggregation

[source,ts,subs=+macros]
----
interface AggregationsMultiTermsAggregation extends <<AggregationsBucketAggregationBase>> {
  pass:[/**] @property collect_mode Specifies the strategy for data collection. */
  collect_mode?: <<AggregationsTermsAggregationCollectMode>>
  pass:[/**] @property order Specifies the sort order of the buckets. Defaults to sorting by descending document count. */
  order?: <<AggregationsAggregateOrder>>
  pass:[/**] @property min_doc_count The minimum number of documents in a bucket for it to be returned. */
  min_doc_count?: <<long>>
  pass:[/**] @property shard_min_doc_count The minimum number of documents in a bucket on each shard for it to be returned. */
  shard_min_doc_count?: <<long>>
  pass:[/**] @property shard_size The number of candidate terms produced by each shard. By default, `shard_size` will be automatically estimated based on the number of shards and the `size` parameter. */
  shard_size?: <<integer>>
  pass:[/**] @property show_term_doc_count_error Calculates the doc count error on per term basis. */
  show_term_doc_count_error?: boolean
  pass:[/**] @property size The number of term buckets should be returned out of the overall terms list. */
  size?: <<integer>>
  pass:[/**] @property terms The field from which to generate sets of terms. */
  terms: <<AggregationsMultiTermLookup>>[]
}
----


[discrete]
[[AggregationsMultiTermsBucket]]
=== AggregationsMultiTermsBucket

[source,ts,subs=+macros]
----
interface AggregationsMultiTermsBucketKeys extends <<AggregationsMultiBucketBase>> {
  key: <<FieldValue>>[]
  key_as_string?: string
  doc_count_error_upper_bound?: <<long>>
}
type AggregationsMultiTermsBucket = AggregationsMultiTermsBucketKeys
  & { [property: string]: <<AggregationsAggregate>> | <<FieldValue>>[] | string | <<long>> }
----


[discrete]
[[AggregationsMutualInformationHeuristic]]
=== AggregationsMutualInformationHeuristic

[source,ts,subs=+macros]
----
interface AggregationsMutualInformationHeuristic {
  pass:[/**] @property background_is_superset Set to `false` if you defined a custom background filter that represents a different set of documents that you want to compare to. */
  background_is_superset?: boolean
  pass:[/**] @property include_negatives Set to `false` to filter out the terms that appear less often in the subset than in documents outside the subset. */
  include_negatives?: boolean
}
----


[discrete]
[[AggregationsNestedAggregate]]
=== AggregationsNestedAggregate

[source,ts,subs=+macros]
----
interface AggregationsNestedAggregateKeys extends <<AggregationsSingleBucketAggregateBase>> {}
type AggregationsNestedAggregate = AggregationsNestedAggregateKeys
  & { [property: string]: <<AggregationsAggregate>> | <<long>> | <<Metadata>> }
----


[discrete]
[[AggregationsNestedAggregation]]
=== AggregationsNestedAggregation

[source,ts,subs=+macros]
----
interface AggregationsNestedAggregation extends <<AggregationsBucketAggregationBase>> {
  pass:[/**] @property path The path to the field of type `nested`. */
  path?: <<Field>>
}
----


[discrete]
[[AggregationsNormalizeAggregation]]
=== AggregationsNormalizeAggregation

[source,ts,subs=+macros]
----
interface AggregationsNormalizeAggregation extends <<AggregationsPipelineAggregationBase>> {
  pass:[/**] @property method The specific method to apply. */
  method?: <<AggregationsNormalizeMethod>>
}
----


[discrete]
[[AggregationsNormalizeMethod]]
=== AggregationsNormalizeMethod

[source,ts,subs=+macros]
----
type AggregationsNormalizeMethod = 'rescale_0_1' | 'rescale_0_100' | 'percent_of_sum' | 'mean' | 'z-score' | 'softmax'
----


[discrete]
[[AggregationsParentAggregate]]
=== AggregationsParentAggregate

[source,ts,subs=+macros]
----
interface AggregationsParentAggregateKeys extends <<AggregationsSingleBucketAggregateBase>> {}
type AggregationsParentAggregate = AggregationsParentAggregateKeys
  & { [property: string]: <<AggregationsAggregate>> | <<long>> | <<Metadata>> }
----


[discrete]
[[AggregationsParentAggregation]]
=== AggregationsParentAggregation

[source,ts,subs=+macros]
----
interface AggregationsParentAggregation extends <<AggregationsBucketAggregationBase>> {
  pass:[/**] @property type The child type that should be selected. */
  type?: <<RelationName>>
}
----


[discrete]
[[AggregationsPercentageScoreHeuristic]]
=== AggregationsPercentageScoreHeuristic

[source,ts,subs=+macros]
----
interface AggregationsPercentageScoreHeuristic {}
----


[discrete]
[[AggregationsPercentileRanksAggregation]]
=== AggregationsPercentileRanksAggregation

[source,ts,subs=+macros]
----
interface AggregationsPercentileRanksAggregation extends <<AggregationsFormatMetricAggregationBase>> {
  pass:[/**] @property keyed By default, the aggregation associates a unique string key with each bucket and returns the ranges as a hash rather than an array. Set to `false` to disable this behavior. */
  keyed?: boolean
  pass:[/**] @property values An array of values for which to calculate the percentile ranks. */
  values?: <<double>>[] | null
  pass:[/**] @property hdr Uses the alternative High Dynamic Range Histogram algorithm to calculate percentile ranks. */
  hdr?: <<AggregationsHdrMethod>>
  pass:[/**] @property tdigest Sets parameters for the default TDigest algorithm used to calculate percentile ranks. */
  tdigest?: <<AggregationsTDigest>>
}
----


[discrete]
[[AggregationsPercentiles]]
=== AggregationsPercentiles

[source,ts,subs=+macros]
----
type AggregationsPercentiles = <<AggregationsKeyedPercentiles>> | <<AggregationsArrayPercentilesItem>>[]
----


[discrete]
[[AggregationsPercentilesAggregateBase]]
=== AggregationsPercentilesAggregateBase

[source,ts,subs=+macros]
----
interface AggregationsPercentilesAggregateBase extends <<AggregationsAggregateBase>> {
  values: <<AggregationsPercentiles>>
}
----


[discrete]
[[AggregationsPercentilesAggregation]]
=== AggregationsPercentilesAggregation

[source,ts,subs=+macros]
----
interface AggregationsPercentilesAggregation extends <<AggregationsFormatMetricAggregationBase>> {
  pass:[/**] @property keyed By default, the aggregation associates a unique string key with each bucket and returns the ranges as a hash rather than an array. Set to `false` to disable this behavior. */
  keyed?: boolean
  pass:[/**] @property percents The percentiles to calculate. */
  percents?: <<double>>[]
  pass:[/**] @property hdr Uses the alternative High Dynamic Range Histogram algorithm to calculate percentiles. */
  hdr?: <<AggregationsHdrMethod>>
  pass:[/**] @property tdigest Sets parameters for the default TDigest algorithm used to calculate percentiles. */
  tdigest?: <<AggregationsTDigest>>
}
----


[discrete]
[[AggregationsPercentilesBucketAggregate]]
=== AggregationsPercentilesBucketAggregate

[source,ts,subs=+macros]
----
interface AggregationsPercentilesBucketAggregate extends <<AggregationsPercentilesAggregateBase>> {}
----


[discrete]
[[AggregationsPercentilesBucketAggregation]]
=== AggregationsPercentilesBucketAggregation

[source,ts,subs=+macros]
----
interface AggregationsPercentilesBucketAggregation extends <<AggregationsPipelineAggregationBase>> {
  pass:[/**] @property percents The list of percentiles to calculate. */
  percents?: <<double>>[]
}
----


[discrete]
[[AggregationsPipelineAggregationBase]]
=== AggregationsPipelineAggregationBase

[source,ts,subs=+macros]
----
interface AggregationsPipelineAggregationBase extends <<AggregationsBucketPathAggregation>> {
  pass:[/**] @property format `DecimalFormat` pattern for the output value. If specified, the formatted value is returned in the aggregation’s `value_as_string` property. */
  format?: string
  pass:[/**] @property gap_policy Policy to apply when gaps are found in the data. */
  gap_policy?: <<AggregationsGapPolicy>>
}
----


[discrete]
[[AggregationsRandomSamplerAggregation]]
=== AggregationsRandomSamplerAggregation

[source,ts,subs=+macros]
----
interface AggregationsRandomSamplerAggregation extends <<AggregationsBucketAggregationBase>> {
  pass:[/**] @property probability The probability that a document will be included in the aggregated data. Must be greater than 0, less than 0.5, or exactly 1. The lower the probability, the fewer documents are matched. */
  probability: <<double>>
  pass:[/**] @property seed The seed to generate the random sampling of documents. When a seed is provided, the random subset of documents is the same between calls. */
  seed?: <<integer>>
  pass:[/**] @property shard_seed When combined with seed, setting shard_seed ensures 100% consistent sampling over shards where data is exactly the same. */
  shard_seed?: <<integer>>
}
----


[discrete]
[[AggregationsRangeAggregate]]
=== AggregationsRangeAggregate

[source,ts,subs=+macros]
----
interface AggregationsRangeAggregate extends <<AggregationsMultiBucketAggregateBase>><<<AggregationsRangeBucket>>> {}
----


[discrete]
[[AggregationsRangeAggregation]]
=== AggregationsRangeAggregation

[source,ts,subs=+macros]
----
interface AggregationsRangeAggregation extends <<AggregationsBucketAggregationBase>> {
  pass:[/**] @property field The date field whose values are use to build ranges. */
  field?: <<Field>>
  pass:[/**] @property missing The value to apply to documents that do not have a value. By default, documents without a value are ignored. */
  missing?: <<integer>>
  pass:[/**] @property ranges An array of ranges used to bucket documents. */
  ranges?: <<AggregationsAggregationRange>>[]
  script?: <<Script>> | string
  pass:[/**] @property keyed Set to `true` to associate a unique string key with each bucket and return the ranges as a hash rather than an array. */
  keyed?: boolean
  format?: string
}
----


[discrete]
[[AggregationsRangeBucket]]
=== AggregationsRangeBucket

[source,ts,subs=+macros]
----
interface AggregationsRangeBucketKeys extends <<AggregationsMultiBucketBase>> {
  from?: <<double>>
  to?: <<double>>
  from_as_string?: string
  to_as_string?: string
  key?: string
}
type AggregationsRangeBucket = AggregationsRangeBucketKeys
  & { [property: string]: <<AggregationsAggregate>> | <<double>> | string | <<long>> }
----


[discrete]
[[AggregationsRareTermsAggregation]]
=== AggregationsRareTermsAggregation

[source,ts,subs=+macros]
----
interface AggregationsRareTermsAggregation extends <<AggregationsBucketAggregationBase>> {
  pass:[/**] @property exclude Terms that should be excluded from the aggregation. */
  exclude?: <<AggregationsTermsExclude>>
  pass:[/**] @property field The field from which to return rare terms. */
  field?: <<Field>>
  pass:[/**] @property include Terms that should be included in the aggregation. */
  include?: <<AggregationsTermsInclude>>
  pass:[/**] @property max_doc_count The maximum number of documents a term should appear in. */
  max_doc_count?: <<long>>
  pass:[/**] @property missing The value to apply to documents that do not have a value. By default, documents without a value are ignored. */
  missing?: <<AggregationsMissing>>
  pass:[/**] @property precision The precision of the internal CuckooFilters. Smaller precision leads to better approximation, but higher memory usage. */
  precision?: <<double>>
  value_type?: string
}
----


[discrete]
[[AggregationsRateAggregate]]
=== AggregationsRateAggregate

[source,ts,subs=+macros]
----
interface AggregationsRateAggregate extends <<AggregationsAggregateBase>> {
  value: <<double>>
  value_as_string?: string
}
----


[discrete]
[[AggregationsRateAggregation]]
=== AggregationsRateAggregation

[source,ts,subs=+macros]
----
interface AggregationsRateAggregation extends <<AggregationsFormatMetricAggregationBase>> {
  pass:[/**] @property unit The interval used to calculate the rate. By default, the interval of the `date_histogram` is used. */
  unit?: <<AggregationsCalendarInterval>>
  pass:[/**] @property mode How the rate is calculated. */
  mode?: <<AggregationsRateMode>>
}
----


[discrete]
[[AggregationsRateMode]]
=== AggregationsRateMode

[source,ts,subs=+macros]
----
type AggregationsRateMode = 'sum' | 'value_count'
----


[discrete]
[[AggregationsReverseNestedAggregate]]
=== AggregationsReverseNestedAggregate

[source,ts,subs=+macros]
----
interface AggregationsReverseNestedAggregateKeys extends <<AggregationsSingleBucketAggregateBase>> {}
type AggregationsReverseNestedAggregate = AggregationsReverseNestedAggregateKeys
  & { [property: string]: <<AggregationsAggregate>> | <<long>> | <<Metadata>> }
----


[discrete]
[[AggregationsReverseNestedAggregation]]
=== AggregationsReverseNestedAggregation

[source,ts,subs=+macros]
----
interface AggregationsReverseNestedAggregation extends <<AggregationsBucketAggregationBase>> {
  pass:[/**] @property path Defines the nested object field that should be joined back to. The default is empty, which means that it joins back to the root/main document level. */
  path?: <<Field>>
}
----


[discrete]
[[AggregationsSamplerAggregate]]
=== AggregationsSamplerAggregate

[source,ts,subs=+macros]
----
interface AggregationsSamplerAggregateKeys extends <<AggregationsSingleBucketAggregateBase>> {}
type AggregationsSamplerAggregate = AggregationsSamplerAggregateKeys
  & { [property: string]: <<AggregationsAggregate>> | <<long>> | <<Metadata>> }
----


[discrete]
[[AggregationsSamplerAggregation]]
=== AggregationsSamplerAggregation

[source,ts,subs=+macros]
----
interface AggregationsSamplerAggregation extends <<AggregationsBucketAggregationBase>> {
  pass:[/**] @property shard_size Limits how many top-scoring documents are collected in the sample processed on each shard. */
  shard_size?: <<integer>>
}
----


[discrete]
[[AggregationsSamplerAggregationExecutionHint]]
=== AggregationsSamplerAggregationExecutionHint

[source,ts,subs=+macros]
----
type AggregationsSamplerAggregationExecutionHint = 'map' | 'global_ordinals' | 'bytes_hash'
----


[discrete]
[[AggregationsScriptedHeuristic]]
=== AggregationsScriptedHeuristic

[source,ts,subs=+macros]
----
interface AggregationsScriptedHeuristic {
  script: <<Script>> | string
}
----


[discrete]
[[AggregationsScriptedMetricAggregate]]
=== AggregationsScriptedMetricAggregate

[source,ts,subs=+macros]
----
interface AggregationsScriptedMetricAggregate extends <<AggregationsAggregateBase>> {
  value: any
}
----


[discrete]
[[AggregationsScriptedMetricAggregation]]
=== AggregationsScriptedMetricAggregation

[source,ts,subs=+macros]
----
interface AggregationsScriptedMetricAggregation extends <<AggregationsMetricAggregationBase>> {
  pass:[/**] @property combine_script Runs once on each shard after document collection is complete. Allows the aggregation to consolidate the state returned from each shard. */
  combine_script?: <<Script>> | string
  pass:[/**] @property init_script Runs prior to any collection of documents. Allows the aggregation to set up any initial state. */
  init_script?: <<Script>> | string
  pass:[/**] @property map_script Run once per document collected. If no `combine_script` is specified, the resulting state needs to be stored in the `state` object. */
  map_script?: <<Script>> | string
  pass:[/**] @property params A global object with script parameters for `init`, `map` and `combine` scripts. It is shared between the scripts. */
  params?: Record<string, any>
  pass:[/**] @property reduce_script Runs once on the coordinating node after all shards have returned their results. The script is provided with access to a variable `states`, which is an array of the result of the `combine_script` on each shard. */
  reduce_script?: <<Script>> | string
}
----


[discrete]
[[AggregationsSerialDifferencingAggregation]]
=== AggregationsSerialDifferencingAggregation

[source,ts,subs=+macros]
----
interface AggregationsSerialDifferencingAggregation extends <<AggregationsPipelineAggregationBase>> {
  pass:[/**] @property lag The historical bucket to subtract from the current value. Must be a positive, non-zero <<integer>>. */
  lag?: <<integer>>
}
----


[discrete]
[[AggregationsSignificantLongTermsAggregate]]
=== AggregationsSignificantLongTermsAggregate

[source,ts,subs=+macros]
----
interface AggregationsSignificantLongTermsAggregate extends <<AggregationsSignificantTermsAggregateBase>><<<AggregationsSignificantLongTermsBucket>>> {}
----


[discrete]
[[AggregationsSignificantLongTermsBucket]]
=== AggregationsSignificantLongTermsBucket

[source,ts,subs=+macros]
----
interface AggregationsSignificantLongTermsBucketKeys extends <<AggregationsSignificantTermsBucketBase>> {
  key: <<long>>
  key_as_string?: string
}
type AggregationsSignificantLongTermsBucket = AggregationsSignificantLongTermsBucketKeys
  & { [property: string]: <<AggregationsAggregate>> | <<long>> | string | <<double>> }
----


[discrete]
[[AggregationsSignificantStringTermsAggregate]]
=== AggregationsSignificantStringTermsAggregate

[source,ts,subs=+macros]
----
interface AggregationsSignificantStringTermsAggregate extends <<AggregationsSignificantTermsAggregateBase>><<<AggregationsSignificantStringTermsBucket>>> {}
----


[discrete]
[[AggregationsSignificantStringTermsBucket]]
=== AggregationsSignificantStringTermsBucket

[source,ts,subs=+macros]
----
interface AggregationsSignificantStringTermsBucketKeys extends <<AggregationsSignificantTermsBucketBase>> {
  key: string
}
type AggregationsSignificantStringTermsBucket = AggregationsSignificantStringTermsBucketKeys
  & { [property: string]: <<AggregationsAggregate>> | string | <<double>> | <<long>> }
----


[discrete]
[[AggregationsSignificantTermsAggregateBase]]
=== AggregationsSignificantTermsAggregateBase

[source,ts,subs=+macros]
----
interface AggregationsSignificantTermsAggregateBase<T = unknown> extends <<AggregationsMultiBucketAggregateBase>><T> {
  bg_count?: <<long>>
  doc_count?: <<long>>
}
----


[discrete]
[[AggregationsSignificantTermsAggregation]]
=== AggregationsSignificantTermsAggregation

[source,ts,subs=+macros]
----
interface AggregationsSignificantTermsAggregation extends <<AggregationsBucketAggregationBase>> {
  pass:[/**] @property background_filter A background filter that can be used to focus in on significant terms within a narrower context, instead of the entire index. */
  background_filter?: <<QueryDslQueryContainer>>
  pass:[/**] @property chi_square Use Chi square, as described in "Information Retrieval", Manning et al., Chapter 13.5.2, as the significance score. */
  chi_square?: <<AggregationsChiSquareHeuristic>>
  pass:[/**] @property exclude Terms to exclude. */
  exclude?: <<AggregationsTermsExclude>>
  pass:[/**] @property execution_hint Mechanism by which the aggregation should be executed: using field values directly or using global ordinals. */
  execution_hint?: <<AggregationsTermsAggregationExecutionHint>>
  pass:[/**] @property field The field from which to return significant terms. */
  field?: <<Field>>
  pass:[/**] @property gnd Use Google normalized distance as described in "The Google Similarity <<Distance>>", Cilibrasi and Vitanyi, 2007, as the significance score. */
  gnd?: <<AggregationsGoogleNormalizedDistanceHeuristic>>
  pass:[/**] @property include Terms to include. */
  include?: <<AggregationsTermsInclude>>
  pass:[/**] @property jlh Use JLH score as the significance score. */
  jlh?: <<EmptyObject>>
  pass:[/**] @property min_doc_count Only return terms that are found in more than `min_doc_count` hits. */
  min_doc_count?: <<long>>
  pass:[/**] @property mutual_information Use mutual information as described in "Information Retrieval", Manning et al., Chapter 13.5.1, as the significance score. */
  mutual_information?: <<AggregationsMutualInformationHeuristic>>
  pass:[/**] @property percentage A simple calculation of the number of documents in the foreground sample with a term divided by the number of documents in the background with the term. */
  percentage?: <<AggregationsPercentageScoreHeuristic>>
  pass:[/**] @property script_heuristic Customized score, implemented via a script. */
  script_heuristic?: <<AggregationsScriptedHeuristic>>
  pass:[/**] @property shard_min_doc_count Regulates the certainty a shard has if the term should actually be added to the candidate list or not with respect to the `min_doc_count`. Terms will only be considered if their local shard frequency within the set is higher than the `shard_min_doc_count`. */
  shard_min_doc_count?: <<long>>
  pass:[/**] @property shard_size Can be used to control the volumes of candidate terms produced by each shard. By default, `shard_size` will be automatically estimated based on the number of shards and the `size` parameter. */
  shard_size?: <<integer>>
  pass:[/**] @property size The number of buckets returned out of the overall terms list. */
  size?: <<integer>>
}
----


[discrete]
[[AggregationsSignificantTermsBucketBase]]
=== AggregationsSignificantTermsBucketBase

[source,ts,subs=+macros]
----
interface AggregationsSignificantTermsBucketBase extends <<AggregationsMultiBucketBase>> {
  score: <<double>>
  bg_count: <<long>>
}
----


[discrete]
[[AggregationsSignificantTextAggregation]]
=== AggregationsSignificantTextAggregation

[source,ts,subs=+macros]
----
interface AggregationsSignificantTextAggregation extends <<AggregationsBucketAggregationBase>> {
  pass:[/**] @property background_filter A background filter that can be used to focus in on significant terms within a narrower context, instead of the entire index. */
  background_filter?: <<QueryDslQueryContainer>>
  pass:[/**] @property chi_square Use Chi square, as described in "Information Retrieval", Manning et al., Chapter 13.5.2, as the significance score. */
  chi_square?: <<AggregationsChiSquareHeuristic>>
  pass:[/**] @property exclude Values to exclude. */
  exclude?: <<AggregationsTermsExclude>>
  pass:[/**] @property execution_hint Determines whether the aggregation will use field values directly or global ordinals. */
  execution_hint?: <<AggregationsTermsAggregationExecutionHint>>
  pass:[/**] @property field The field from which to return significant text. */
  field?: <<Field>>
  pass:[/**] @property filter_duplicate_text Whether to out duplicate text to deal with noisy data. */
  filter_duplicate_text?: boolean
  pass:[/**] @property gnd Use Google normalized distance as described in "The Google Similarity <<Distance>>", Cilibrasi and Vitanyi, 2007, as the significance score. */
  gnd?: <<AggregationsGoogleNormalizedDistanceHeuristic>>
  pass:[/**] @property include Values to include. */
  include?: <<AggregationsTermsInclude>>
  pass:[/**] @property jlh Use JLH score as the significance score. */
  jlh?: <<EmptyObject>>
  pass:[/**] @property min_doc_count Only return values that are found in more than `min_doc_count` hits. */
  min_doc_count?: <<long>>
  pass:[/**] @property mutual_information Use mutual information as described in "Information Retrieval", Manning et al., Chapter 13.5.1, as the significance score. */
  mutual_information?: <<AggregationsMutualInformationHeuristic>>
  pass:[/**] @property percentage A simple calculation of the number of documents in the foreground sample with a term divided by the number of documents in the background with the term. */
  percentage?: <<AggregationsPercentageScoreHeuristic>>
  pass:[/**] @property script_heuristic Customized score, implemented via a script. */
  script_heuristic?: <<AggregationsScriptedHeuristic>>
  pass:[/**] @property shard_min_doc_count Regulates the certainty a shard has if the values should actually be added to the candidate list or not with respect to the min_doc_count. Values will only be considered if their local shard frequency within the set is higher than the `shard_min_doc_count`. */
  shard_min_doc_count?: <<long>>
  pass:[/**] @property shard_size The number of candidate terms produced by each shard. By default, `shard_size` will be automatically estimated based on the number of shards and the `size` parameter. */
  shard_size?: <<integer>>
  pass:[/**] @property size The number of buckets returned out of the overall terms list. */
  size?: <<integer>>
  pass:[/**] @property source_fields Overrides the JSON `_source` fields from which text will be analyzed. */
  source_fields?: <<Fields>>
}
----


[discrete]
[[AggregationsSimpleMovingAverageAggregation]]
=== AggregationsSimpleMovingAverageAggregation

[source,ts,subs=+macros]
----
interface AggregationsSimpleMovingAverageAggregation extends <<AggregationsMovingAverageAggregationBase>> {
  model: 'simple'
  settings: <<EmptyObject>>
}
----


[discrete]
[[AggregationsSimpleValueAggregate]]
=== AggregationsSimpleValueAggregate

[source,ts,subs=+macros]
----
interface AggregationsSimpleValueAggregate extends <<AggregationsSingleMetricAggregateBase>> {}
----


[discrete]
[[AggregationsSingleBucketAggregateBase]]
=== AggregationsSingleBucketAggregateBase

[source,ts,subs=+macros]
----
interface AggregationsSingleBucketAggregateBase extends <<AggregationsAggregateBase>> {
  doc_count: <<long>>
}
----


[discrete]
[[AggregationsSingleMetricAggregateBase]]
=== AggregationsSingleMetricAggregateBase

[source,ts,subs=+macros]
----
interface AggregationsSingleMetricAggregateBase extends <<AggregationsAggregateBase>> {
  pass:[/**] @property value The metric value. A missing value generally means that there was no data to aggregate, unless specified otherwise. */
  value: <<double>> | null
  value_as_string?: string
}
----


[discrete]
[[AggregationsStandardDeviationBounds]]
=== AggregationsStandardDeviationBounds

[source,ts,subs=+macros]
----
interface AggregationsStandardDeviationBounds {
  upper: <<double>> | null
  lower: <<double>> | null
  upper_population: <<double>> | null
  lower_population: <<double>> | null
  upper_sampling: <<double>> | null
  lower_sampling: <<double>> | null
}
----


[discrete]
[[AggregationsStandardDeviationBoundsAsString]]
=== AggregationsStandardDeviationBoundsAsString

[source,ts,subs=+macros]
----
interface AggregationsStandardDeviationBoundsAsString {
  upper: string
  lower: string
  upper_population: string
  lower_population: string
  upper_sampling: string
  lower_sampling: string
}
----


[discrete]
[[AggregationsStatsAggregate]]
=== AggregationsStatsAggregate

[source,ts,subs=+macros]
----
interface AggregationsStatsAggregate extends <<AggregationsAggregateBase>> {
  count: <<long>>
  min: <<double>> | null
  max: <<double>> | null
  avg: <<double>> | null
  sum: <<double>>
  min_as_string?: string
  max_as_string?: string
  avg_as_string?: string
  sum_as_string?: string
}
----


[discrete]
[[AggregationsStatsAggregation]]
=== AggregationsStatsAggregation

[source,ts,subs=+macros]
----
interface AggregationsStatsAggregation extends <<AggregationsFormatMetricAggregationBase>> {}
----


[discrete]
[[AggregationsStatsBucketAggregate]]
=== AggregationsStatsBucketAggregate

[source,ts,subs=+macros]
----
interface AggregationsStatsBucketAggregate extends <<AggregationsStatsAggregate>> {}
----


[discrete]
[[AggregationsStatsBucketAggregation]]
=== AggregationsStatsBucketAggregation

[source,ts,subs=+macros]
----
interface AggregationsStatsBucketAggregation extends <<AggregationsPipelineAggregationBase>> {}
----


[discrete]
[[AggregationsStringRareTermsAggregate]]
=== AggregationsStringRareTermsAggregate

[source,ts,subs=+macros]
----
interface AggregationsStringRareTermsAggregate extends <<AggregationsMultiBucketAggregateBase>><<<AggregationsStringRareTermsBucket>>> {}
----


[discrete]
[[AggregationsStringRareTermsBucket]]
=== AggregationsStringRareTermsBucket

[source,ts,subs=+macros]
----
interface AggregationsStringRareTermsBucketKeys extends <<AggregationsMultiBucketBase>> {
  key: string
}
type AggregationsStringRareTermsBucket = AggregationsStringRareTermsBucketKeys
  & { [property: string]: <<AggregationsAggregate>> | string | <<long>> }
----


[discrete]
[[AggregationsStringStatsAggregate]]
=== AggregationsStringStatsAggregate

[source,ts,subs=+macros]
----
interface AggregationsStringStatsAggregate extends <<AggregationsAggregateBase>> {
  count: <<long>>
  min_length: <<integer>> | null
  max_length: <<integer>> | null
  avg_length: <<double>> | null
  entropy: <<double>> | null
  distribution?: Record<string, <<double>>> | null
  min_length_as_string?: string
  max_length_as_string?: string
  avg_length_as_string?: string
}
----


[discrete]
[[AggregationsStringStatsAggregation]]
=== AggregationsStringStatsAggregation

[source,ts,subs=+macros]
----
interface AggregationsStringStatsAggregation extends <<AggregationsMetricAggregationBase>> {
  pass:[/**] @property show_distribution Shows the probability distribution for all characters. */
  show_distribution?: boolean
}
----


[discrete]
[[AggregationsStringTermsAggregate]]
=== AggregationsStringTermsAggregate

[source,ts,subs=+macros]
----
interface AggregationsStringTermsAggregate extends <<AggregationsTermsAggregateBase>><<<AggregationsStringTermsBucket>>> {}
----


[discrete]
[[AggregationsStringTermsBucket]]
=== AggregationsStringTermsBucket

[source,ts,subs=+macros]
----
interface AggregationsStringTermsBucketKeys extends <<AggregationsTermsBucketBase>> {
  key: <<FieldValue>>
}
type AggregationsStringTermsBucket = AggregationsStringTermsBucketKeys
  & { [property: string]: <<AggregationsAggregate>> | <<FieldValue>> | <<long>> }
----


[discrete]
[[AggregationsSumAggregate]]
=== AggregationsSumAggregate

[source,ts,subs=+macros]
----
interface AggregationsSumAggregate extends <<AggregationsSingleMetricAggregateBase>> {}
----


[discrete]
[[AggregationsSumAggregation]]
=== AggregationsSumAggregation

[source,ts,subs=+macros]
----
interface AggregationsSumAggregation extends <<AggregationsFormatMetricAggregationBase>> {}
----


[discrete]
[[AggregationsSumBucketAggregation]]
=== AggregationsSumBucketAggregation

[source,ts,subs=+macros]
----
interface AggregationsSumBucketAggregation extends <<AggregationsPipelineAggregationBase>> {}
----


[discrete]
[[AggregationsTDigest]]
=== AggregationsTDigest

[source,ts,subs=+macros]
----
interface AggregationsTDigest {
  pass:[/**] @property compression Limits the maximum number of nodes used by the underlying TDigest algorithm to `20 * compression`, enabling control of memory usage and approximation error. */
  compression?: <<integer>>
}
----


[discrete]
[[AggregationsTDigestPercentileRanksAggregate]]
=== AggregationsTDigestPercentileRanksAggregate

[source,ts,subs=+macros]
----
interface AggregationsTDigestPercentileRanksAggregate extends <<AggregationsPercentilesAggregateBase>> {}
----


[discrete]
[[AggregationsTDigestPercentilesAggregate]]
=== AggregationsTDigestPercentilesAggregate

[source,ts,subs=+macros]
----
interface AggregationsTDigestPercentilesAggregate extends <<AggregationsPercentilesAggregateBase>> {}
----


[discrete]
[[AggregationsTTestAggregate]]
=== AggregationsTTestAggregate

[source,ts,subs=+macros]
----
interface AggregationsTTestAggregate extends <<AggregationsAggregateBase>> {
  value: <<double>> | null
  value_as_string?: string
}
----


[discrete]
[[AggregationsTTestAggregation]]
=== AggregationsTTestAggregation

[source,ts,subs=+macros]
----
interface AggregationsTTestAggregation {
  pass:[/**] @property a Test population A. */
  a?: <<AggregationsTestPopulation>>
  pass:[/**] @property b Test population B. */
  b?: <<AggregationsTestPopulation>>
  pass:[/**] @property type The type of test. */
  type?: <<AggregationsTTestType>>
}
----


[discrete]
[[AggregationsTTestType]]
=== AggregationsTTestType

[source,ts,subs=+macros]
----
type AggregationsTTestType = 'paired' | 'homoscedastic' | 'heteroscedastic'
----


[discrete]
[[AggregationsTermsAggregateBase]]
=== AggregationsTermsAggregateBase

[source,ts,subs=+macros]
----
interface AggregationsTermsAggregateBase<TBucket = unknown> extends <<AggregationsMultiBucketAggregateBase>><TBucket> {
  doc_count_error_upper_bound?: <<long>>
  sum_other_doc_count?: <<long>>
}
----


[discrete]
[[AggregationsTermsAggregation]]
=== AggregationsTermsAggregation

[source,ts,subs=+macros]
----
interface AggregationsTermsAggregation extends <<AggregationsBucketAggregationBase>> {
  pass:[/**] @property collect_mode Determines how child aggregations should be calculated: breadth-first or depth-first. */
  collect_mode?: <<AggregationsTermsAggregationCollectMode>>
  pass:[/**] @property exclude Values to exclude. Accepts regular expressions and partitions. */
  exclude?: <<AggregationsTermsExclude>>
  pass:[/**] @property execution_hint Determines whether the aggregation will use field values directly or global ordinals. */
  execution_hint?: <<AggregationsTermsAggregationExecutionHint>>
  pass:[/**] @property field The field from which to return terms. */
  field?: <<Field>>
  pass:[/**] @property include Values to include. Accepts regular expressions and partitions. */
  include?: <<AggregationsTermsInclude>>
  pass:[/**] @property min_doc_count Only return values that are found in more than `min_doc_count` hits. */
  min_doc_count?: <<integer>>
  pass:[/**] @property missing The value to apply to documents that do not have a value. By default, documents without a value are ignored. */
  missing?: <<AggregationsMissing>>
  missing_order?: <<AggregationsMissingOrder>>
  missing_bucket?: boolean
  pass:[/**] @property value_type Coerced unmapped fields into the specified type. */
  value_type?: string
  pass:[/**] @property order Specifies the sort order of the buckets. Defaults to sorting by descending document count. */
  order?: <<AggregationsAggregateOrder>>
  script?: <<Script>> | string
  pass:[/**] @property shard_min_doc_count Regulates the certainty a shard has if the term should actually be added to the candidate list or not with respect to the `min_doc_count`. Terms will only be considered if their local shard frequency within the set is higher than the `shard_min_doc_count`. */
  shard_min_doc_count?: <<long>>
  pass:[/**] @property shard_size The number of candidate terms produced by each shard. By default, `shard_size` will be automatically estimated based on the number of shards and the `size` parameter. */
  shard_size?: <<integer>>
  pass:[/**] @property show_term_doc_count_error Set to `true` to return the `doc_count_error_upper_bound`, which is an upper bound to the error on the `doc_count` returned by each shard. */
  show_term_doc_count_error?: boolean
  pass:[/**] @property size The number of buckets returned out of the overall terms list. */
  size?: <<integer>>
  format?: string
}
----


[discrete]
[[AggregationsTermsAggregationCollectMode]]
=== AggregationsTermsAggregationCollectMode

[source,ts,subs=+macros]
----
type AggregationsTermsAggregationCollectMode = 'depth_first' | 'breadth_first'
----


[discrete]
[[AggregationsTermsAggregationExecutionHint]]
=== AggregationsTermsAggregationExecutionHint

[source,ts,subs=+macros]
----
type AggregationsTermsAggregationExecutionHint = 'map' | 'global_ordinals' | 'global_ordinals_hash' | 'global_ordinals_low_cardinality'
----


[discrete]
[[AggregationsTermsBucketBase]]
=== AggregationsTermsBucketBase

[source,ts,subs=+macros]
----
interface AggregationsTermsBucketBase extends <<AggregationsMultiBucketBase>> {
  doc_count_error_upper_bound?: <<long>>
}
----


[discrete]
[[AggregationsTermsExclude]]
=== AggregationsTermsExclude

[source,ts,subs=+macros]
----
type AggregationsTermsExclude = string | string[]
----


[discrete]
[[AggregationsTermsInclude]]
=== AggregationsTermsInclude

[source,ts,subs=+macros]
----
type AggregationsTermsInclude = string | string[] | <<AggregationsTermsPartition>>
----


[discrete]
[[AggregationsTermsPartition]]
=== AggregationsTermsPartition

[source,ts,subs=+macros]
----
interface AggregationsTermsPartition {
  pass:[/**] @property num_partitions The number of partitions. */
  num_partitions: <<long>>
  pass:[/**] @property partition The partition number for this request. */
  partition: <<long>>
}
----


[discrete]
[[AggregationsTestPopulation]]
=== AggregationsTestPopulation

[source,ts,subs=+macros]
----
interface AggregationsTestPopulation {
  pass:[/**] @property field The field to aggregate. */
  field: <<Field>>
  script?: <<Script>> | string
  pass:[/**] @property filter A filter used to define a set of records to run unpaired t-test on. */
  filter?: <<QueryDslQueryContainer>>
}
----


[discrete]
[[AggregationsTimeSeriesAggregate]]
=== AggregationsTimeSeriesAggregate

[source,ts,subs=+macros]
----
interface AggregationsTimeSeriesAggregate extends <<AggregationsMultiBucketAggregateBase>><<<AggregationsTimeSeriesBucket>>> {}
----


[discrete]
[[AggregationsTimeSeriesAggregation]]
=== AggregationsTimeSeriesAggregation

[source,ts,subs=+macros]
----
interface AggregationsTimeSeriesAggregation extends <<AggregationsBucketAggregationBase>> {
  pass:[/**] @property size The maximum number of results to return. */
  size?: <<integer>>
  pass:[/**] @property keyed Set to `true` to associate a unique string key with each bucket and returns the ranges as a hash rather than an array. */
  keyed?: boolean
}
----


[discrete]
[[AggregationsTimeSeriesBucket]]
=== AggregationsTimeSeriesBucket

[source,ts,subs=+macros]
----
interface AggregationsTimeSeriesBucketKeys extends <<AggregationsMultiBucketBase>> {
  key: Record<<<Field>>, <<FieldValue>>>
}
type AggregationsTimeSeriesBucket = AggregationsTimeSeriesBucketKeys
  & { [property: string]: <<AggregationsAggregate>> | Record<<<Field>>, <<FieldValue>>> | <<long>> }
----


[discrete]
[[AggregationsTopHitsAggregate]]
=== AggregationsTopHitsAggregate

[source,ts,subs=+macros]
----
interface AggregationsTopHitsAggregate extends <<AggregationsAggregateBase>> {
  hits: <<SearchHitsMetadata>><any>
}
----


[discrete]
[[AggregationsTopHitsAggregation]]
=== AggregationsTopHitsAggregation

[source,ts,subs=+macros]
----
interface AggregationsTopHitsAggregation extends <<AggregationsMetricAggregationBase>> {
  pass:[/**] @property docvalue_fields <<Fields>> for which to return doc values. */
  docvalue_fields?: (<<QueryDslFieldAndFormat>> | <<Field>>)[]
  pass:[/**] @property explain If `true`, returns detailed information about score computation as part of a hit. */
  explain?: boolean
  pass:[/**] @property fields Array of wildcard (*) patterns. The request returns values for field names matching these patterns in the hits.fields property of the response. */
  fields?: (<<QueryDslFieldAndFormat>> | <<Field>>)[]
  pass:[/**] @property from Starting document offset. */
  from?: <<integer>>
  pass:[/**] @property highlight Specifies the highlighter to use for retrieving highlighted snippets from one or more fields in the search results. */
  highlight?: <<SearchHighlight>>
  pass:[/**] @property script_fields Returns the result of one or more script evaluations for each hit. */
  script_fields?: Record<string, <<ScriptField>>>
  pass:[/**] @property size The maximum number of top matching hits to return per bucket. */
  size?: <<integer>>
  pass:[/**] @property sort <<Sort>> order of the top matching hits. By default, the hits are sorted by the score of the main query. */
  sort?: <<Sort>>
  pass:[/**] @property _source Selects the fields of the source that are returned. */
  _source?: <<SearchSourceConfig>>
  pass:[/**] @property stored_fields Returns values for the specified stored fields (fields that use the `store` mapping option). */
  stored_fields?: <<Fields>>
  pass:[/**] @property track_scores If `true`, calculates and returns document scores, even if the scores are not used for sorting. */
  track_scores?: boolean
  pass:[/**] @property version If `true`, returns document version as part of a hit. */
  version?: boolean
  pass:[/**] @property seq_no_primary_term If `true`, returns sequence number and primary term of the last modification of each hit. */
  seq_no_primary_term?: boolean
}
----


[discrete]
[[AggregationsTopMetrics]]
=== AggregationsTopMetrics

[source,ts,subs=+macros]
----
interface AggregationsTopMetrics {
  sort: (<<FieldValue>> | null)[]
  metrics: Record<string, <<FieldValue>> | null>
}
----


[discrete]
[[AggregationsTopMetricsAggregate]]
=== AggregationsTopMetricsAggregate

[source,ts,subs=+macros]
----
interface AggregationsTopMetricsAggregate extends <<AggregationsAggregateBase>> {
  top: <<AggregationsTopMetrics>>[]
}
----


[discrete]
[[AggregationsTopMetricsAggregation]]
=== AggregationsTopMetricsAggregation

[source,ts,subs=+macros]
----
interface AggregationsTopMetricsAggregation extends <<AggregationsMetricAggregationBase>> {
  pass:[/**] @property metrics The fields of the top document to return. */
  metrics?: <<AggregationsTopMetricsValue>> | <<AggregationsTopMetricsValue>>[]
  pass:[/**] @property size The number of top documents from which to return metrics. */
  size?: <<integer>>
  pass:[/**] @property sort The sort order of the documents. */
  sort?: <<Sort>>
}
----


[discrete]
[[AggregationsTopMetricsValue]]
=== AggregationsTopMetricsValue

[source,ts,subs=+macros]
----
interface AggregationsTopMetricsValue {
  pass:[/**] @property field A field to return as a metric. */
  field: <<Field>>
}
----


[discrete]
[[AggregationsUnmappedRareTermsAggregate]]
=== AggregationsUnmappedRareTermsAggregate

[source,ts,subs=+macros]
----
interface AggregationsUnmappedRareTermsAggregate extends <<AggregationsMultiBucketAggregateBase>><void> {}
----


[discrete]
[[AggregationsUnmappedSamplerAggregate]]
=== AggregationsUnmappedSamplerAggregate

[source,ts,subs=+macros]
----
interface AggregationsUnmappedSamplerAggregateKeys extends <<AggregationsSingleBucketAggregateBase>> {}
type AggregationsUnmappedSamplerAggregate = AggregationsUnmappedSamplerAggregateKeys
  & { [property: string]: <<AggregationsAggregate>> | <<long>> | <<Metadata>> }
----


[discrete]
[[AggregationsUnmappedSignificantTermsAggregate]]
=== AggregationsUnmappedSignificantTermsAggregate

[source,ts,subs=+macros]
----
interface AggregationsUnmappedSignificantTermsAggregate extends <<AggregationsSignificantTermsAggregateBase>><void> {}
----


[discrete]
[[AggregationsUnmappedTermsAggregate]]
=== AggregationsUnmappedTermsAggregate

[source,ts,subs=+macros]
----
interface AggregationsUnmappedTermsAggregate extends <<AggregationsTermsAggregateBase>><void> {}
----


[discrete]
[[AggregationsValueCountAggregate]]
=== AggregationsValueCountAggregate

[source,ts,subs=+macros]
----
interface AggregationsValueCountAggregate extends <<AggregationsSingleMetricAggregateBase>> {}
----


[discrete]
[[AggregationsValueCountAggregation]]
=== AggregationsValueCountAggregation

[source,ts,subs=+macros]
----
interface AggregationsValueCountAggregation extends <<AggregationsFormattableMetricAggregation>> {}
----


[discrete]
[[AggregationsValueType]]
=== AggregationsValueType

[source,ts,subs=+macros]
----
type AggregationsValueType = 'string' | '<<long>>' | '<<double>>' | 'number' | 'date' | 'date_nanos' | 'ip' | 'numeric' | 'geo_point' | 'boolean'
----


[discrete]
[[AggregationsVariableWidthHistogramAggregate]]
=== AggregationsVariableWidthHistogramAggregate

[source,ts,subs=+macros]
----
interface AggregationsVariableWidthHistogramAggregate extends <<AggregationsMultiBucketAggregateBase>><<<AggregationsVariableWidthHistogramBucket>>> {}
----


[discrete]
[[AggregationsVariableWidthHistogramAggregation]]
=== AggregationsVariableWidthHistogramAggregation

[source,ts,subs=+macros]
----
interface AggregationsVariableWidthHistogramAggregation {
  pass:[/**] @property field The name of the field. */
  field?: <<Field>>
  pass:[/**] @property buckets The target number of buckets. */
  buckets?: <<integer>>
  pass:[/**] @property shard_size The number of buckets that the coordinating node will request from each shard. Defaults to `buckets * 50`. */
  shard_size?: <<integer>>
  pass:[/**] @property initial_buffer Specifies the number of individual documents that will be stored in memory on a shard before the initial bucketing algorithm is run. Defaults to `min(10 * shard_size, 50000)`. */
  initial_buffer?: <<integer>>
  script?: <<Script>> | string
}
----


[discrete]
[[AggregationsVariableWidthHistogramBucket]]
=== AggregationsVariableWidthHistogramBucket

[source,ts,subs=+macros]
----
interface AggregationsVariableWidthHistogramBucketKeys extends <<AggregationsMultiBucketBase>> {
  min: <<double>>
  key: <<double>>
  max: <<double>>
  min_as_string?: string
  key_as_string?: string
  max_as_string?: string
}
type AggregationsVariableWidthHistogramBucket = AggregationsVariableWidthHistogramBucketKeys
  & { [property: string]: <<AggregationsAggregate>> | <<double>> | string | <<long>> }
----


[discrete]
[[AggregationsWeightedAverageAggregation]]
=== AggregationsWeightedAverageAggregation

[source,ts,subs=+macros]
----
interface AggregationsWeightedAverageAggregation {
  pass:[/**] @property format A numeric response formatter. */
  format?: string
  pass:[/**] @property value Configuration for the field that provides the values. */
  value?: <<AggregationsWeightedAverageValue>>
  value_type?: <<AggregationsValueType>>
  pass:[/**] @property weight Configuration for the field or script that provides the weights. */
  weight?: <<AggregationsWeightedAverageValue>>
}
----


[discrete]
[[AggregationsWeightedAverageValue]]
=== AggregationsWeightedAverageValue

[source,ts,subs=+macros]
----
interface AggregationsWeightedAverageValue {
  pass:[/**] @property field The field from which to extract the values or weights. */
  field?: <<Field>>
  pass:[/**] @property missing A value or weight to use if the field is missing. */
  missing?: <<double>>
  script?: <<Script>> | string
}
----


[discrete]
[[AggregationsWeightedAvgAggregate]]
=== AggregationsWeightedAvgAggregate

[source,ts,subs=+macros]
----
interface AggregationsWeightedAvgAggregate extends <<AggregationsSingleMetricAggregateBase>> {}
----


[discrete]
[[AnalysisAnalyzer]]
=== AnalysisAnalyzer

[source,ts,subs=+macros]
----
type AnalysisAnalyzer = <<AnalysisCustomAnalyzer>> | <<AnalysisFingerprintAnalyzer>> | <<AnalysisKeywordAnalyzer>> | <<AnalysisLanguageAnalyzer>> | <<AnalysisNoriAnalyzer>> | <<AnalysisPatternAnalyzer>> | <<AnalysisSimpleAnalyzer>> | <<AnalysisStandardAnalyzer>> | <<AnalysisStopAnalyzer>> | <<AnalysisWhitespaceAnalyzer>> | <<AnalysisIcuAnalyzer>> | <<AnalysisKuromojiAnalyzer>> | <<AnalysisSnowballAnalyzer>> | <<AnalysisArabicAnalyzer>> | <<AnalysisArmenianAnalyzer>> | <<AnalysisBasqueAnalyzer>> | <<AnalysisBengaliAnalyzer>> | <<AnalysisBrazilianAnalyzer>> | <<AnalysisBulgarianAnalyzer>> | <<AnalysisCatalanAnalyzer>> | <<AnalysisChineseAnalyzer>> | <<AnalysisCjkAnalyzer>> | <<AnalysisCzechAnalyzer>> | <<AnalysisDanishAnalyzer>> | <<AnalysisDutchAnalyzer>> | <<AnalysisEnglishAnalyzer>> | <<AnalysisEstonianAnalyzer>> | <<AnalysisFinnishAnalyzer>> | <<AnalysisFrenchAnalyzer>> | <<AnalysisGalicianAnalyzer>> | <<AnalysisGermanAnalyzer>> | <<AnalysisGreekAnalyzer>> | <<AnalysisHindiAnalyzer>> | <<AnalysisHungarianAnalyzer>> | <<AnalysisIndonesianAnalyzer>> | <<AnalysisIrishAnalyzer>> | <<AnalysisItalianAnalyzer>> | <<AnalysisLatvianAnalyzer>> | <<AnalysisLithuanianAnalyzer>> | <<AnalysisNorwegianAnalyzer>> | <<AnalysisPersianAnalyzer>> | <<AnalysisPortugueseAnalyzer>> | <<AnalysisRomanianAnalyzer>> | <<AnalysisRussianAnalyzer>> | <<AnalysisSerbianAnalyzer>> | <<AnalysisSoraniAnalyzer>> | <<AnalysisSpanishAnalyzer>> | <<AnalysisSwedishAnalyzer>> | <<AnalysisTurkishAnalyzer>> | <<AnalysisThaiAnalyzer>>
----


[discrete]
[[AnalysisArabicAnalyzer]]
=== AnalysisArabicAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisArabicAnalyzer {
  type: 'arabic'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
  stem_exclusion?: string[]
}
----


[discrete]
[[AnalysisArmenianAnalyzer]]
=== AnalysisArmenianAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisArmenianAnalyzer {
  type: 'armenian'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
  stem_exclusion?: string[]
}
----


[discrete]
[[AnalysisAsciiFoldingTokenFilter]]
=== AnalysisAsciiFoldingTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisAsciiFoldingTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'asciifolding'
  preserve_original?: <<SpecUtilsStringified>><boolean>
}
----


[discrete]
[[AnalysisBasqueAnalyzer]]
=== AnalysisBasqueAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisBasqueAnalyzer {
  type: 'basque'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
  stem_exclusion?: string[]
}
----


[discrete]
[[AnalysisBengaliAnalyzer]]
=== AnalysisBengaliAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisBengaliAnalyzer {
  type: 'bengali'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
  stem_exclusion?: string[]
}
----


[discrete]
[[AnalysisBrazilianAnalyzer]]
=== AnalysisBrazilianAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisBrazilianAnalyzer {
  type: 'brazilian'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
}
----


[discrete]
[[AnalysisBulgarianAnalyzer]]
=== AnalysisBulgarianAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisBulgarianAnalyzer {
  type: 'bulgarian'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
  stem_exclusion?: string[]
}
----


[discrete]
[[AnalysisCatalanAnalyzer]]
=== AnalysisCatalanAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisCatalanAnalyzer {
  type: 'catalan'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
  stem_exclusion?: string[]
}
----


[discrete]
[[AnalysisCharFilter]]
=== AnalysisCharFilter

[source,ts,subs=+macros]
----
type AnalysisCharFilter = string | <<AnalysisCharFilterDefinition>>
----


[discrete]
[[AnalysisCharFilterBase]]
=== AnalysisCharFilterBase

[source,ts,subs=+macros]
----
interface AnalysisCharFilterBase {
  version?: <<VersionString>>
}
----


[discrete]
[[AnalysisCharFilterDefinition]]
=== AnalysisCharFilterDefinition

[source,ts,subs=+macros]
----
type AnalysisCharFilterDefinition = <<AnalysisHtmlStripCharFilter>> | <<AnalysisMappingCharFilter>> | <<AnalysisPatternReplaceCharFilter>> | <<AnalysisIcuNormalizationCharFilter>> | <<AnalysisKuromojiIterationMarkCharFilter>>
----


[discrete]
[[AnalysisCharGroupTokenizer]]
=== AnalysisCharGroupTokenizer

[source,ts,subs=+macros]
----
interface AnalysisCharGroupTokenizer extends <<AnalysisTokenizerBase>> {
  type: 'char_group'
  tokenize_on_chars: string[]
  max_token_length?: <<integer>>
}
----


[discrete]
[[AnalysisChineseAnalyzer]]
=== AnalysisChineseAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisChineseAnalyzer {
  type: 'chinese'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
}
----


[discrete]
[[AnalysisCjkAnalyzer]]
=== AnalysisCjkAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisCjkAnalyzer {
  type: 'cjk'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
}
----


[discrete]
[[AnalysisClassicTokenizer]]
=== AnalysisClassicTokenizer

[source,ts,subs=+macros]
----
interface AnalysisClassicTokenizer extends <<AnalysisTokenizerBase>> {
  type: 'classic'
  max_token_length?: <<integer>>
}
----


[discrete]
[[AnalysisCommonGramsTokenFilter]]
=== AnalysisCommonGramsTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisCommonGramsTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'common_grams'
  common_words?: string[]
  common_words_path?: string
  ignore_case?: boolean
  query_mode?: boolean
}
----


[discrete]
[[AnalysisCompoundWordTokenFilterBase]]
=== AnalysisCompoundWordTokenFilterBase

[source,ts,subs=+macros]
----
interface AnalysisCompoundWordTokenFilterBase extends <<AnalysisTokenFilterBase>> {
  hyphenation_patterns_path?: string
  max_subword_size?: <<integer>>
  min_subword_size?: <<integer>>
  min_word_size?: <<integer>>
  only_longest_match?: boolean
  word_list?: string[]
  word_list_path?: string
}
----


[discrete]
[[AnalysisConditionTokenFilter]]
=== AnalysisConditionTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisConditionTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'condition'
  filter: string[]
  script: <<Script>> | string
}
----


[discrete]
[[AnalysisCustomAnalyzer]]
=== AnalysisCustomAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisCustomAnalyzer {
  type: 'custom'
  char_filter?: string | string[]
  filter?: string | string[]
  position_increment_gap?: <<integer>>
  position_offset_gap?: <<integer>>
  tokenizer: string
}
----


[discrete]
[[AnalysisCustomNormalizer]]
=== AnalysisCustomNormalizer

[source,ts,subs=+macros]
----
interface AnalysisCustomNormalizer {
  type: 'custom'
  char_filter?: string[]
  filter?: string[]
}
----


[discrete]
[[AnalysisCzechAnalyzer]]
=== AnalysisCzechAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisCzechAnalyzer {
  type: 'czech'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
  stem_exclusion?: string[]
}
----


[discrete]
[[AnalysisDanishAnalyzer]]
=== AnalysisDanishAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisDanishAnalyzer {
  type: 'danish'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
}
----


[discrete]
[[AnalysisDelimitedPayloadEncoding]]
=== AnalysisDelimitedPayloadEncoding

[source,ts,subs=+macros]
----
type AnalysisDelimitedPayloadEncoding = 'int' | '<<float>>' | 'identity'
----


[discrete]
[[AnalysisDelimitedPayloadTokenFilter]]
=== AnalysisDelimitedPayloadTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisDelimitedPayloadTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'delimited_payload'
  delimiter?: string
  encoding?: <<AnalysisDelimitedPayloadEncoding>>
}
----


[discrete]
[[AnalysisDictionaryDecompounderTokenFilter]]
=== AnalysisDictionaryDecompounderTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisDictionaryDecompounderTokenFilter extends <<AnalysisCompoundWordTokenFilterBase>> {
  type: 'dictionary_decompounder'
}
----


[discrete]
[[AnalysisDutchAnalyzer]]
=== AnalysisDutchAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisDutchAnalyzer {
  type: 'dutch'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
  stem_exclusion?: string[]
}
----


[discrete]
[[AnalysisEdgeNGramSide]]
=== AnalysisEdgeNGramSide

[source,ts,subs=+macros]
----
type AnalysisEdgeNGramSide = 'front' | 'back'
----


[discrete]
[[AnalysisEdgeNGramTokenFilter]]
=== AnalysisEdgeNGramTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisEdgeNGramTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'edge_ngram'
  max_gram?: <<integer>>
  min_gram?: <<integer>>
  side?: <<AnalysisEdgeNGramSide>>
  preserve_original?: <<SpecUtilsStringified>><boolean>
}
----


[discrete]
[[AnalysisEdgeNGramTokenizer]]
=== AnalysisEdgeNGramTokenizer

[source,ts,subs=+macros]
----
interface AnalysisEdgeNGramTokenizer extends <<AnalysisTokenizerBase>> {
  type: 'edge_ngram'
  custom_token_chars?: string
  max_gram?: <<integer>>
  min_gram?: <<integer>>
  token_chars?: <<AnalysisTokenChar>>[]
}
----


[discrete]
[[AnalysisElisionTokenFilter]]
=== AnalysisElisionTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisElisionTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'elision'
  articles?: string[]
  articles_path?: string
  articles_case?: <<SpecUtilsStringified>><boolean>
}
----


[discrete]
[[AnalysisEnglishAnalyzer]]
=== AnalysisEnglishAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisEnglishAnalyzer {
  type: 'english'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
  stem_exclusion?: string[]
}
----


[discrete]
[[AnalysisEstonianAnalyzer]]
=== AnalysisEstonianAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisEstonianAnalyzer {
  type: 'estonian'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
}
----


[discrete]
[[AnalysisFingerprintAnalyzer]]
=== AnalysisFingerprintAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisFingerprintAnalyzer {
  type: 'fingerprint'
  version?: <<VersionString>>
  max_output_size: <<integer>>
  preserve_original: boolean
  separator: string
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
}
----


[discrete]
[[AnalysisFingerprintTokenFilter]]
=== AnalysisFingerprintTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisFingerprintTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'fingerprint'
  max_output_size?: <<integer>>
  separator?: string
}
----


[discrete]
[[AnalysisFinnishAnalyzer]]
=== AnalysisFinnishAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisFinnishAnalyzer {
  type: 'finnish'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
  stem_exclusion?: string[]
}
----


[discrete]
[[AnalysisFrenchAnalyzer]]
=== AnalysisFrenchAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisFrenchAnalyzer {
  type: 'french'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
  stem_exclusion?: string[]
}
----


[discrete]
[[AnalysisGalicianAnalyzer]]
=== AnalysisGalicianAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisGalicianAnalyzer {
  type: 'galician'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
  stem_exclusion?: string[]
}
----


[discrete]
[[AnalysisGermanAnalyzer]]
=== AnalysisGermanAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisGermanAnalyzer {
  type: 'german'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
  stem_exclusion?: string[]
}
----


[discrete]
[[AnalysisGreekAnalyzer]]
=== AnalysisGreekAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisGreekAnalyzer {
  type: 'greek'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
}
----


[discrete]
[[AnalysisHindiAnalyzer]]
=== AnalysisHindiAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisHindiAnalyzer {
  type: 'hindi'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
  stem_exclusion?: string[]
}
----


[discrete]
[[AnalysisHtmlStripCharFilter]]
=== AnalysisHtmlStripCharFilter

[source,ts,subs=+macros]
----
interface AnalysisHtmlStripCharFilter extends <<AnalysisCharFilterBase>> {
  type: 'html_strip'
  escaped_tags?: string[]
}
----


[discrete]
[[AnalysisHungarianAnalyzer]]
=== AnalysisHungarianAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisHungarianAnalyzer {
  type: 'hungarian'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
  stem_exclusion?: string[]
}
----


[discrete]
[[AnalysisHunspellTokenFilter]]
=== AnalysisHunspellTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisHunspellTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'hunspell'
  dedup?: boolean
  dictionary?: string
  locale: string
  longest_only?: boolean
}
----


[discrete]
[[AnalysisHyphenationDecompounderTokenFilter]]
=== AnalysisHyphenationDecompounderTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisHyphenationDecompounderTokenFilter extends <<AnalysisCompoundWordTokenFilterBase>> {
  type: 'hyphenation_decompounder'
}
----


[discrete]
[[AnalysisIcuAnalyzer]]
=== AnalysisIcuAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisIcuAnalyzer {
  type: 'icu_analyzer'
  method: <<AnalysisIcuNormalizationType>>
  mode: <<AnalysisIcuNormalizationMode>>
}
----


[discrete]
[[AnalysisIcuCollationAlternate]]
=== AnalysisIcuCollationAlternate

[source,ts,subs=+macros]
----
type AnalysisIcuCollationAlternate = 'shifted' | 'non-ignorable'
----


[discrete]
[[AnalysisIcuCollationCaseFirst]]
=== AnalysisIcuCollationCaseFirst

[source,ts,subs=+macros]
----
type AnalysisIcuCollationCaseFirst = 'lower' | 'upper'
----


[discrete]
[[AnalysisIcuCollationDecomposition]]
=== AnalysisIcuCollationDecomposition

[source,ts,subs=+macros]
----
type AnalysisIcuCollationDecomposition = 'no' | 'identical'
----


[discrete]
[[AnalysisIcuCollationStrength]]
=== AnalysisIcuCollationStrength

[source,ts,subs=+macros]
----
type AnalysisIcuCollationStrength = 'primary' | 'secondary' | 'tertiary' | 'quaternary' | 'identical'
----


[discrete]
[[AnalysisIcuCollationTokenFilter]]
=== AnalysisIcuCollationTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisIcuCollationTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'icu_collation'
  alternate?: <<AnalysisIcuCollationAlternate>>
  case_first?: <<AnalysisIcuCollationCaseFirst>>
  case_level?: boolean
  country?: string
  decomposition?: <<AnalysisIcuCollationDecomposition>>
  hiragana_quaternary_mode?: boolean
  language?: string
  numeric?: boolean
  rules?: string
  strength?: <<AnalysisIcuCollationStrength>>
  variable_top?: string
  variant?: string
}
----


[discrete]
[[AnalysisIcuFoldingTokenFilter]]
=== AnalysisIcuFoldingTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisIcuFoldingTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'icu_folding'
  unicode_set_filter: string
}
----


[discrete]
[[AnalysisIcuNormalizationCharFilter]]
=== AnalysisIcuNormalizationCharFilter

[source,ts,subs=+macros]
----
interface AnalysisIcuNormalizationCharFilter extends <<AnalysisCharFilterBase>> {
  type: 'icu_normalizer'
  mode?: <<AnalysisIcuNormalizationMode>>
  name?: <<AnalysisIcuNormalizationType>>
}
----


[discrete]
[[AnalysisIcuNormalizationMode]]
=== AnalysisIcuNormalizationMode

[source,ts,subs=+macros]
----
type AnalysisIcuNormalizationMode = 'decompose' | 'compose'
----


[discrete]
[[AnalysisIcuNormalizationTokenFilter]]
=== AnalysisIcuNormalizationTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisIcuNormalizationTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'icu_normalizer'
  name: <<AnalysisIcuNormalizationType>>
}
----


[discrete]
[[AnalysisIcuNormalizationType]]
=== AnalysisIcuNormalizationType

[source,ts,subs=+macros]
----
type AnalysisIcuNormalizationType = 'nfc' | 'nfkc' | 'nfkc_cf'
----


[discrete]
[[AnalysisIcuTokenizer]]
=== AnalysisIcuTokenizer

[source,ts,subs=+macros]
----
interface AnalysisIcuTokenizer extends <<AnalysisTokenizerBase>> {
  type: 'icu_tokenizer'
  rule_files: string
}
----


[discrete]
[[AnalysisIcuTransformDirection]]
=== AnalysisIcuTransformDirection

[source,ts,subs=+macros]
----
type AnalysisIcuTransformDirection = 'forward' | 'reverse'
----


[discrete]
[[AnalysisIcuTransformTokenFilter]]
=== AnalysisIcuTransformTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisIcuTransformTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'icu_transform'
  dir?: <<AnalysisIcuTransformDirection>>
  id: string
}
----


[discrete]
[[AnalysisIndonesianAnalyzer]]
=== AnalysisIndonesianAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisIndonesianAnalyzer {
  type: 'indonesian'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
  stem_exclusion?: string[]
}
----


[discrete]
[[AnalysisIrishAnalyzer]]
=== AnalysisIrishAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisIrishAnalyzer {
  type: 'irish'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
  stem_exclusion?: string[]
}
----


[discrete]
[[AnalysisItalianAnalyzer]]
=== AnalysisItalianAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisItalianAnalyzer {
  type: 'italian'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
  stem_exclusion?: string[]
}
----


[discrete]
[[AnalysisKStemTokenFilter]]
=== AnalysisKStemTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisKStemTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'kstem'
}
----


[discrete]
[[AnalysisKeepTypesMode]]
=== AnalysisKeepTypesMode

[source,ts,subs=+macros]
----
type AnalysisKeepTypesMode = 'include' | 'exclude'
----


[discrete]
[[AnalysisKeepTypesTokenFilter]]
=== AnalysisKeepTypesTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisKeepTypesTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'keep_types'
  mode?: <<AnalysisKeepTypesMode>>
  types?: string[]
}
----


[discrete]
[[AnalysisKeepWordsTokenFilter]]
=== AnalysisKeepWordsTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisKeepWordsTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'keep'
  keep_words?: string[]
  keep_words_case?: boolean
  keep_words_path?: string
}
----


[discrete]
[[AnalysisKeywordAnalyzer]]
=== AnalysisKeywordAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisKeywordAnalyzer {
  type: 'keyword'
  version?: <<VersionString>>
}
----


[discrete]
[[AnalysisKeywordMarkerTokenFilter]]
=== AnalysisKeywordMarkerTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisKeywordMarkerTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'keyword_marker'
  ignore_case?: boolean
  keywords?: string | string[]
  keywords_path?: string
  keywords_pattern?: string
}
----


[discrete]
[[AnalysisKeywordTokenizer]]
=== AnalysisKeywordTokenizer

[source,ts,subs=+macros]
----
interface AnalysisKeywordTokenizer extends <<AnalysisTokenizerBase>> {
  type: 'keyword'
  buffer_size?: <<integer>>
}
----


[discrete]
[[AnalysisKuromojiAnalyzer]]
=== AnalysisKuromojiAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisKuromojiAnalyzer {
  type: 'kuromoji'
  mode: <<AnalysisKuromojiTokenizationMode>>
  user_dictionary?: string
}
----


[discrete]
[[AnalysisKuromojiIterationMarkCharFilter]]
=== AnalysisKuromojiIterationMarkCharFilter

[source,ts,subs=+macros]
----
interface AnalysisKuromojiIterationMarkCharFilter extends <<AnalysisCharFilterBase>> {
  type: 'kuromoji_iteration_mark'
  normalize_kana: boolean
  normalize_kanji: boolean
}
----


[discrete]
[[AnalysisKuromojiPartOfSpeechTokenFilter]]
=== AnalysisKuromojiPartOfSpeechTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisKuromojiPartOfSpeechTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'kuromoji_part_of_speech'
  stoptags: string[]
}
----


[discrete]
[[AnalysisKuromojiReadingFormTokenFilter]]
=== AnalysisKuromojiReadingFormTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisKuromojiReadingFormTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'kuromoji_readingform'
  use_romaji: boolean
}
----


[discrete]
[[AnalysisKuromojiStemmerTokenFilter]]
=== AnalysisKuromojiStemmerTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisKuromojiStemmerTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'kuromoji_stemmer'
  minimum_length: <<integer>>
}
----


[discrete]
[[AnalysisKuromojiTokenizationMode]]
=== AnalysisKuromojiTokenizationMode

[source,ts,subs=+macros]
----
type AnalysisKuromojiTokenizationMode = 'normal' | 'search' | 'extended'
----


[discrete]
[[AnalysisKuromojiTokenizer]]
=== AnalysisKuromojiTokenizer

[source,ts,subs=+macros]
----
interface AnalysisKuromojiTokenizer extends <<AnalysisTokenizerBase>> {
  type: 'kuromoji_tokenizer'
  discard_punctuation?: boolean
  mode: <<AnalysisKuromojiTokenizationMode>>
  nbest_cost?: <<integer>>
  nbest_examples?: string
  user_dictionary?: string
  user_dictionary_rules?: string[]
  discard_compound_token?: boolean
}
----


[discrete]
[[AnalysisLanguage]]
=== AnalysisLanguage

[source,ts,subs=+macros]
----
type AnalysisLanguage = 'Arabic' | 'Armenian' | 'Basque' | 'Brazilian' | 'Bulgarian' | 'Catalan' | 'Chinese' | 'Cjk' | 'Czech' | 'Danish' | 'Dutch' | 'English' | 'Estonian' | 'Finnish' | 'French' | 'Galician' | 'German' | 'Greek' | 'Hindi' | 'Hungarian' | 'Indonesian' | 'Irish' | 'Italian' | 'Latvian' | 'Norwegian' | 'Persian' | 'Portuguese' | 'Romanian' | 'Russian' | 'Sorani' | 'Spanish' | 'Swedish' | 'Turkish' | 'Thai'
----


[discrete]
[[AnalysisLanguageAnalyzer]]
=== AnalysisLanguageAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisLanguageAnalyzer {
  type: 'language'
  version?: <<VersionString>>
  language: <<AnalysisLanguage>>
  stem_exclusion: string[]
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
}
----


[discrete]
[[AnalysisLatvianAnalyzer]]
=== AnalysisLatvianAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisLatvianAnalyzer {
  type: 'latvian'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
  stem_exclusion?: string[]
}
----


[discrete]
[[AnalysisLengthTokenFilter]]
=== AnalysisLengthTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisLengthTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'length'
  max?: <<integer>>
  min?: <<integer>>
}
----


[discrete]
[[AnalysisLetterTokenizer]]
=== AnalysisLetterTokenizer

[source,ts,subs=+macros]
----
interface AnalysisLetterTokenizer extends <<AnalysisTokenizerBase>> {
  type: 'letter'
}
----


[discrete]
[[AnalysisLimitTokenCountTokenFilter]]
=== AnalysisLimitTokenCountTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisLimitTokenCountTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'limit'
  consume_all_tokens?: boolean
  max_token_count?: <<SpecUtilsStringified>><<<integer>>>
}
----


[discrete]
[[AnalysisLithuanianAnalyzer]]
=== AnalysisLithuanianAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisLithuanianAnalyzer {
  type: 'lithuanian'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
  stem_exclusion?: string[]
}
----


[discrete]
[[AnalysisLowercaseNormalizer]]
=== AnalysisLowercaseNormalizer

[source,ts,subs=+macros]
----
interface AnalysisLowercaseNormalizer {
  type: 'lowercase'
}
----


[discrete]
[[AnalysisLowercaseTokenFilter]]
=== AnalysisLowercaseTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisLowercaseTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'lowercase'
  language?: string
}
----


[discrete]
[[AnalysisLowercaseTokenizer]]
=== AnalysisLowercaseTokenizer

[source,ts,subs=+macros]
----
interface AnalysisLowercaseTokenizer extends <<AnalysisTokenizerBase>> {
  type: 'lowercase'
}
----


[discrete]
[[AnalysisMappingCharFilter]]
=== AnalysisMappingCharFilter

[source,ts,subs=+macros]
----
interface AnalysisMappingCharFilter extends <<AnalysisCharFilterBase>> {
  type: 'mapping'
  mappings?: string[]
  mappings_path?: string
}
----


[discrete]
[[AnalysisMultiplexerTokenFilter]]
=== AnalysisMultiplexerTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisMultiplexerTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'multiplexer'
  filters: string[]
  preserve_original?: <<SpecUtilsStringified>><boolean>
}
----


[discrete]
[[AnalysisNGramTokenFilter]]
=== AnalysisNGramTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisNGramTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'ngram'
  max_gram?: <<integer>>
  min_gram?: <<integer>>
  preserve_original?: <<SpecUtilsStringified>><boolean>
}
----


[discrete]
[[AnalysisNGramTokenizer]]
=== AnalysisNGramTokenizer

[source,ts,subs=+macros]
----
interface AnalysisNGramTokenizer extends <<AnalysisTokenizerBase>> {
  type: 'ngram'
  custom_token_chars?: string
  max_gram?: <<integer>>
  min_gram?: <<integer>>
  token_chars?: <<AnalysisTokenChar>>[]
}
----


[discrete]
[[AnalysisNoriAnalyzer]]
=== AnalysisNoriAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisNoriAnalyzer {
  type: 'nori'
  version?: <<VersionString>>
  decompound_mode?: <<AnalysisNoriDecompoundMode>>
  stoptags?: string[]
  user_dictionary?: string
}
----


[discrete]
[[AnalysisNoriDecompoundMode]]
=== AnalysisNoriDecompoundMode

[source,ts,subs=+macros]
----
type AnalysisNoriDecompoundMode = 'discard' | 'none' | 'mixed'
----


[discrete]
[[AnalysisNoriPartOfSpeechTokenFilter]]
=== AnalysisNoriPartOfSpeechTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisNoriPartOfSpeechTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'nori_part_of_speech'
  stoptags?: string[]
}
----


[discrete]
[[AnalysisNoriTokenizer]]
=== AnalysisNoriTokenizer

[source,ts,subs=+macros]
----
interface AnalysisNoriTokenizer extends <<AnalysisTokenizerBase>> {
  type: 'nori_tokenizer'
  decompound_mode?: <<AnalysisNoriDecompoundMode>>
  discard_punctuation?: boolean
  user_dictionary?: string
  user_dictionary_rules?: string[]
}
----


[discrete]
[[AnalysisNormalizer]]
=== AnalysisNormalizer

[source,ts,subs=+macros]
----
type AnalysisNormalizer = <<AnalysisLowercaseNormalizer>> | <<AnalysisCustomNormalizer>>
----


[discrete]
[[AnalysisNorwegianAnalyzer]]
=== AnalysisNorwegianAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisNorwegianAnalyzer {
  type: 'norwegian'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
  stem_exclusion?: string[]
}
----


[discrete]
[[AnalysisPathHierarchyTokenizer]]
=== AnalysisPathHierarchyTokenizer

[source,ts,subs=+macros]
----
interface AnalysisPathHierarchyTokenizer extends <<AnalysisTokenizerBase>> {
  type: 'path_hierarchy'
  buffer_size?: <<SpecUtilsStringified>><<<integer>>>
  delimiter?: string
  replacement?: string
  reverse?: <<SpecUtilsStringified>><boolean>
  skip?: <<SpecUtilsStringified>><<<integer>>>
}
----


[discrete]
[[AnalysisPatternAnalyzer]]
=== AnalysisPatternAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisPatternAnalyzer {
  type: 'pattern'
  version?: <<VersionString>>
  flags?: string
  lowercase?: boolean
  pattern: string
  stopwords?: <<AnalysisStopWords>>
}
----


[discrete]
[[AnalysisPatternCaptureTokenFilter]]
=== AnalysisPatternCaptureTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisPatternCaptureTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'pattern_capture'
  patterns: string[]
  preserve_original?: <<SpecUtilsStringified>><boolean>
}
----


[discrete]
[[AnalysisPatternReplaceCharFilter]]
=== AnalysisPatternReplaceCharFilter

[source,ts,subs=+macros]
----
interface AnalysisPatternReplaceCharFilter extends <<AnalysisCharFilterBase>> {
  type: 'pattern_replace'
  flags?: string
  pattern: string
  replacement?: string
}
----


[discrete]
[[AnalysisPatternReplaceTokenFilter]]
=== AnalysisPatternReplaceTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisPatternReplaceTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'pattern_replace'
  all?: boolean
  flags?: string
  pattern: string
  replacement?: string
}
----


[discrete]
[[AnalysisPatternTokenizer]]
=== AnalysisPatternTokenizer

[source,ts,subs=+macros]
----
interface AnalysisPatternTokenizer extends <<AnalysisTokenizerBase>> {
  type: 'pattern'
  flags?: string
  group?: <<integer>>
  pattern?: string
}
----


[discrete]
[[AnalysisPersianAnalyzer]]
=== AnalysisPersianAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisPersianAnalyzer {
  type: 'persian'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
}
----


[discrete]
[[AnalysisPhoneticEncoder]]
=== AnalysisPhoneticEncoder

[source,ts,subs=+macros]
----
type AnalysisPhoneticEncoder = 'metaphone' | 'double_metaphone' | 'soundex' | 'refined_soundex' | 'caverphone1' | 'caverphone2' | 'cologne' | 'nysiis' | 'koelnerphonetik' | 'haasephonetik' | 'beider_morse' | 'daitch_mokotoff'
----


[discrete]
[[AnalysisPhoneticLanguage]]
=== AnalysisPhoneticLanguage

[source,ts,subs=+macros]
----
type AnalysisPhoneticLanguage = 'any' | 'common' | 'cyrillic' | 'english' | 'french' | 'german' | 'hebrew' | 'hungarian' | 'polish' | 'romanian' | 'russian' | 'spanish'
----


[discrete]
[[AnalysisPhoneticNameType]]
=== AnalysisPhoneticNameType

[source,ts,subs=+macros]
----
type AnalysisPhoneticNameType = 'generic' | 'ashkenazi' | 'sephardic'
----


[discrete]
[[AnalysisPhoneticRuleType]]
=== AnalysisPhoneticRuleType

[source,ts,subs=+macros]
----
type AnalysisPhoneticRuleType = 'approx' | 'exact'
----


[discrete]
[[AnalysisPhoneticTokenFilter]]
=== AnalysisPhoneticTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisPhoneticTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'phonetic'
  encoder: <<AnalysisPhoneticEncoder>>
  languageset?: <<AnalysisPhoneticLanguage>> | <<AnalysisPhoneticLanguage>>[]
  max_code_len?: <<integer>>
  name_type?: <<AnalysisPhoneticNameType>>
  replace?: boolean
  rule_type?: <<AnalysisPhoneticRuleType>>
}
----


[discrete]
[[AnalysisPorterStemTokenFilter]]
=== AnalysisPorterStemTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisPorterStemTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'porter_stem'
}
----


[discrete]
[[AnalysisPortugueseAnalyzer]]
=== AnalysisPortugueseAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisPortugueseAnalyzer {
  type: 'portuguese'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
  stem_exclusion?: string[]
}
----


[discrete]
[[AnalysisPredicateTokenFilter]]
=== AnalysisPredicateTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisPredicateTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'predicate_token_filter'
  script: <<Script>> | string
}
----


[discrete]
[[AnalysisRemoveDuplicatesTokenFilter]]
=== AnalysisRemoveDuplicatesTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisRemoveDuplicatesTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'remove_duplicates'
}
----


[discrete]
[[AnalysisReverseTokenFilter]]
=== AnalysisReverseTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisReverseTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'reverse'
}
----


[discrete]
[[AnalysisRomanianAnalyzer]]
=== AnalysisRomanianAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisRomanianAnalyzer {
  type: 'romanian'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
  stem_exclusion?: string[]
}
----


[discrete]
[[AnalysisRussianAnalyzer]]
=== AnalysisRussianAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisRussianAnalyzer {
  type: 'russian'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
  stem_exclusion?: string[]
}
----


[discrete]
[[AnalysisSerbianAnalyzer]]
=== AnalysisSerbianAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisSerbianAnalyzer {
  type: 'serbian'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
  stem_exclusion?: string[]
}
----


[discrete]
[[AnalysisShingleTokenFilter]]
=== AnalysisShingleTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisShingleTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'shingle'
  filler_token?: string
  max_shingle_size?: <<integer>> | string
  min_shingle_size?: <<integer>> | string
  output_unigrams?: boolean
  output_unigrams_if_no_shingles?: boolean
  token_separator?: string
}
----


[discrete]
[[AnalysisSimpleAnalyzer]]
=== AnalysisSimpleAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisSimpleAnalyzer {
  type: 'simple'
  version?: <<VersionString>>
}
----


[discrete]
[[AnalysisSimplePatternSplitTokenizer]]
=== AnalysisSimplePatternSplitTokenizer

[source,ts,subs=+macros]
----
interface AnalysisSimplePatternSplitTokenizer extends <<AnalysisTokenizerBase>> {
  type: 'simple_pattern_split'
  pattern?: string
}
----


[discrete]
[[AnalysisSimplePatternTokenizer]]
=== AnalysisSimplePatternTokenizer

[source,ts,subs=+macros]
----
interface AnalysisSimplePatternTokenizer extends <<AnalysisTokenizerBase>> {
  type: 'simple_pattern'
  pattern?: string
}
----


[discrete]
[[AnalysisSnowballAnalyzer]]
=== AnalysisSnowballAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisSnowballAnalyzer {
  type: 'snowball'
  version?: <<VersionString>>
  language: <<AnalysisSnowballLanguage>>
  stopwords?: <<AnalysisStopWords>>
}
----


[discrete]
[[AnalysisSnowballLanguage]]
=== AnalysisSnowballLanguage

[source,ts,subs=+macros]
----
type AnalysisSnowballLanguage = 'Armenian' | 'Basque' | 'Catalan' | 'Danish' | 'Dutch' | 'English' | 'Finnish' | 'French' | 'German' | 'German2' | 'Hungarian' | 'Italian' | 'Kp' | 'Lovins' | 'Norwegian' | 'Porter' | 'Portuguese' | 'Romanian' | 'Russian' | 'Spanish' | 'Swedish' | 'Turkish'
----


[discrete]
[[AnalysisSnowballTokenFilter]]
=== AnalysisSnowballTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisSnowballTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'snowball'
  language?: <<AnalysisSnowballLanguage>>
}
----


[discrete]
[[AnalysisSoraniAnalyzer]]
=== AnalysisSoraniAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisSoraniAnalyzer {
  type: 'sorani'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
  stem_exclusion?: string[]
}
----


[discrete]
[[AnalysisSpanishAnalyzer]]
=== AnalysisSpanishAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisSpanishAnalyzer {
  type: 'spanish'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
  stem_exclusion?: string[]
}
----


[discrete]
[[AnalysisStandardAnalyzer]]
=== AnalysisStandardAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisStandardAnalyzer {
  type: 'standard'
  max_token_length?: <<integer>>
  stopwords?: <<AnalysisStopWords>>
}
----


[discrete]
[[AnalysisStandardTokenizer]]
=== AnalysisStandardTokenizer

[source,ts,subs=+macros]
----
interface AnalysisStandardTokenizer extends <<AnalysisTokenizerBase>> {
  type: 'standard'
  max_token_length?: <<integer>>
}
----


[discrete]
[[AnalysisStemmerOverrideTokenFilter]]
=== AnalysisStemmerOverrideTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisStemmerOverrideTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'stemmer_override'
  rules?: string[]
  rules_path?: string
}
----


[discrete]
[[AnalysisStemmerTokenFilter]]
=== AnalysisStemmerTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisStemmerTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'stemmer'
  language?: string
  name?: string
}
----


[discrete]
[[AnalysisStopAnalyzer]]
=== AnalysisStopAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisStopAnalyzer {
  type: 'stop'
  version?: <<VersionString>>
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
}
----


[discrete]
[[AnalysisStopTokenFilter]]
=== AnalysisStopTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisStopTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'stop'
  ignore_case?: boolean
  remove_trailing?: boolean
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
}
----


[discrete]
[[AnalysisStopWords]]
=== AnalysisStopWords

[source,ts,subs=+macros]
----
type AnalysisStopWords = string | string[]
----


[discrete]
[[AnalysisSwedishAnalyzer]]
=== AnalysisSwedishAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisSwedishAnalyzer {
  type: 'swedish'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
  stem_exclusion?: string[]
}
----


[discrete]
[[AnalysisSynonymFormat]]
=== AnalysisSynonymFormat

[source,ts,subs=+macros]
----
type AnalysisSynonymFormat = 'solr' | 'wordnet'
----


[discrete]
[[AnalysisSynonymGraphTokenFilter]]
=== AnalysisSynonymGraphTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisSynonymGraphTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'synonym_graph'
  expand?: boolean
  format?: <<AnalysisSynonymFormat>>
  lenient?: boolean
  synonyms?: string[]
  synonyms_path?: string
  synonyms_set?: string
  tokenizer?: string
  updateable?: boolean
}
----


[discrete]
[[AnalysisSynonymTokenFilter]]
=== AnalysisSynonymTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisSynonymTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'synonym'
  expand?: boolean
  format?: <<AnalysisSynonymFormat>>
  lenient?: boolean
  synonyms?: string[]
  synonyms_path?: string
  synonyms_set?: string
  tokenizer?: string
  updateable?: boolean
}
----


[discrete]
[[AnalysisThaiAnalyzer]]
=== AnalysisThaiAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisThaiAnalyzer {
  type: 'thai'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
}
----


[discrete]
[[AnalysisThaiTokenizer]]
=== AnalysisThaiTokenizer

[source,ts,subs=+macros]
----
interface AnalysisThaiTokenizer extends <<AnalysisTokenizerBase>> {
  type: 'thai'
}
----


[discrete]
[[AnalysisTokenChar]]
=== AnalysisTokenChar

[source,ts,subs=+macros]
----
type AnalysisTokenChar = 'letter' | 'digit' | 'whitespace' | 'punctuation' | 'symbol' | 'custom'
----


[discrete]
[[AnalysisTokenFilter]]
=== AnalysisTokenFilter

[source,ts,subs=+macros]
----
type AnalysisTokenFilter = string | <<AnalysisTokenFilterDefinition>>
----


[discrete]
[[AnalysisTokenFilterBase]]
=== AnalysisTokenFilterBase

[source,ts,subs=+macros]
----
interface AnalysisTokenFilterBase {
  version?: <<VersionString>>
}
----


[discrete]
[[AnalysisTokenFilterDefinition]]
=== AnalysisTokenFilterDefinition

[source,ts,subs=+macros]
----
type AnalysisTokenFilterDefinition = <<AnalysisAsciiFoldingTokenFilter>> | <<AnalysisCommonGramsTokenFilter>> | <<AnalysisConditionTokenFilter>> | <<AnalysisDelimitedPayloadTokenFilter>> | <<AnalysisEdgeNGramTokenFilter>> | <<AnalysisElisionTokenFilter>> | <<AnalysisFingerprintTokenFilter>> | <<AnalysisHunspellTokenFilter>> | <<AnalysisHyphenationDecompounderTokenFilter>> | <<AnalysisKeepTypesTokenFilter>> | <<AnalysisKeepWordsTokenFilter>> | <<AnalysisKeywordMarkerTokenFilter>> | <<AnalysisKStemTokenFilter>> | <<AnalysisLengthTokenFilter>> | <<AnalysisLimitTokenCountTokenFilter>> | <<AnalysisLowercaseTokenFilter>> | <<AnalysisMultiplexerTokenFilter>> | <<AnalysisNGramTokenFilter>> | <<AnalysisNoriPartOfSpeechTokenFilter>> | <<AnalysisPatternCaptureTokenFilter>> | <<AnalysisPatternReplaceTokenFilter>> | <<AnalysisPorterStemTokenFilter>> | <<AnalysisPredicateTokenFilter>> | <<AnalysisRemoveDuplicatesTokenFilter>> | <<AnalysisReverseTokenFilter>> | <<AnalysisShingleTokenFilter>> | <<AnalysisSnowballTokenFilter>> | <<AnalysisStemmerOverrideTokenFilter>> | <<AnalysisStemmerTokenFilter>> | <<AnalysisStopTokenFilter>> | <<AnalysisSynonymGraphTokenFilter>> | <<AnalysisSynonymTokenFilter>> | <<AnalysisTrimTokenFilter>> | <<AnalysisTruncateTokenFilter>> | <<AnalysisUniqueTokenFilter>> | <<AnalysisUppercaseTokenFilter>> | <<AnalysisWordDelimiterGraphTokenFilter>> | <<AnalysisWordDelimiterTokenFilter>> | <<AnalysisKuromojiStemmerTokenFilter>> | <<AnalysisKuromojiReadingFormTokenFilter>> | <<AnalysisKuromojiPartOfSpeechTokenFilter>> | <<AnalysisIcuCollationTokenFilter>> | <<AnalysisIcuFoldingTokenFilter>> | <<AnalysisIcuNormalizationTokenFilter>> | <<AnalysisIcuTransformTokenFilter>> | <<AnalysisPhoneticTokenFilter>> | <<AnalysisDictionaryDecompounderTokenFilter>>
----


[discrete]
[[AnalysisTokenizer]]
=== AnalysisTokenizer

[source,ts,subs=+macros]
----
type AnalysisTokenizer = string | <<AnalysisTokenizerDefinition>>
----


[discrete]
[[AnalysisTokenizerBase]]
=== AnalysisTokenizerBase

[source,ts,subs=+macros]
----
interface AnalysisTokenizerBase {
  version?: <<VersionString>>
}
----


[discrete]
[[AnalysisTokenizerDefinition]]
=== AnalysisTokenizerDefinition

[source,ts,subs=+macros]
----
type AnalysisTokenizerDefinition = <<AnalysisCharGroupTokenizer>> | <<AnalysisClassicTokenizer>> | <<AnalysisEdgeNGramTokenizer>> | <<AnalysisKeywordTokenizer>> | <<AnalysisLetterTokenizer>> | <<AnalysisLowercaseTokenizer>> | <<AnalysisNGramTokenizer>> | <<AnalysisPathHierarchyTokenizer>> | <<AnalysisPatternTokenizer>> | <<AnalysisSimplePatternTokenizer>> | <<AnalysisSimplePatternSplitTokenizer>> | <<AnalysisStandardTokenizer>> | <<AnalysisThaiTokenizer>> | <<AnalysisUaxEmailUrlTokenizer>> | <<AnalysisWhitespaceTokenizer>> | <<AnalysisIcuTokenizer>> | <<AnalysisKuromojiTokenizer>> | <<AnalysisNoriTokenizer>>
----


[discrete]
[[AnalysisTrimTokenFilter]]
=== AnalysisTrimTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisTrimTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'trim'
}
----


[discrete]
[[AnalysisTruncateTokenFilter]]
=== AnalysisTruncateTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisTruncateTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'truncate'
  length?: <<integer>>
}
----


[discrete]
[[AnalysisTurkishAnalyzer]]
=== AnalysisTurkishAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisTurkishAnalyzer {
  type: 'turkish'
  stopwords?: <<AnalysisStopWords>>
  stopwords_path?: string
  stem_exclusion?: string[]
}
----


[discrete]
[[AnalysisUaxEmailUrlTokenizer]]
=== AnalysisUaxEmailUrlTokenizer

[source,ts,subs=+macros]
----
interface AnalysisUaxEmailUrlTokenizer extends <<AnalysisTokenizerBase>> {
  type: 'uax_url_email'
  max_token_length?: <<integer>>
}
----


[discrete]
[[AnalysisUniqueTokenFilter]]
=== AnalysisUniqueTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisUniqueTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'unique'
  only_on_same_position?: boolean
}
----


[discrete]
[[AnalysisUppercaseTokenFilter]]
=== AnalysisUppercaseTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisUppercaseTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'uppercase'
}
----


[discrete]
[[AnalysisWhitespaceAnalyzer]]
=== AnalysisWhitespaceAnalyzer

[source,ts,subs=+macros]
----
interface AnalysisWhitespaceAnalyzer {
  type: 'whitespace'
  version?: <<VersionString>>
}
----


[discrete]
[[AnalysisWhitespaceTokenizer]]
=== AnalysisWhitespaceTokenizer

[source,ts,subs=+macros]
----
interface AnalysisWhitespaceTokenizer extends <<AnalysisTokenizerBase>> {
  type: 'whitespace'
  max_token_length?: <<integer>>
}
----


[discrete]
[[AnalysisWordDelimiterGraphTokenFilter]]
=== AnalysisWordDelimiterGraphTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisWordDelimiterGraphTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'word_delimiter_graph'
  adjust_offsets?: boolean
  catenate_all?: boolean
  catenate_numbers?: boolean
  catenate_words?: boolean
  generate_number_parts?: boolean
  generate_word_parts?: boolean
  ignore_keywords?: boolean
  preserve_original?: <<SpecUtilsStringified>><boolean>
  protected_words?: string[]
  protected_words_path?: string
  split_on_case_change?: boolean
  split_on_numerics?: boolean
  stem_english_possessive?: boolean
  type_table?: string[]
  type_table_path?: string
}
----


[discrete]
[[AnalysisWordDelimiterTokenFilter]]
=== AnalysisWordDelimiterTokenFilter

[source,ts,subs=+macros]
----
interface AnalysisWordDelimiterTokenFilter extends <<AnalysisTokenFilterBase>> {
  type: 'word_delimiter'
  catenate_all?: boolean
  catenate_numbers?: boolean
  catenate_words?: boolean
  generate_number_parts?: boolean
  generate_word_parts?: boolean
  preserve_original?: <<SpecUtilsStringified>><boolean>
  protected_words?: string[]
  protected_words_path?: string
  split_on_case_change?: boolean
  split_on_numerics?: boolean
  stem_english_possessive?: boolean
  type_table?: string[]
  type_table_path?: string
}
----


[discrete]
[[MappingAggregateMetricDoubleProperty]]
=== MappingAggregateMetricDoubleProperty

[source,ts,subs=+macros]
----
interface MappingAggregateMetricDoubleProperty extends <<MappingPropertyBase>> {
  type: 'aggregate_metric_double'
  default_metric: string
  metrics: string[]
  time_series_metric?: <<MappingTimeSeriesMetricType>>
}
----


[discrete]
[[MappingAllField]]
=== MappingAllField

[source,ts,subs=+macros]
----
interface MappingAllField {
  analyzer: string
  enabled: boolean
  omit_norms: boolean
  search_analyzer: string
  similarity: string
  store: boolean
  store_term_vector_offsets: boolean
  store_term_vector_payloads: boolean
  store_term_vector_positions: boolean
  store_term_vectors: boolean
}
----


[discrete]
[[MappingBinaryProperty]]
=== MappingBinaryProperty

[source,ts,subs=+macros]
----
interface MappingBinaryProperty extends <<MappingDocValuesPropertyBase>> {
  type: 'binary'
}
----


[discrete]
[[MappingBooleanProperty]]
=== MappingBooleanProperty

[source,ts,subs=+macros]
----
interface MappingBooleanProperty extends <<MappingDocValuesPropertyBase>> {
  boost?: <<double>>
  fielddata?: <<IndicesNumericFielddata>>
  index?: boolean
  null_value?: boolean
  type: 'boolean'
}
----


[discrete]
[[MappingByteNumberProperty]]
=== MappingByteNumberProperty

[source,ts,subs=+macros]
----
interface MappingByteNumberProperty extends <<MappingNumberPropertyBase>> {
  type: '<<byte>>'
  null_value?: <<byte>>
}
----


[discrete]
[[MappingCompletionProperty]]
=== MappingCompletionProperty

[source,ts,subs=+macros]
----
interface MappingCompletionProperty extends <<MappingDocValuesPropertyBase>> {
  analyzer?: string
  contexts?: <<MappingSuggestContext>>[]
  max_input_length?: <<integer>>
  preserve_position_increments?: boolean
  preserve_separators?: boolean
  search_analyzer?: string
  type: 'completion'
}
----


[discrete]
[[MappingCompositeSubField]]
=== MappingCompositeSubField

[source,ts,subs=+macros]
----
interface MappingCompositeSubField {
  type: <<MappingRuntimeFieldType>>
}
----


[discrete]
[[MappingConstantKeywordProperty]]
=== MappingConstantKeywordProperty

[source,ts,subs=+macros]
----
interface MappingConstantKeywordProperty extends <<MappingPropertyBase>> {
  value?: any
  type: 'constant_keyword'
}
----


[discrete]
[[MappingCorePropertyBase]]
=== MappingCorePropertyBase

[source,ts,subs=+macros]
----
interface MappingCorePropertyBase extends <<MappingPropertyBase>> {
  copy_to?: <<Fields>>
  store?: boolean
}
----


[discrete]
[[MappingDataStreamTimestamp]]
=== MappingDataStreamTimestamp

[source,ts,subs=+macros]
----
interface MappingDataStreamTimestamp {
  enabled: boolean
}
----


[discrete]
[[MappingDateNanosProperty]]
=== MappingDateNanosProperty

[source,ts,subs=+macros]
----
interface MappingDateNanosProperty extends <<MappingDocValuesPropertyBase>> {
  boost?: <<double>>
  format?: string
  ignore_malformed?: boolean
  index?: boolean
  null_value?: <<DateTime>>
  precision_step?: <<integer>>
  type: 'date_nanos'
}
----


[discrete]
[[MappingDateProperty]]
=== MappingDateProperty

[source,ts,subs=+macros]
----
interface MappingDateProperty extends <<MappingDocValuesPropertyBase>> {
  boost?: <<double>>
  fielddata?: <<IndicesNumericFielddata>>
  format?: string
  ignore_malformed?: boolean
  index?: boolean
  null_value?: <<DateTime>>
  precision_step?: <<integer>>
  locale?: string
  type: 'date'
}
----


[discrete]
[[MappingDateRangeProperty]]
=== MappingDateRangeProperty

[source,ts,subs=+macros]
----
interface MappingDateRangeProperty extends <<MappingRangePropertyBase>> {
  format?: string
  type: 'date_range'
}
----


[discrete]
[[MappingDenseVectorIndexOptions]]
=== MappingDenseVectorIndexOptions

[source,ts,subs=+macros]
----
interface MappingDenseVectorIndexOptions {
  type: string
  m?: <<integer>>
  ef_construction?: <<integer>>
  confidence_interval?: <<float>>
}
----


[discrete]
[[MappingDenseVectorProperty]]
=== MappingDenseVectorProperty

[source,ts,subs=+macros]
----
interface MappingDenseVectorProperty extends <<MappingPropertyBase>> {
  type: 'dense_vector'
  element_type?: string
  dims?: <<integer>>
  similarity?: string
  index?: boolean
  index_options?: <<MappingDenseVectorIndexOptions>>
}
----


[discrete]
[[MappingDocValuesPropertyBase]]
=== MappingDocValuesPropertyBase

[source,ts,subs=+macros]
----
interface MappingDocValuesPropertyBase extends <<MappingCorePropertyBase>> {
  doc_values?: boolean
}
----


[discrete]
[[MappingDoubleNumberProperty]]
=== MappingDoubleNumberProperty

[source,ts,subs=+macros]
----
interface MappingDoubleNumberProperty extends <<MappingNumberPropertyBase>> {
  type: '<<double>>'
  null_value?: <<double>>
}
----


[discrete]
[[MappingDoubleRangeProperty]]
=== MappingDoubleRangeProperty

[source,ts,subs=+macros]
----
interface MappingDoubleRangeProperty extends <<MappingRangePropertyBase>> {
  type: 'double_range'
}
----


[discrete]
[[MappingDynamicMapping]]
=== MappingDynamicMapping

[source,ts,subs=+macros]
----
type MappingDynamicMapping = boolean | 'strict' | 'runtime' | 'true' | 'false'
----


[discrete]
[[MappingDynamicProperty]]
=== MappingDynamicProperty

[source,ts,subs=+macros]
----
interface MappingDynamicProperty extends <<MappingDocValuesPropertyBase>> {
  type: '{dynamic_type}'
  enabled?: boolean
  null_value?: <<FieldValue>>
  boost?: <<double>>
  coerce?: boolean
  script?: <<Script>> | string
  on_script_error?: <<MappingOnScriptError>>
  ignore_malformed?: boolean
  time_series_metric?: <<MappingTimeSeriesMetricType>>
  analyzer?: string
  eager_global_ordinals?: boolean
  index?: boolean
  index_options?: <<MappingIndexOptions>>
  index_phrases?: boolean
  index_prefixes?: <<MappingTextIndexPrefixes>> | null
  norms?: boolean
  position_increment_gap?: <<integer>>
  search_analyzer?: string
  search_quote_analyzer?: string
  term_vector?: <<MappingTermVectorOption>>
  format?: string
  precision_step?: <<integer>>
  locale?: string
}
----


[discrete]
[[MappingDynamicTemplate]]
=== MappingDynamicTemplate

[source,ts,subs=+macros]
----
interface MappingDynamicTemplate {
  mapping?: <<MappingProperty>>
  runtime?: <<MappingProperty>>
  match?: string | string[]
  path_match?: string | string[]
  unmatch?: string | string[]
  path_unmatch?: string | string[]
  match_mapping_type?: string | string[]
  unmatch_mapping_type?: string | string[]
  match_pattern?: <<MappingMatchType>>
}
----


[discrete]
[[MappingFieldAliasProperty]]
=== MappingFieldAliasProperty

[source,ts,subs=+macros]
----
interface MappingFieldAliasProperty extends <<MappingPropertyBase>> {
  path?: <<Field>>
  type: 'alias'
}
----


[discrete]
[[MappingFieldMapping]]
=== MappingFieldMapping

[source,ts,subs=+macros]
----
interface MappingFieldMapping {
  full_name: string
  mapping: Partial<Record<<<Field>>, <<MappingProperty>>>>
}
----


[discrete]
[[MappingFieldNamesField]]
=== MappingFieldNamesField

[source,ts,subs=+macros]
----
interface MappingFieldNamesField {
  enabled: boolean
}
----


[discrete]
[[MappingFieldType]]
=== MappingFieldType

[source,ts,subs=+macros]
----
type MappingFieldType = 'none' | 'geo_point' | 'geo_shape' | 'ip' | 'binary' | 'keyword' | 'text' | 'search_as_you_type' | 'date' | 'date_nanos' | 'boolean' | 'completion' | 'nested' | 'object' | 'version' | 'murmur3' | 'token_count' | 'percolator' | '<<integer>>' | '<<long>>' | '<<short>>' | '<<byte>>' | '<<float>>' | 'half_float' | 'scaled_float' | '<<double>>' | 'integer_range' | 'float_range' | 'long_range' | 'double_range' | 'date_range' | 'ip_range' | 'alias' | 'join' | 'rank_feature' | 'rank_features' | 'flattened' | 'shape' | 'histogram' | 'constant_keyword' | 'aggregate_metric_double' | 'dense_vector' | 'semantic_text' | 'sparse_vector' | 'match_only_text' | 'icu_collation_keyword'
----


[discrete]
[[MappingFlattenedProperty]]
=== MappingFlattenedProperty

[source,ts,subs=+macros]
----
interface MappingFlattenedProperty extends <<MappingPropertyBase>> {
  boost?: <<double>>
  depth_limit?: <<integer>>
  doc_values?: boolean
  eager_global_ordinals?: boolean
  index?: boolean
  index_options?: <<MappingIndexOptions>>
  null_value?: string
  similarity?: string
  split_queries_on_whitespace?: boolean
  type: 'flattened'
}
----


[discrete]
[[MappingFloatNumberProperty]]
=== MappingFloatNumberProperty

[source,ts,subs=+macros]
----
interface MappingFloatNumberProperty extends <<MappingNumberPropertyBase>> {
  type: '<<float>>'
  null_value?: <<float>>
}
----


[discrete]
[[MappingFloatRangeProperty]]
=== MappingFloatRangeProperty

[source,ts,subs=+macros]
----
interface MappingFloatRangeProperty extends <<MappingRangePropertyBase>> {
  type: 'float_range'
}
----


[discrete]
[[MappingGeoOrientation]]
=== MappingGeoOrientation

[source,ts,subs=+macros]
----
type MappingGeoOrientation = 'right' | 'RIGHT' | 'counterclockwise' | 'ccw' | 'left' | 'LEFT' | 'clockwise' | 'cw'
----


[discrete]
[[MappingGeoPointProperty]]
=== MappingGeoPointProperty

[source,ts,subs=+macros]
----
interface MappingGeoPointProperty extends <<MappingDocValuesPropertyBase>> {
  ignore_malformed?: boolean
  ignore_z_value?: boolean
  null_value?: <<GeoLocation>>
  index?: boolean
  on_script_error?: <<MappingOnScriptError>>
  script?: <<Script>> | string
  type: 'geo_point'
}
----


[discrete]
[[MappingGeoShapeProperty]]
=== MappingGeoShapeProperty

[source,ts,subs=+macros]
----
interface MappingGeoShapeProperty extends <<MappingDocValuesPropertyBase>> {
  coerce?: boolean
  ignore_malformed?: boolean
  ignore_z_value?: boolean
  orientation?: <<MappingGeoOrientation>>
  strategy?: <<MappingGeoStrategy>>
  type: 'geo_shape'
}
----


[discrete]
[[MappingGeoStrategy]]
=== MappingGeoStrategy

[source,ts,subs=+macros]
----
type MappingGeoStrategy = 'recursive' | 'term'
----


[discrete]
[[MappingHalfFloatNumberProperty]]
=== MappingHalfFloatNumberProperty

[source,ts,subs=+macros]
----
interface MappingHalfFloatNumberProperty extends <<MappingNumberPropertyBase>> {
  type: 'half_float'
  null_value?: <<float>>
}
----


[discrete]
[[MappingHistogramProperty]]
=== MappingHistogramProperty

[source,ts,subs=+macros]
----
interface MappingHistogramProperty extends <<MappingPropertyBase>> {
  ignore_malformed?: boolean
  type: 'histogram'
}
----


[discrete]
[[MappingIcuCollationProperty]]
=== MappingIcuCollationProperty

[source,ts,subs=+macros]
----
interface MappingIcuCollationProperty extends <<MappingDocValuesPropertyBase>> {
  type: 'icu_collation_keyword'
  norms?: boolean
  index_options?: <<MappingIndexOptions>>
  pass:[/**] @property index Should the field be searchable? */
  index?: boolean
  pass:[/**] @property null_value Accepts a string value which is substituted for any explicit null values. Defaults to null, which means the field is treated as missing. */
  null_value?: string
  rules?: string
  language?: string
  country?: string
  variant?: string
  strength?: <<AnalysisIcuCollationStrength>>
  decomposition?: <<AnalysisIcuCollationDecomposition>>
  alternate?: <<AnalysisIcuCollationAlternate>>
  case_level?: boolean
  case_first?: <<AnalysisIcuCollationCaseFirst>>
  numeric?: boolean
  variable_top?: string
  hiragana_quaternary_mode?: boolean
}
----


[discrete]
[[MappingIndexField]]
=== MappingIndexField

[source,ts,subs=+macros]
----
interface MappingIndexField {
  enabled: boolean
}
----


[discrete]
[[MappingIndexOptions]]
=== MappingIndexOptions

[source,ts,subs=+macros]
----
type MappingIndexOptions = 'docs' | 'freqs' | 'positions' | 'offsets'
----


[discrete]
[[MappingIntegerNumberProperty]]
=== MappingIntegerNumberProperty

[source,ts,subs=+macros]
----
interface MappingIntegerNumberProperty extends <<MappingNumberPropertyBase>> {
  type: '<<integer>>'
  null_value?: <<integer>>
}
----


[discrete]
[[MappingIntegerRangeProperty]]
=== MappingIntegerRangeProperty

[source,ts,subs=+macros]
----
interface MappingIntegerRangeProperty extends <<MappingRangePropertyBase>> {
  type: 'integer_range'
}
----


[discrete]
[[MappingIpProperty]]
=== MappingIpProperty

[source,ts,subs=+macros]
----
interface MappingIpProperty extends <<MappingDocValuesPropertyBase>> {
  boost?: <<double>>
  index?: boolean
  ignore_malformed?: boolean
  null_value?: string
  on_script_error?: <<MappingOnScriptError>>
  script?: <<Script>> | string
  pass:[/**] @property time_series_dimension For internal use by Elastic only. Marks the field as a time series dimension. Defaults to false. */
  time_series_dimension?: boolean
  type: 'ip'
}
----


[discrete]
[[MappingIpRangeProperty]]
=== MappingIpRangeProperty

[source,ts,subs=+macros]
----
interface MappingIpRangeProperty extends <<MappingRangePropertyBase>> {
  type: 'ip_range'
}
----


[discrete]
[[MappingJoinProperty]]
=== MappingJoinProperty

[source,ts,subs=+macros]
----
interface MappingJoinProperty extends <<MappingPropertyBase>> {
  relations?: Record<<<RelationName>>, <<RelationName>> | <<RelationName>>[]>
  eager_global_ordinals?: boolean
  type: 'join'
}
----


[discrete]
[[MappingKeywordProperty]]
=== MappingKeywordProperty

[source,ts,subs=+macros]
----
interface MappingKeywordProperty extends <<MappingDocValuesPropertyBase>> {
  boost?: <<double>>
  eager_global_ordinals?: boolean
  index?: boolean
  index_options?: <<MappingIndexOptions>>
  script?: <<Script>> | string
  on_script_error?: <<MappingOnScriptError>>
  normalizer?: string
  norms?: boolean
  null_value?: string
  similarity?: string | null
  split_queries_on_whitespace?: boolean
  pass:[/**] @property time_series_dimension For internal use by Elastic only. Marks the field as a time series dimension. Defaults to false. */
  time_series_dimension?: boolean
  type: 'keyword'
}
----


[discrete]
[[MappingLongNumberProperty]]
=== MappingLongNumberProperty

[source,ts,subs=+macros]
----
interface MappingLongNumberProperty extends <<MappingNumberPropertyBase>> {
  type: '<<long>>'
  null_value?: <<long>>
}
----


[discrete]
[[MappingLongRangeProperty]]
=== MappingLongRangeProperty

[source,ts,subs=+macros]
----
interface MappingLongRangeProperty extends <<MappingRangePropertyBase>> {
  type: 'long_range'
}
----


[discrete]
[[MappingMatchOnlyTextProperty]]
=== MappingMatchOnlyTextProperty

[source,ts,subs=+macros]
----
interface MappingMatchOnlyTextProperty {
  type: 'match_only_text'
  pass:[/**] @property fields Multi-fields allow the same string value to be indexed in multiple ways for different purposes, such as one field for search and a multi-field for sorting and aggregations, or the same string value analyzed by different analyzers. */
  fields?: Record<<<PropertyName>>, <<MappingProperty>>>
  pass:[/**] @property meta <<Metadata>> about the field. */
  meta?: Record<string, string>
  pass:[/**] @property copy_to Allows you to copy the values of multiple fields into a group field, which can then be queried as a single field. */
  copy_to?: <<Fields>>
}
----


[discrete]
[[MappingMatchType]]
=== MappingMatchType

[source,ts,subs=+macros]
----
type MappingMatchType = 'simple' | 'regex'
----


[discrete]
[[MappingMurmur3HashProperty]]
=== MappingMurmur3HashProperty

[source,ts,subs=+macros]
----
interface MappingMurmur3HashProperty extends <<MappingDocValuesPropertyBase>> {
  type: 'murmur3'
}
----


[discrete]
[[MappingNestedProperty]]
=== MappingNestedProperty

[source,ts,subs=+macros]
----
interface MappingNestedProperty extends <<MappingCorePropertyBase>> {
  enabled?: boolean
  include_in_parent?: boolean
  include_in_root?: boolean
  type: 'nested'
}
----


[discrete]
[[MappingNumberPropertyBase]]
=== MappingNumberPropertyBase

[source,ts,subs=+macros]
----
interface MappingNumberPropertyBase extends <<MappingDocValuesPropertyBase>> {
  boost?: <<double>>
  coerce?: boolean
  ignore_malformed?: boolean
  index?: boolean
  on_script_error?: <<MappingOnScriptError>>
  script?: <<Script>> | string
  pass:[/**] @property time_series_metric For internal use by Elastic only. Marks the field as a time series dimension. Defaults to false. */
  time_series_metric?: <<MappingTimeSeriesMetricType>>
  pass:[/**] @property time_series_dimension For internal use by Elastic only. Marks the field as a time series dimension. Defaults to false. */
  time_series_dimension?: boolean
}
----


[discrete]
[[MappingObjectProperty]]
=== MappingObjectProperty

[source,ts,subs=+macros]
----
interface MappingObjectProperty extends <<MappingCorePropertyBase>> {
  enabled?: boolean
  subobjects?: boolean
  type?: 'object'
}
----


[discrete]
[[MappingOnScriptError]]
=== MappingOnScriptError

[source,ts,subs=+macros]
----
type MappingOnScriptError = 'fail' | 'continue'
----


[discrete]
[[MappingPercolatorProperty]]
=== MappingPercolatorProperty

[source,ts,subs=+macros]
----
interface MappingPercolatorProperty extends <<MappingPropertyBase>> {
  type: 'percolator'
}
----


[discrete]
[[MappingPointProperty]]
=== MappingPointProperty

[source,ts,subs=+macros]
----
interface MappingPointProperty extends <<MappingDocValuesPropertyBase>> {
  ignore_malformed?: boolean
  ignore_z_value?: boolean
  null_value?: string
  type: 'point'
}
----


[discrete]
[[MappingProperty]]
=== MappingProperty

[source,ts,subs=+macros]
----
type MappingProperty = <<MappingBinaryProperty>> | <<MappingBooleanProperty>> | <<MappingDynamicProperty>> | <<MappingJoinProperty>> | <<MappingKeywordProperty>> | <<MappingMatchOnlyTextProperty>> | <<MappingPercolatorProperty>> | <<MappingRankFeatureProperty>> | <<MappingRankFeaturesProperty>> | <<MappingSearchAsYouTypeProperty>> | <<MappingTextProperty>> | <<MappingVersionProperty>> | <<MappingWildcardProperty>> | <<MappingDateNanosProperty>> | <<MappingDateProperty>> | <<MappingAggregateMetricDoubleProperty>> | <<MappingDenseVectorProperty>> | <<MappingFlattenedProperty>> | <<MappingNestedProperty>> | <<MappingObjectProperty>> | <<MappingSemanticTextProperty>> | <<MappingSparseVectorProperty>> | <<MappingCompletionProperty>> | <<MappingConstantKeywordProperty>> | <<MappingFieldAliasProperty>> | <<MappingHistogramProperty>> | <<MappingIpProperty>> | MappingMurmur3HashProperty | <<MappingTokenCountProperty>> | <<MappingGeoPointProperty>> | <<MappingGeoShapeProperty>> | <<MappingPointProperty>> | <<MappingShapeProperty>> | <<MappingByteNumberProperty>> | <<MappingDoubleNumberProperty>> | <<MappingFloatNumberProperty>> | <<MappingHalfFloatNumberProperty>> | <<MappingIntegerNumberProperty>> | <<MappingLongNumberProperty>> | <<MappingScaledFloatNumberProperty>> | <<MappingShortNumberProperty>> | <<MappingUnsignedLongNumberProperty>> | <<MappingDateRangeProperty>> | <<MappingDoubleRangeProperty>> | <<MappingFloatRangeProperty>> | <<MappingIntegerRangeProperty>> | <<MappingIpRangeProperty>> | <<MappingLongRangeProperty>> | <<MappingIcuCollationProperty>>
----


[discrete]
[[MappingPropertyBase]]
=== MappingPropertyBase

[source,ts,subs=+macros]
----
interface MappingPropertyBase {
  pass:[/**] @property meta <<Metadata>> about the field. */
  meta?: Record<string, string>
  properties?: Record<<<PropertyName>>, <<MappingProperty>>>
  ignore_above?: <<integer>>
  dynamic?: <<MappingDynamicMapping>>
  fields?: Record<<<PropertyName>>, <<MappingProperty>>>
}
----


[discrete]
[[MappingRangePropertyBase]]
=== MappingRangePropertyBase

[source,ts,subs=+macros]
----
interface MappingRangePropertyBase extends <<MappingDocValuesPropertyBase>> {
  boost?: <<double>>
  coerce?: boolean
  index?: boolean
}
----


[discrete]
[[MappingRankFeatureProperty]]
=== MappingRankFeatureProperty

[source,ts,subs=+macros]
----
interface MappingRankFeatureProperty extends <<MappingPropertyBase>> {
  positive_score_impact?: boolean
  type: 'rank_feature'
}
----


[discrete]
[[MappingRankFeaturesProperty]]
=== MappingRankFeaturesProperty

[source,ts,subs=+macros]
----
interface MappingRankFeaturesProperty extends <<MappingPropertyBase>> {
  positive_score_impact?: boolean
  type: 'rank_features'
}
----


[discrete]
[[MappingRoutingField]]
=== MappingRoutingField

[source,ts,subs=+macros]
----
interface MappingRoutingField {
  required: boolean
}
----


[discrete]
[[MappingRuntimeField]]
=== MappingRuntimeField

[source,ts,subs=+macros]
----
interface MappingRuntimeField {
  pass:[/**] @property fields For type `composite` */
  fields?: Record<string, <<MappingCompositeSubField>>>
  pass:[/**] @property fetch_fields For type `lookup` */
  fetch_fields?: (<<MappingRuntimeFieldFetchFields>> | <<Field>>)[]
  pass:[/**] @property format A custom format for `date` type runtime fields. */
  format?: string
  pass:[/**] @property input_field For type `lookup` */
  input_field?: <<Field>>
  pass:[/**] @property target_field For type `lookup` */
  target_field?: <<Field>>
  pass:[/**] @property target_index For type `lookup` */
  target_index?: <<IndexName>>
  pass:[/**] @property script Painless script executed at query time. */
  script?: <<Script>> | string
  pass:[/**] @property type <<Field>> type, which can be: `boolean`, `composite`, `date`, `<<double>>`, `geo_point`, `ip`,`keyword`, `<<long>>`, or `lookup`. */
  type: <<MappingRuntimeFieldType>>
}
----


[discrete]
[[MappingRuntimeFieldFetchFields]]
=== MappingRuntimeFieldFetchFields

[source,ts,subs=+macros]
----
interface MappingRuntimeFieldFetchFields {
  field: <<Field>>
  format?: string
}
----


[discrete]
[[MappingRuntimeFieldType]]
=== MappingRuntimeFieldType

[source,ts,subs=+macros]
----
type MappingRuntimeFieldType = 'boolean' | 'composite' | 'date' | '<<double>>' | 'geo_point' | 'ip' | 'keyword' | '<<long>>' | 'lookup'
----


[discrete]
[[MappingRuntimeFields]]
=== MappingRuntimeFields

[source,ts,subs=+macros]
----
type MappingRuntimeFields = Record<<<Field>>, <<MappingRuntimeField>>>
----


[discrete]
[[MappingScaledFloatNumberProperty]]
=== MappingScaledFloatNumberProperty

[source,ts,subs=+macros]
----
interface MappingScaledFloatNumberProperty extends <<MappingNumberPropertyBase>> {
  type: 'scaled_float'
  null_value?: <<double>>
  scaling_factor?: <<double>>
}
----


[discrete]
[[MappingSearchAsYouTypeProperty]]
=== MappingSearchAsYouTypeProperty

[source,ts,subs=+macros]
----
interface MappingSearchAsYouTypeProperty extends <<MappingCorePropertyBase>> {
  analyzer?: string
  index?: boolean
  index_options?: <<MappingIndexOptions>>
  max_shingle_size?: <<integer>>
  norms?: boolean
  search_analyzer?: string
  search_quote_analyzer?: string
  similarity?: string | null
  term_vector?: <<MappingTermVectorOption>>
  type: 'search_as_you_type'
}
----


[discrete]
[[MappingSemanticTextProperty]]
=== MappingSemanticTextProperty

[source,ts,subs=+macros]
----
interface MappingSemanticTextProperty {
  type: 'semantic_text'
  meta?: Record<string, string>
  inference_id: <<Id>>
}
----


[discrete]
[[MappingShapeProperty]]
=== MappingShapeProperty

[source,ts,subs=+macros]
----
interface MappingShapeProperty extends <<MappingDocValuesPropertyBase>> {
  coerce?: boolean
  ignore_malformed?: boolean
  ignore_z_value?: boolean
  orientation?: <<MappingGeoOrientation>>
  type: 'shape'
}
----


[discrete]
[[MappingShortNumberProperty]]
=== MappingShortNumberProperty

[source,ts,subs=+macros]
----
interface MappingShortNumberProperty extends <<MappingNumberPropertyBase>> {
  type: '<<short>>'
  null_value?: <<short>>
}
----


[discrete]
[[MappingSizeField]]
=== MappingSizeField

[source,ts,subs=+macros]
----
interface MappingSizeField {
  enabled: boolean
}
----


[discrete]
[[MappingSourceField]]
=== MappingSourceField

[source,ts,subs=+macros]
----
interface MappingSourceField {
  compress?: boolean
  compress_threshold?: string
  enabled?: boolean
  excludes?: string[]
  includes?: string[]
  mode?: <<MappingSourceFieldMode>>
}
----


[discrete]
[[MappingSourceFieldMode]]
=== MappingSourceFieldMode

[source,ts,subs=+macros]
----
type MappingSourceFieldMode = 'disabled' | 'stored' | 'synthetic'
----


[discrete]
[[MappingSparseVectorProperty]]
=== MappingSparseVectorProperty

[source,ts,subs=+macros]
----
interface MappingSparseVectorProperty extends <<MappingPropertyBase>> {
  type: 'sparse_vector'
}
----


[discrete]
[[MappingSuggestContext]]
=== MappingSuggestContext

[source,ts,subs=+macros]
----
interface MappingSuggestContext {
  name: <<Name>>
  path?: <<Field>>
  type: string
  precision?: <<integer>> | string
}
----


[discrete]
[[MappingTermVectorOption]]
=== MappingTermVectorOption

[source,ts,subs=+macros]
----
type MappingTermVectorOption = 'no' | 'yes' | 'with_offsets' | 'with_positions' | 'with_positions_offsets' | 'with_positions_offsets_payloads' | 'with_positions_payloads'
----


[discrete]
[[MappingTextIndexPrefixes]]
=== MappingTextIndexPrefixes

[source,ts,subs=+macros]
----
interface MappingTextIndexPrefixes {
  max_chars: <<integer>>
  min_chars: <<integer>>
}
----


[discrete]
[[MappingTextProperty]]
=== MappingTextProperty

[source,ts,subs=+macros]
----
interface MappingTextProperty extends <<MappingCorePropertyBase>> {
  analyzer?: string
  boost?: <<double>>
  eager_global_ordinals?: boolean
  fielddata?: boolean
  fielddata_frequency_filter?: <<IndicesFielddataFrequencyFilter>>
  index?: boolean
  index_options?: <<MappingIndexOptions>>
  index_phrases?: boolean
  index_prefixes?: <<MappingTextIndexPrefixes>> | null
  norms?: boolean
  position_increment_gap?: <<integer>>
  search_analyzer?: string
  search_quote_analyzer?: string
  similarity?: string | null
  term_vector?: <<MappingTermVectorOption>>
  type: 'text'
}
----


[discrete]
[[MappingTimeSeriesMetricType]]
=== MappingTimeSeriesMetricType

[source,ts,subs=+macros]
----
type MappingTimeSeriesMetricType = 'gauge' | 'counter' | 'summary' | 'histogram' | 'position'
----


[discrete]
[[MappingTokenCountProperty]]
=== MappingTokenCountProperty

[source,ts,subs=+macros]
----
interface MappingTokenCountProperty extends <<MappingDocValuesPropertyBase>> {
  analyzer?: string
  boost?: <<double>>
  index?: boolean
  null_value?: <<double>>
  enable_position_increments?: boolean
  type: 'token_count'
}
----


[discrete]
[[MappingTypeMapping]]
=== MappingTypeMapping

[source,ts,subs=+macros]
----
interface MappingTypeMapping {
  all_field?: <<MappingAllField>>
  date_detection?: boolean
  dynamic?: <<MappingDynamicMapping>>
  dynamic_date_formats?: string[]
  dynamic_templates?: Record<string, <<MappingDynamicTemplate>>>[]
  _field_names?: <<MappingFieldNamesField>>
  index_field?: <<MappingIndexField>>
  _meta?: <<Metadata>>
  numeric_detection?: boolean
  properties?: Record<<<PropertyName>>, <<MappingProperty>>>
  _routing?: <<MappingRoutingField>>
  _size?: <<MappingSizeField>>
  _source?: <<MappingSourceField>>
  runtime?: Record<string, <<MappingRuntimeField>>>
  enabled?: boolean
  subobjects?: boolean
  _data_stream_timestamp?: <<MappingDataStreamTimestamp>>
}
----


[discrete]
[[MappingUnsignedLongNumberProperty]]
=== MappingUnsignedLongNumberProperty

[source,ts,subs=+macros]
----
interface MappingUnsignedLongNumberProperty extends <<MappingNumberPropertyBase>> {
  type: 'unsigned_long'
  null_value?: <<ulong>>
}
----


[discrete]
[[MappingVersionProperty]]
=== MappingVersionProperty

[source,ts,subs=+macros]
----
interface MappingVersionProperty extends <<MappingDocValuesPropertyBase>> {
  type: 'version'
}
----


[discrete]
[[MappingWildcardProperty]]
=== MappingWildcardProperty

[source,ts,subs=+macros]
----
interface MappingWildcardProperty extends <<MappingDocValuesPropertyBase>> {
  type: 'wildcard'
  null_value?: string
}
----


[discrete]
[[QueryDslBoolQuery]]
=== QueryDslBoolQuery

[source,ts,subs=+macros]
----
interface QueryDslBoolQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property filter The clause (query) must appear in matching documents. However, unlike `must`, the score of the query will be ignored. */
  filter?: <<QueryDslQueryContainer>> | <<QueryDslQueryContainer>>[]
  pass:[/**] @property minimum_should_match Specifies the number or percentage of `should` clauses returned documents must match. */
  minimum_should_match?: <<MinimumShouldMatch>>
  pass:[/**] @property must The clause (query) must appear in matching documents and will contribute to the score. */
  must?: <<QueryDslQueryContainer>> | <<QueryDslQueryContainer>>[]
  pass:[/**] @property must_not The clause (query) must not appear in the matching documents. Because scoring is ignored, a score of `0` is returned for all documents. */
  must_not?: <<QueryDslQueryContainer>> | <<QueryDslQueryContainer>>[]
  pass:[/**] @property should The clause (query) should appear in the matching document. */
  should?: <<QueryDslQueryContainer>> | <<QueryDslQueryContainer>>[]
}
----


[discrete]
[[QueryDslBoostingQuery]]
=== QueryDslBoostingQuery

[source,ts,subs=+macros]
----
interface QueryDslBoostingQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property negative_boost Floating point number between 0 and 1.0 used to decrease the relevance scores of documents matching the `negative` query. */
  negative_boost: <<double>>
  pass:[/**] @property negative Query used to decrease the relevance score of matching documents. */
  negative: <<QueryDslQueryContainer>>
  pass:[/**] @property positive Any returned documents must match this query. */
  positive: <<QueryDslQueryContainer>>
}
----


[discrete]
[[QueryDslChildScoreMode]]
=== QueryDslChildScoreMode

[source,ts,subs=+macros]
----
type QueryDslChildScoreMode = 'none' | 'avg' | 'sum' | 'max' | 'min'
----


[discrete]
[[QueryDslCombinedFieldsOperator]]
=== QueryDslCombinedFieldsOperator

[source,ts,subs=+macros]
----
type QueryDslCombinedFieldsOperator = 'or' | 'and'
----


[discrete]
[[QueryDslCombinedFieldsQuery]]
=== QueryDslCombinedFieldsQuery

[source,ts,subs=+macros]
----
interface QueryDslCombinedFieldsQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property fields List of fields to search. <<Field>> wildcard patterns are allowed. Only `text` fields are supported, and they must all have the same search `analyzer`. */
  fields: <<Field>>[]
  pass:[/**] @property query Text to search for in the provided `fields`. The `combined_fields` query analyzes the provided text before performing a search. */
  query: string
  pass:[/**] @property auto_generate_synonyms_phrase_query If true, match phrase queries are automatically created for multi-term synonyms. */
  auto_generate_synonyms_phrase_query?: boolean
  pass:[/**] @property operator Boolean logic used to interpret text in the query value. */
  operator?: <<QueryDslCombinedFieldsOperator>>
  pass:[/**] @property minimum_should_match Minimum number of clauses that must match for a document to be returned. */
  minimum_should_match?: <<MinimumShouldMatch>>
  pass:[/**] @property zero_terms_query Indicates whether no documents are returned if the analyzer removes all tokens, such as when using a `stop` filter. */
  zero_terms_query?: <<QueryDslCombinedFieldsZeroTerms>>
}
----


[discrete]
[[QueryDslCombinedFieldsZeroTerms]]
=== QueryDslCombinedFieldsZeroTerms

[source,ts,subs=+macros]
----
type QueryDslCombinedFieldsZeroTerms = 'none' | 'all'
----


[discrete]
[[QueryDslCommonTermsQuery]]
=== QueryDslCommonTermsQuery

[source,ts,subs=+macros]
----
interface QueryDslCommonTermsQuery extends <<QueryDslQueryBase>> {
  analyzer?: string
  cutoff_frequency?: <<double>>
  high_freq_operator?: <<QueryDslOperator>>
  low_freq_operator?: <<QueryDslOperator>>
  minimum_should_match?: <<MinimumShouldMatch>>
  query: string
}
----


[discrete]
[[QueryDslConstantScoreQuery]]
=== QueryDslConstantScoreQuery

[source,ts,subs=+macros]
----
interface QueryDslConstantScoreQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property filter Filter query you wish to run. Any returned documents must match this query. Filter queries do not calculate relevance scores. To speed up performance, Elasticsearch automatically caches frequently used filter queries. */
  filter: <<QueryDslQueryContainer>>
}
----


[discrete]
[[QueryDslDateDecayFunction]]
=== QueryDslDateDecayFunction

[source,ts,subs=+macros]
----
interface QueryDslDateDecayFunctionKeys extends <<QueryDslDecayFunctionBase>><<<DateMath>>, <<Duration>>> {}
type QueryDslDateDecayFunction = QueryDslDateDecayFunctionKeys
  & { [property: string]: <<QueryDslDecayPlacement>> | <<QueryDslMultiValueMode>> }
----


[discrete]
[[QueryDslDateDistanceFeatureQuery]]
=== QueryDslDateDistanceFeatureQuery

[source,ts,subs=+macros]
----
interface QueryDslDateDistanceFeatureQuery extends <<QueryDslDistanceFeatureQueryBase>><<<DateMath>>, <<Duration>>> {}
----


[discrete]
[[QueryDslDateRangeQuery]]
=== QueryDslDateRangeQuery

[source,ts,subs=+macros]
----
interface QueryDslDateRangeQuery extends <<QueryDslRangeQueryBase>><<<DateMath>>> {
  pass:[/**] @property format Date format used to convert `date` values in the query. */
  format?: <<DateFormat>>
  pass:[/**] @property time_zone Coordinated Universal Time (UTC) offset or IANA time zone used to convert `date` values in the query to UTC. */
  time_zone?: <<TimeZone>>
}
----


[discrete]
[[QueryDslDecayFunction]]
=== QueryDslDecayFunction

[source,ts,subs=+macros]
----
type QueryDslDecayFunction = <<QueryDslUntypedDecayFunction>> | <<QueryDslDateDecayFunction>> | <<QueryDslNumericDecayFunction>> | <<QueryDslGeoDecayFunction>>
----


[discrete]
[[QueryDslDecayFunctionBase]]
=== QueryDslDecayFunctionBase

[source,ts,subs=+macros]
----
interface QueryDslDecayFunctionBase<TOrigin = unknown, TScale = unknown> {
  pass:[/**] @property multi_value_mode Determines how the distance is calculated when a field used for computing the decay contains multiple values. */
  multi_value_mode?: <<QueryDslMultiValueMode>>
}
----


[discrete]
[[QueryDslDecayPlacement]]
=== QueryDslDecayPlacement

[source,ts,subs=+macros]
----
interface QueryDslDecayPlacement<TOrigin = unknown, TScale = unknown> {
  pass:[/**] @property decay Defines how documents are scored at the distance given at scale. */
  decay?: <<double>>
  pass:[/**] @property offset If defined, the decay function will only compute the decay function for documents with a distance greater than the defined `offset`. */
  offset?: TScale
  pass:[/**] @property scale Defines the distance from origin + offset at which the computed score will equal `decay` parameter. */
  scale?: TScale
  pass:[/**] @property origin The point of origin used for calculating distance. Must be given as a number for numeric field, date for date fields and geo point for geo fields. */
  origin?: TOrigin
}
----


[discrete]
[[QueryDslDisMaxQuery]]
=== QueryDslDisMaxQuery

[source,ts,subs=+macros]
----
interface QueryDslDisMaxQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property queries One or more query clauses. Returned documents must match one or more of these queries. If a document matches multiple queries, Elasticsearch uses the highest relevance score. */
  queries: <<QueryDslQueryContainer>>[]
  pass:[/**] @property tie_breaker Floating point number between 0 and 1.0 used to increase the relevance scores of documents matching multiple query clauses. */
  tie_breaker?: <<double>>
}
----


[discrete]
[[QueryDslDistanceFeatureQuery]]
=== QueryDslDistanceFeatureQuery

[source,ts,subs=+macros]
----
type QueryDslDistanceFeatureQuery = <<QueryDslUntypedDistanceFeatureQuery>> | <<QueryDslGeoDistanceFeatureQuery>> | <<QueryDslDateDistanceFeatureQuery>>
----


[discrete]
[[QueryDslDistanceFeatureQueryBase]]
=== QueryDslDistanceFeatureQueryBase

[source,ts,subs=+macros]
----
interface QueryDslDistanceFeatureQueryBase<TOrigin = unknown, TDistance = unknown> extends <<QueryDslQueryBase>> {
  pass:[/**] @property origin Date or point of origin used to calculate distances. If the `field` value is a `date` or `date_nanos` field, the `origin` value must be a date. Date Math, such as `now-1h`, is supported. If the field value is a `geo_point` field, the `origin` value must be a geopoint. */
  origin: TOrigin
  pass:[/**] @property pivot <<Distance>> from the `origin` at which relevance scores receive half of the `boost` value. If the `field` value is a `date` or `date_nanos` field, the `pivot` value must be a time unit, such as `1h` or `10d`. If the `field` value is a `geo_point` field, the `pivot` value must be a distance unit, such as `1km` or `12m`. */
  pivot: TDistance
  pass:[/**] @property field <<Name>> of the field used to calculate distances. This field must meet the following criteria: be a `date`, `date_nanos` or `geo_point` field; have an `index` mapping parameter value of `true`, which is the default; have an `doc_values` mapping parameter value of `true`, which is the default. */
  field: <<Field>>
}
----


[discrete]
[[QueryDslExistsQuery]]
=== QueryDslExistsQuery

[source,ts,subs=+macros]
----
interface QueryDslExistsQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property field <<Name>> of the field you wish to search. */
  field: <<Field>>
}
----


[discrete]
[[QueryDslFieldAndFormat]]
=== QueryDslFieldAndFormat

[source,ts,subs=+macros]
----
interface QueryDslFieldAndFormat {
  pass:[/**] @property field Wildcard pattern. The request returns values for field names matching this pattern. */
  field: <<Field>>
  pass:[/**] @property format Format in which the values are returned. */
  format?: string
  include_unmapped?: boolean
}
----


[discrete]
[[QueryDslFieldLookup]]
=== QueryDslFieldLookup

[source,ts,subs=+macros]
----
interface QueryDslFieldLookup {
  pass:[/**] @property id `id` of the document. */
  id: <<Id>>
  pass:[/**] @property index Index from which to retrieve the document. */
  index?: <<IndexName>>
  pass:[/**] @property path <<Name>> of the field. */
  path?: <<Field>>
  pass:[/**] @property routing Custom routing value. */
  routing?: <<Routing>>
}
----


[discrete]
[[QueryDslFieldValueFactorModifier]]
=== QueryDslFieldValueFactorModifier

[source,ts,subs=+macros]
----
type QueryDslFieldValueFactorModifier = 'none' | 'log' | 'log1p' | 'log2p' | 'ln' | 'ln1p' | 'ln2p' | 'square' | 'sqrt' | 'reciprocal'
----


[discrete]
[[QueryDslFieldValueFactorScoreFunction]]
=== QueryDslFieldValueFactorScoreFunction

[source,ts,subs=+macros]
----
interface QueryDslFieldValueFactorScoreFunction {
  pass:[/**] @property field <<Field>> to be extracted from the document. */
  field: <<Field>>
  pass:[/**] @property factor Optional factor to multiply the field value with. */
  factor?: <<double>>
  pass:[/**] @property missing Value used if the document doesn’t have that field. The modifier and factor are still applied to it as though it were read from the document. */
  missing?: <<double>>
  pass:[/**] @property modifier Modifier to apply to the field value. */
  modifier?: <<QueryDslFieldValueFactorModifier>>
}
----


[discrete]
[[QueryDslFunctionBoostMode]]
=== QueryDslFunctionBoostMode

[source,ts,subs=+macros]
----
type QueryDslFunctionBoostMode = 'multiply' | 'replace' | 'sum' | 'avg' | 'max' | 'min'
----


[discrete]
[[QueryDslFunctionScoreContainer]]
=== QueryDslFunctionScoreContainer

[source,ts,subs=+macros]
----
interface QueryDslFunctionScoreContainer {
  pass:[/**] @property exp Function that scores a document with a exponential decay, depending on the distance of a numeric field value of the document from an origin. */
  exp?: <<QueryDslDecayFunction>>
  pass:[/**] @property gauss Function that scores a document with a normal decay, depending on the distance of a numeric field value of the document from an origin. */
  gauss?: <<QueryDslDecayFunction>>
  pass:[/**] @property linear Function that scores a document with a linear decay, depending on the distance of a numeric field value of the document from an origin. */
  linear?: <<QueryDslDecayFunction>>
  pass:[/**] @property field_value_factor Function allows you to use a field from a document to influence the score. It’s similar to using the script_score function, however, it avoids the overhead of scripting. */
  field_value_factor?: <<QueryDslFieldValueFactorScoreFunction>>
  pass:[/**] @property random_score Generates scores that are uniformly distributed from 0 up to but not including 1. In case you want scores to be reproducible, it is possible to provide a `seed` and `field`. */
  random_score?: <<QueryDslRandomScoreFunction>>
  pass:[/**] @property script_score Enables you to wrap another query and customize the scoring of it optionally with a computation derived from other numeric field values in the doc using a script expression. */
  script_score?: <<QueryDslScriptScoreFunction>>
  filter?: <<QueryDslQueryContainer>>
  weight?: <<double>>
}
----


[discrete]
[[QueryDslFunctionScoreMode]]
=== QueryDslFunctionScoreMode

[source,ts,subs=+macros]
----
type QueryDslFunctionScoreMode = 'multiply' | 'sum' | 'avg' | 'first' | 'max' | 'min'
----


[discrete]
[[QueryDslFunctionScoreQuery]]
=== QueryDslFunctionScoreQuery

[source,ts,subs=+macros]
----
interface QueryDslFunctionScoreQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property boost_mode Defines how he newly computed score is combined with the score of the query */
  boost_mode?: <<QueryDslFunctionBoostMode>>
  pass:[/**] @property functions One or more functions that compute a new score for each document returned by the query. */
  functions?: <<QueryDslFunctionScoreContainer>>[]
  pass:[/**] @property max_boost Restricts the new score to not exceed the provided limit. */
  max_boost?: <<double>>
  pass:[/**] @property min_score Excludes documents that do not meet the provided score threshold. */
  min_score?: <<double>>
  pass:[/**] @property query A query that determines the documents for which a new score is computed. */
  query?: <<QueryDslQueryContainer>>
  pass:[/**] @property score_mode Specifies how the computed scores are combined */
  score_mode?: <<QueryDslFunctionScoreMode>>
}
----


[discrete]
[[QueryDslFuzzyQuery]]
=== QueryDslFuzzyQuery

[source,ts,subs=+macros]
----
interface QueryDslFuzzyQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property max_expansions Maximum number of variations created. */
  max_expansions?: <<integer>>
  pass:[/**] @property prefix_length Number of beginning characters left unchanged when creating expansions. */
  prefix_length?: <<integer>>
  pass:[/**] @property rewrite Number of beginning characters left unchanged when creating expansions. */
  rewrite?: <<MultiTermQueryRewrite>>
  pass:[/**] @property transpositions Indicates whether edits include transpositions of two adjacent characters (for example `ab` to `ba`). */
  transpositions?: boolean
  pass:[/**] @property fuzziness Maximum edit distance allowed for matching. */
  fuzziness?: <<Fuzziness>>
  pass:[/**] @property value Term you wish to find in the provided field. */
  value: string | <<double>> | boolean
}
----


[discrete]
[[QueryDslGeoBoundingBoxQuery]]
=== QueryDslGeoBoundingBoxQuery

[source,ts,subs=+macros]
----
interface QueryDslGeoBoundingBoxQueryKeys extends <<QueryDslQueryBase>> {
  type?: <<QueryDslGeoExecution>>
  validation_method?: <<QueryDslGeoValidationMethod>>
  ignore_unmapped?: boolean
}
type QueryDslGeoBoundingBoxQuery = QueryDslGeoBoundingBoxQueryKeys
  & { [property: string]: <<GeoBounds>> | <<QueryDslGeoExecution>> | <<QueryDslGeoValidationMethod>> | boolean | <<float>> | string }
----


[discrete]
[[QueryDslGeoDecayFunction]]
=== QueryDslGeoDecayFunction

[source,ts,subs=+macros]
----
interface QueryDslGeoDecayFunctionKeys extends <<QueryDslDecayFunctionBase>><<<GeoLocation>>, <<Distance>>> {}
type QueryDslGeoDecayFunction = QueryDslGeoDecayFunctionKeys
  & { [property: string]: <<QueryDslDecayPlacement>> | <<QueryDslMultiValueMode>> }
----


[discrete]
[[QueryDslGeoDistanceFeatureQuery]]
=== QueryDslGeoDistanceFeatureQuery

[source,ts,subs=+macros]
----
interface QueryDslGeoDistanceFeatureQuery extends <<QueryDslDistanceFeatureQueryBase>><<<GeoLocation>>, <<Distance>>> {}
----


[discrete]
[[QueryDslGeoDistanceQuery]]
=== QueryDslGeoDistanceQuery

[source,ts,subs=+macros]
----
interface QueryDslGeoDistanceQueryKeys extends <<QueryDslQueryBase>> {
  distance: <<Distance>>
  distance_type?: <<GeoDistanceType>>
  validation_method?: <<QueryDslGeoValidationMethod>>
  ignore_unmapped?: boolean
}
type QueryDslGeoDistanceQuery = QueryDslGeoDistanceQueryKeys
  & { [property: string]: <<GeoLocation>> | <<Distance>> | <<GeoDistanceType>> | <<QueryDslGeoValidationMethod>> | boolean | <<float>> | string }
----


[discrete]
[[QueryDslGeoExecution]]
=== QueryDslGeoExecution

[source,ts,subs=+macros]
----
type QueryDslGeoExecution = 'memory' | 'indexed'
----


[discrete]
[[QueryDslGeoPolygonPoints]]
=== QueryDslGeoPolygonPoints

[source,ts,subs=+macros]
----
interface QueryDslGeoPolygonPoints {
  points: <<GeoLocation>>[]
}
----


[discrete]
[[QueryDslGeoPolygonQuery]]
=== QueryDslGeoPolygonQuery

[source,ts,subs=+macros]
----
interface QueryDslGeoPolygonQueryKeys extends <<QueryDslQueryBase>> {
  validation_method?: <<QueryDslGeoValidationMethod>>
  ignore_unmapped?: boolean
}
type QueryDslGeoPolygonQuery = QueryDslGeoPolygonQueryKeys
  & { [property: string]: <<QueryDslGeoPolygonPoints>> | <<QueryDslGeoValidationMethod>> | boolean | <<float>> | string }
----


[discrete]
[[QueryDslGeoShapeFieldQuery]]
=== QueryDslGeoShapeFieldQuery

[source,ts,subs=+macros]
----
interface QueryDslGeoShapeFieldQuery {
  shape?: <<GeoShape>>
  pass:[/**] @property indexed_shape Query using an indexed shape retrieved from the the specified document and path. */
  indexed_shape?: <<QueryDslFieldLookup>>
  pass:[/**] @property relation Spatial relation operator used to search a geo field. */
  relation?: <<GeoShapeRelation>>
}
----


[discrete]
[[QueryDslGeoShapeQuery]]
=== QueryDslGeoShapeQuery

[source,ts,subs=+macros]
----
interface QueryDslGeoShapeQueryKeys extends <<QueryDslQueryBase>> {
  ignore_unmapped?: boolean
}
type QueryDslGeoShapeQuery = QueryDslGeoShapeQueryKeys
  & { [property: string]: <<QueryDslGeoShapeFieldQuery>> | boolean | <<float>> | string }
----


[discrete]
[[QueryDslGeoValidationMethod]]
=== QueryDslGeoValidationMethod

[source,ts,subs=+macros]
----
type QueryDslGeoValidationMethod = 'coerce' | 'ignore_malformed' | 'strict'
----


[discrete]
[[QueryDslHasChildQuery]]
=== QueryDslHasChildQuery

[source,ts,subs=+macros]
----
interface QueryDslHasChildQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property ignore_unmapped Indicates whether to ignore an unmapped `type` and not return any documents instead of an error. */
  ignore_unmapped?: boolean
  pass:[/**] @property inner_hits If defined, each search hit will contain inner hits. */
  inner_hits?: <<SearchInnerHits>>
  pass:[/**] @property max_children Maximum number of child documents that match the query allowed for a returned parent document. If the parent document exceeds this limit, it is excluded from the search results. */
  max_children?: <<integer>>
  pass:[/**] @property min_children Minimum number of child documents that match the query required to match the query for a returned parent document. If the parent document does not meet this limit, it is excluded from the search results. */
  min_children?: <<integer>>
  pass:[/**] @property query Query you wish to run on child documents of the `type` field. If a child document matches the search, the query returns the parent document. */
  query: <<QueryDslQueryContainer>>
  pass:[/**] @property score_mode Indicates how scores for matching child documents affect the root parent document’s relevance score. */
  score_mode?: <<QueryDslChildScoreMode>>
  pass:[/**] @property type <<Name>> of the child relationship mapped for the `join` field. */
  type: <<RelationName>>
}
----


[discrete]
[[QueryDslHasParentQuery]]
=== QueryDslHasParentQuery

[source,ts,subs=+macros]
----
interface QueryDslHasParentQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property ignore_unmapped Indicates whether to ignore an unmapped `parent_type` and not return any documents instead of an error. You can use this parameter to query multiple indices that may not contain the `parent_type`. */
  ignore_unmapped?: boolean
  pass:[/**] @property inner_hits If defined, each search hit will contain inner hits. */
  inner_hits?: <<SearchInnerHits>>
  pass:[/**] @property parent_type <<Name>> of the parent relationship mapped for the `join` field. */
  parent_type: <<RelationName>>
  pass:[/**] @property query Query you wish to run on parent documents of the `parent_type` field. If a parent document matches the search, the query returns its child documents. */
  query: <<QueryDslQueryContainer>>
  pass:[/**] @property score Indicates whether the relevance score of a matching parent document is aggregated into its child documents. */
  score?: boolean
}
----


[discrete]
[[QueryDslIdsQuery]]
=== QueryDslIdsQuery

[source,ts,subs=+macros]
----
interface QueryDslIdsQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property values An array of document IDs. */
  values?: <<Ids>>
}
----


[discrete]
[[QueryDslIntervalsAllOf]]
=== QueryDslIntervalsAllOf

[source,ts,subs=+macros]
----
interface QueryDslIntervalsAllOf {
  pass:[/**] @property intervals An array of rules to combine. All rules must produce a match in a document for the overall source to match. */
  intervals: <<QueryDslIntervalsContainer>>[]
  pass:[/**] @property max_gaps Maximum number of positions between the matching terms. Intervals produced by the rules further apart than this are not considered matches. */
  max_gaps?: <<integer>>
  pass:[/**] @property ordered If `true`, intervals produced by the rules should appear in the order in which they are specified. */
  ordered?: boolean
  pass:[/**] @property filter Rule used to filter returned intervals. */
  filter?: <<QueryDslIntervalsFilter>>
}
----


[discrete]
[[QueryDslIntervalsAnyOf]]
=== QueryDslIntervalsAnyOf

[source,ts,subs=+macros]
----
interface QueryDslIntervalsAnyOf {
  pass:[/**] @property intervals An array of rules to match. */
  intervals: <<QueryDslIntervalsContainer>>[]
  pass:[/**] @property filter Rule used to filter returned intervals. */
  filter?: <<QueryDslIntervalsFilter>>
}
----


[discrete]
[[QueryDslIntervalsContainer]]
=== QueryDslIntervalsContainer

[source,ts,subs=+macros]
----
interface QueryDslIntervalsContainer {
  pass:[/**] @property all_of Returns matches that span a combination of other rules. */
  all_of?: <<QueryDslIntervalsAllOf>>
  pass:[/**] @property any_of Returns intervals produced by any of its sub-rules. */
  any_of?: <<QueryDslIntervalsAnyOf>>
  pass:[/**] @property fuzzy Matches analyzed text. */
  fuzzy?: <<QueryDslIntervalsFuzzy>>
  pass:[/**] @property match Matches analyzed text. */
  match?: <<QueryDslIntervalsMatch>>
  pass:[/**] @property prefix Matches terms that start with a specified set of characters. */
  prefix?: <<QueryDslIntervalsPrefix>>
  pass:[/**] @property wildcard Matches terms using a wildcard pattern. */
  wildcard?: <<QueryDslIntervalsWildcard>>
}
----


[discrete]
[[QueryDslIntervalsFilter]]
=== QueryDslIntervalsFilter

[source,ts,subs=+macros]
----
interface QueryDslIntervalsFilter {
  pass:[/**] @property after Query used to return intervals that follow an interval from the `filter` rule. */
  after?: <<QueryDslIntervalsContainer>>
  pass:[/**] @property before Query used to return intervals that occur before an interval from the `filter` rule. */
  before?: <<QueryDslIntervalsContainer>>
  pass:[/**] @property contained_by Query used to return intervals contained by an interval from the `filter` rule. */
  contained_by?: <<QueryDslIntervalsContainer>>
  pass:[/**] @property containing Query used to return intervals that contain an interval from the `filter` rule. */
  containing?: <<QueryDslIntervalsContainer>>
  pass:[/**] @property not_contained_by Query used to return intervals that are **not** contained by an interval from the `filter` rule. */
  not_contained_by?: <<QueryDslIntervalsContainer>>
  pass:[/**] @property not_containing Query used to return intervals that do **not** contain an interval from the `filter` rule. */
  not_containing?: <<QueryDslIntervalsContainer>>
  pass:[/**] @property not_overlapping Query used to return intervals that do **not** overlap with an interval from the `filter` rule. */
  not_overlapping?: <<QueryDslIntervalsContainer>>
  pass:[/**] @property overlapping Query used to return intervals that overlap with an interval from the `filter` rule. */
  overlapping?: <<QueryDslIntervalsContainer>>
  pass:[/**] @property script <<Script>> used to return matching documents. This script must return a boolean value: `true` or `false`. */
  script?: <<Script>> | string
}
----


[discrete]
[[QueryDslIntervalsFuzzy]]
=== QueryDslIntervalsFuzzy

[source,ts,subs=+macros]
----
interface QueryDslIntervalsFuzzy {
  pass:[/**] @property analyzer Analyzer used to normalize the term. */
  analyzer?: string
  pass:[/**] @property fuzziness Maximum edit distance allowed for matching. */
  fuzziness?: <<Fuzziness>>
  pass:[/**] @property prefix_length Number of beginning characters left unchanged when creating expansions. */
  prefix_length?: <<integer>>
  pass:[/**] @property term The term to match. */
  term: string
  pass:[/**] @property transpositions Indicates whether edits include transpositions of two adjacent characters (for example, `ab` to `ba`). */
  transpositions?: boolean
  pass:[/**] @property use_field If specified, match intervals from this field rather than the top-level field. The `term` is normalized using the search analyzer from this field, unless `analyzer` is specified separately. */
  use_field?: <<Field>>
}
----


[discrete]
[[QueryDslIntervalsMatch]]
=== QueryDslIntervalsMatch

[source,ts,subs=+macros]
----
interface QueryDslIntervalsMatch {
  pass:[/**] @property analyzer Analyzer used to analyze terms in the query. */
  analyzer?: string
  pass:[/**] @property max_gaps Maximum number of positions between the matching terms. Terms further apart than this are not considered matches. */
  max_gaps?: <<integer>>
  pass:[/**] @property ordered If `true`, matching terms must appear in their specified order. */
  ordered?: boolean
  pass:[/**] @property query Text you wish to find in the provided field. */
  query: string
  pass:[/**] @property use_field If specified, match intervals from this field rather than the top-level field. The `term` is normalized using the search analyzer from this field, unless `analyzer` is specified separately. */
  use_field?: <<Field>>
  pass:[/**] @property filter An optional interval filter. */
  filter?: <<QueryDslIntervalsFilter>>
}
----


[discrete]
[[QueryDslIntervalsPrefix]]
=== QueryDslIntervalsPrefix

[source,ts,subs=+macros]
----
interface QueryDslIntervalsPrefix {
  pass:[/**] @property analyzer Analyzer used to analyze the `prefix`. */
  analyzer?: string
  pass:[/**] @property prefix Beginning characters of terms you wish to find in the top-level field. */
  prefix: string
  pass:[/**] @property use_field If specified, match intervals from this field rather than the top-level field. The `prefix` is normalized using the search analyzer from this field, unless `analyzer` is specified separately. */
  use_field?: <<Field>>
}
----


[discrete]
[[QueryDslIntervalsQuery]]
=== QueryDslIntervalsQuery

[source,ts,subs=+macros]
----
interface QueryDslIntervalsQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property all_of Returns matches that span a combination of other rules. */
  all_of?: <<QueryDslIntervalsAllOf>>
  pass:[/**] @property any_of Returns intervals produced by any of its sub-rules. */
  any_of?: <<QueryDslIntervalsAnyOf>>
  pass:[/**] @property fuzzy Matches terms that are similar to the provided term, within an edit distance defined by `fuzziness`. */
  fuzzy?: <<QueryDslIntervalsFuzzy>>
  pass:[/**] @property match Matches analyzed text. */
  match?: <<QueryDslIntervalsMatch>>
  pass:[/**] @property prefix Matches terms that start with a specified set of characters. */
  prefix?: <<QueryDslIntervalsPrefix>>
  pass:[/**] @property wildcard Matches terms using a wildcard pattern. */
  wildcard?: <<QueryDslIntervalsWildcard>>
}
----


[discrete]
[[QueryDslIntervalsWildcard]]
=== QueryDslIntervalsWildcard

[source,ts,subs=+macros]
----
interface QueryDslIntervalsWildcard {
  pass:[/**] @property analyzer Analyzer used to analyze the `pattern`. Defaults to the top-level field's analyzer. */
  analyzer?: string
  pass:[/**] @property pattern Wildcard pattern used to find matching terms. */
  pattern: string
  pass:[/**] @property use_field If specified, match intervals from this field rather than the top-level field. The `pattern` is normalized using the search analyzer from this field, unless `analyzer` is specified separately. */
  use_field?: <<Field>>
}
----


[discrete]
[[QueryDslLike]]
=== QueryDslLike

[source,ts,subs=+macros]
----
type QueryDslLike = string | <<QueryDslLikeDocument>>
----


[discrete]
[[QueryDslLikeDocument]]
=== QueryDslLikeDocument

[source,ts,subs=+macros]
----
interface QueryDslLikeDocument {
  pass:[/**] @property doc A document not present in the index. */
  doc?: any
  fields?: <<Field>>[]
  pass:[/**] @property _id ID of a document. */
  _id?: <<Id>>
  pass:[/**] @property _index Index of a document. */
  _index?: <<IndexName>>
  pass:[/**] @property per_field_analyzer Overrides the default analyzer. */
  per_field_analyzer?: Record<<<Field>>, string>
  routing?: <<Routing>>
  version?: <<VersionNumber>>
  version_type?: <<VersionType>>
}
----


[discrete]
[[QueryDslMatchAllQuery]]
=== QueryDslMatchAllQuery

[source,ts,subs=+macros]
----
interface QueryDslMatchAllQuery extends <<QueryDslQueryBase>> {}
----


[discrete]
[[QueryDslMatchBoolPrefixQuery]]
=== QueryDslMatchBoolPrefixQuery

[source,ts,subs=+macros]
----
interface QueryDslMatchBoolPrefixQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property analyzer Analyzer used to convert the text in the query value into tokens. */
  analyzer?: string
  pass:[/**] @property fuzziness Maximum edit distance allowed for matching. Can be applied to the term subqueries constructed for all terms but the final term. */
  fuzziness?: <<Fuzziness>>
  pass:[/**] @property fuzzy_rewrite Method used to rewrite the query. Can be applied to the term subqueries constructed for all terms but the final term. */
  fuzzy_rewrite?: <<MultiTermQueryRewrite>>
  pass:[/**] @property fuzzy_transpositions If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`). Can be applied to the term subqueries constructed for all terms but the final term. */
  fuzzy_transpositions?: boolean
  pass:[/**] @property max_expansions Maximum number of terms to which the query will expand. Can be applied to the term subqueries constructed for all terms but the final term. */
  max_expansions?: <<integer>>
  pass:[/**] @property minimum_should_match Minimum number of clauses that must match for a document to be returned. Applied to the constructed bool query. */
  minimum_should_match?: <<MinimumShouldMatch>>
  pass:[/**] @property operator Boolean logic used to interpret text in the query value. Applied to the constructed bool query. */
  operator?: <<QueryDslOperator>>
  pass:[/**] @property prefix_length Number of beginning characters left unchanged for fuzzy matching. Can be applied to the term subqueries constructed for all terms but the final term. */
  prefix_length?: <<integer>>
  pass:[/**] @property query Terms you wish to find in the provided field. The last term is used in a prefix query. */
  query: string
}
----


[discrete]
[[QueryDslMatchNoneQuery]]
=== QueryDslMatchNoneQuery

[source,ts,subs=+macros]
----
interface QueryDslMatchNoneQuery extends <<QueryDslQueryBase>> {}
----


[discrete]
[[QueryDslMatchPhrasePrefixQuery]]
=== QueryDslMatchPhrasePrefixQuery

[source,ts,subs=+macros]
----
interface QueryDslMatchPhrasePrefixQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property analyzer Analyzer used to convert text in the query value into tokens. */
  analyzer?: string
  pass:[/**] @property max_expansions Maximum number of terms to which the last provided term of the query value will expand. */
  max_expansions?: <<integer>>
  pass:[/**] @property query Text you wish to find in the provided field. */
  query: string
  pass:[/**] @property slop Maximum number of positions allowed between matching tokens. */
  slop?: <<integer>>
  pass:[/**] @property zero_terms_query Indicates whether no documents are returned if the analyzer removes all tokens, such as when using a `stop` filter. */
  zero_terms_query?: <<QueryDslZeroTermsQuery>>
}
----


[discrete]
[[QueryDslMatchPhraseQuery]]
=== QueryDslMatchPhraseQuery

[source,ts,subs=+macros]
----
interface QueryDslMatchPhraseQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property analyzer Analyzer used to convert the text in the query value into tokens. */
  analyzer?: string
  pass:[/**] @property query Query terms that are analyzed and turned into a phrase query. */
  query: string
  pass:[/**] @property slop Maximum number of positions allowed between matching tokens. */
  slop?: <<integer>>
  pass:[/**] @property zero_terms_query Indicates whether no documents are returned if the `analyzer` removes all tokens, such as when using a `stop` filter. */
  zero_terms_query?: <<QueryDslZeroTermsQuery>>
}
----


[discrete]
[[QueryDslMatchQuery]]
=== QueryDslMatchQuery

[source,ts,subs=+macros]
----
interface QueryDslMatchQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property analyzer Analyzer used to convert the text in the query value into tokens. */
  analyzer?: string
  pass:[/**] @property auto_generate_synonyms_phrase_query If `true`, match phrase queries are automatically created for multi-term synonyms. */
  auto_generate_synonyms_phrase_query?: boolean
  cutoff_frequency?: <<double>>
  pass:[/**] @property fuzziness Maximum edit distance allowed for matching. */
  fuzziness?: <<Fuzziness>>
  pass:[/**] @property fuzzy_rewrite Method used to rewrite the query. */
  fuzzy_rewrite?: <<MultiTermQueryRewrite>>
  pass:[/**] @property fuzzy_transpositions If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`). */
  fuzzy_transpositions?: boolean
  pass:[/**] @property lenient If `true`, format-based errors, such as providing a text query value for a numeric field, are ignored. */
  lenient?: boolean
  pass:[/**] @property max_expansions Maximum number of terms to which the query will expand. */
  max_expansions?: <<integer>>
  pass:[/**] @property minimum_should_match Minimum number of clauses that must match for a document to be returned. */
  minimum_should_match?: <<MinimumShouldMatch>>
  pass:[/**] @property operator Boolean logic used to interpret text in the query value. */
  operator?: <<QueryDslOperator>>
  pass:[/**] @property prefix_length Number of beginning characters left unchanged for fuzzy matching. */
  prefix_length?: <<integer>>
  pass:[/**] @property query Text, number, boolean value or date you wish to find in the provided field. */
  query: string | <<float>> | boolean
  pass:[/**] @property zero_terms_query Indicates whether no documents are returned if the `analyzer` removes all tokens, such as when using a `stop` filter. */
  zero_terms_query?: <<QueryDslZeroTermsQuery>>
}
----


[discrete]
[[QueryDslMoreLikeThisQuery]]
=== QueryDslMoreLikeThisQuery

[source,ts,subs=+macros]
----
interface QueryDslMoreLikeThisQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property analyzer The analyzer that is used to analyze the free form text. Defaults to the analyzer associated with the first field in fields. */
  analyzer?: string
  pass:[/**] @property boost_terms Each term in the formed query could be further boosted by their tf-idf score. This sets the boost factor to use when using this feature. Defaults to deactivated (0). */
  boost_terms?: <<double>>
  pass:[/**] @property fail_on_unsupported_field Controls whether the query should fail (throw an exception) if any of the specified fields are not of the supported types (`text` or `keyword`). */
  fail_on_unsupported_field?: boolean
  pass:[/**] @property fields A list of fields to fetch and analyze the text from. Defaults to the `index.query.default_field` index setting, which has a default value of `*`. */
  fields?: <<Field>>[]
  pass:[/**] @property include Specifies whether the input documents should also be included in the search results returned. */
  include?: boolean
  pass:[/**] @property like Specifies free form text and/or a single or multiple documents for which you want to find similar documents. */
  like: <<QueryDslLike>> | <<QueryDslLike>>[]
  pass:[/**] @property max_doc_freq The maximum document frequency above which the terms are ignored from the input document. */
  max_doc_freq?: <<integer>>
  pass:[/**] @property max_query_terms The maximum number of query terms that can be selected. */
  max_query_terms?: <<integer>>
  pass:[/**] @property max_word_length The maximum word length above which the terms are ignored. Defaults to unbounded (`0`). */
  max_word_length?: <<integer>>
  pass:[/**] @property min_doc_freq The minimum document frequency below which the terms are ignored from the input document. */
  min_doc_freq?: <<integer>>
  pass:[/**] @property minimum_should_match After the disjunctive query has been formed, this parameter controls the number of terms that must match. */
  minimum_should_match?: <<MinimumShouldMatch>>
  pass:[/**] @property min_term_freq The minimum term frequency below which the terms are ignored from the input document. */
  min_term_freq?: <<integer>>
  pass:[/**] @property min_word_length The minimum word length below which the terms are ignored. */
  min_word_length?: <<integer>>
  routing?: <<Routing>>
  pass:[/**] @property stop_words An array of stop words. Any word in this set is ignored. */
  stop_words?: <<AnalysisStopWords>>
  pass:[/**] @property unlike Used in combination with `like` to exclude documents that match a set of terms. */
  unlike?: <<QueryDslLike>> | <<QueryDslLike>>[]
  version?: <<VersionNumber>>
  version_type?: <<VersionType>>
}
----


[discrete]
[[QueryDslMultiMatchQuery]]
=== QueryDslMultiMatchQuery

[source,ts,subs=+macros]
----
interface QueryDslMultiMatchQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property analyzer Analyzer used to convert the text in the query value into tokens. */
  analyzer?: string
  pass:[/**] @property auto_generate_synonyms_phrase_query If `true`, match phrase queries are automatically created for multi-term synonyms. */
  auto_generate_synonyms_phrase_query?: boolean
  cutoff_frequency?: <<double>>
  pass:[/**] @property fields The fields to be queried. Defaults to the `index.query.default_field` index settings, which in turn defaults to `*`. */
  fields?: <<Fields>>
  pass:[/**] @property fuzziness Maximum edit distance allowed for matching. */
  fuzziness?: <<Fuzziness>>
  pass:[/**] @property fuzzy_rewrite Method used to rewrite the query. */
  fuzzy_rewrite?: <<MultiTermQueryRewrite>>
  pass:[/**] @property fuzzy_transpositions If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`). Can be applied to the term subqueries constructed for all terms but the final term. */
  fuzzy_transpositions?: boolean
  pass:[/**] @property lenient If `true`, format-based errors, such as providing a text query value for a numeric field, are ignored. */
  lenient?: boolean
  pass:[/**] @property max_expansions Maximum number of terms to which the query will expand. */
  max_expansions?: <<integer>>
  pass:[/**] @property minimum_should_match Minimum number of clauses that must match for a document to be returned. */
  minimum_should_match?: <<MinimumShouldMatch>>
  pass:[/**] @property operator Boolean logic used to interpret text in the query value. */
  operator?: <<QueryDslOperator>>
  pass:[/**] @property prefix_length Number of beginning characters left unchanged for fuzzy matching. */
  prefix_length?: <<integer>>
  pass:[/**] @property query Text, number, boolean value or date you wish to find in the provided field. */
  query: string
  pass:[/**] @property slop Maximum number of positions allowed between matching tokens. */
  slop?: <<integer>>
  pass:[/**] @property tie_breaker Determines how scores for each per-term blended query and scores across groups are combined. */
  tie_breaker?: <<double>>
  pass:[/**] @property type How `the` multi_match query is executed internally. */
  type?: <<QueryDslTextQueryType>>
  pass:[/**] @property zero_terms_query Indicates whether no documents are returned if the `analyzer` removes all tokens, such as when using a `stop` filter. */
  zero_terms_query?: <<QueryDslZeroTermsQuery>>
}
----


[discrete]
[[QueryDslMultiValueMode]]
=== QueryDslMultiValueMode

[source,ts,subs=+macros]
----
type QueryDslMultiValueMode = 'min' | 'max' | 'avg' | 'sum'
----


[discrete]
[[QueryDslNestedQuery]]
=== QueryDslNestedQuery

[source,ts,subs=+macros]
----
interface QueryDslNestedQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property ignore_unmapped Indicates whether to ignore an unmapped path and not return any documents instead of an error. */
  ignore_unmapped?: boolean
  pass:[/**] @property inner_hits If defined, each search hit will contain inner hits. */
  inner_hits?: <<SearchInnerHits>>
  pass:[/**] @property path Path to the nested object you wish to search. */
  path: <<Field>>
  pass:[/**] @property query Query you wish to run on nested objects in the path. */
  query: <<QueryDslQueryContainer>>
  pass:[/**] @property score_mode How scores for matching child objects affect the root parent document’s relevance score. */
  score_mode?: <<QueryDslChildScoreMode>>
}
----


[discrete]
[[QueryDslNumberRangeQuery]]
=== QueryDslNumberRangeQuery

[source,ts,subs=+macros]
----
interface QueryDslNumberRangeQuery extends <<QueryDslRangeQueryBase>><<<double>>> {}
----


[discrete]
[[QueryDslNumericDecayFunction]]
=== QueryDslNumericDecayFunction

[source,ts,subs=+macros]
----
interface QueryDslNumericDecayFunctionKeys extends <<QueryDslDecayFunctionBase>><<<double>>, <<double>>> {}
type QueryDslNumericDecayFunction = QueryDslNumericDecayFunctionKeys
  & { [property: string]: <<QueryDslDecayPlacement>> | <<QueryDslMultiValueMode>> }
----


[discrete]
[[QueryDslOperator]]
=== QueryDslOperator

[source,ts,subs=+macros]
----
type QueryDslOperator = 'and' | 'AND' | 'or' | 'OR'
----


[discrete]
[[QueryDslParentIdQuery]]
=== QueryDslParentIdQuery

[source,ts,subs=+macros]
----
interface QueryDslParentIdQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property id ID of the parent document. */
  id?: <<Id>>
  pass:[/**] @property ignore_unmapped Indicates whether to ignore an unmapped `type` and not return any documents instead of an error. */
  ignore_unmapped?: boolean
  pass:[/**] @property type <<Name>> of the child relationship mapped for the `join` field. */
  type?: <<RelationName>>
}
----


[discrete]
[[QueryDslPercolateQuery]]
=== QueryDslPercolateQuery

[source,ts,subs=+macros]
----
interface QueryDslPercolateQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property document The source of the document being percolated. */
  document?: any
  pass:[/**] @property documents An array of sources of the documents being percolated. */
  documents?: any[]
  pass:[/**] @property field <<Field>> that holds the indexed queries. The field must use the `percolator` mapping type. */
  field: <<Field>>
  pass:[/**] @property id The ID of a stored document to percolate. */
  id?: <<Id>>
  pass:[/**] @property index The index of a stored document to percolate. */
  index?: <<IndexName>>
  pass:[/**] @property name The suffix used for the `_percolator_document_slot` field when multiple `percolate` queries are specified. */
  name?: string
  pass:[/**] @property preference Preference used to fetch document to percolate. */
  preference?: string
  pass:[/**] @property routing <<Routing>> used to fetch document to percolate. */
  routing?: <<Routing>>
  pass:[/**] @property version The expected version of a stored document to percolate. */
  version?: <<VersionNumber>>
}
----


[discrete]
[[QueryDslPinnedDoc]]
=== QueryDslPinnedDoc

[source,ts,subs=+macros]
----
interface QueryDslPinnedDoc {
  pass:[/**] @property _id The unique document ID. */
  _id: <<Id>>
  pass:[/**] @property _index The index that contains the document. */
  _index: <<IndexName>>
}
----


[discrete]
[[QueryDslPinnedQuery]]
=== QueryDslPinnedQuery

[source,ts,subs=+macros]
----
interface QueryDslPinnedQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property organic Any choice of query used to rank documents which will be ranked below the "pinned" documents. */
  organic: <<QueryDslQueryContainer>>
  pass:[/**] @property ids Document IDs listed in the order they are to appear in results. Required if `docs` is not specified. */
  ids?: <<Id>>[]
  pass:[/**] @property docs Documents listed in the order they are to appear in results. Required if `ids` is not specified. */
  docs?: <<QueryDslPinnedDoc>>[]
}
----


[discrete]
[[QueryDslPrefixQuery]]
=== QueryDslPrefixQuery

[source,ts,subs=+macros]
----
interface QueryDslPrefixQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property rewrite Method used to rewrite the query. */
  rewrite?: <<MultiTermQueryRewrite>>
  pass:[/**] @property value Beginning characters of terms you wish to find in the provided field. */
  value: string
  pass:[/**] @property case_insensitive Allows ASCII case insensitive matching of the value with the indexed field values when set to `true`. Default is `false` which means the case sensitivity of matching depends on the underlying field’s mapping. */
  case_insensitive?: boolean
}
----


[discrete]
[[QueryDslQueryBase]]
=== QueryDslQueryBase

[source,ts,subs=+macros]
----
interface QueryDslQueryBase {
  pass:[/**] @property boost Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score. */
  boost?: <<float>>
  _name?: string
}
----


[discrete]
[[QueryDslQueryContainer]]
=== QueryDslQueryContainer

[source,ts,subs=+macros]
----
interface QueryDslQueryContainer {
  pass:[/**] @property bool matches documents matching boolean combinations of other queries. */
  bool?: <<QueryDslBoolQuery>>
  pass:[/**] @property boosting Returns documents matching a `positive` query while reducing the relevance score of documents that also match a `negative` query. */
  boosting?: <<QueryDslBoostingQuery>>
  common?: Partial<Record<<<Field>>, <<QueryDslCommonTermsQuery>> | string>>
  pass:[/**] @property combined_fields The `combined_fields` query supports searching multiple text fields as if their contents had been indexed into one combined field. */
  combined_fields?: <<QueryDslCombinedFieldsQuery>>
  pass:[/**] @property constant_score Wraps a filter query and returns every matching document with a relevance score equal to the `boost` parameter value. */
  constant_score?: <<QueryDslConstantScoreQuery>>
  pass:[/**] @property dis_max Returns documents matching one or more wrapped queries, called query clauses or clauses. If a returned document matches multiple query clauses, the `dis_max` query assigns the document the highest relevance score from any matching clause, plus a tie breaking increment for any additional matching subqueries. */
  dis_max?: <<QueryDslDisMaxQuery>>
  pass:[/**] @property distance_feature Boosts the relevance score of documents closer to a provided origin date or point. For example, you can use this query to give more weight to documents closer to a certain date or location. */
  distance_feature?: <<QueryDslDistanceFeatureQuery>>
  pass:[/**] @property exists Returns documents that contain an indexed value for a field. */
  exists?: <<QueryDslExistsQuery>>
  pass:[/**] @property function_score The `function_score` enables you to modify the score of documents that are retrieved by a query. */
  function_score?: <<QueryDslFunctionScoreQuery>> | <<QueryDslFunctionScoreContainer>>[]
  pass:[/**] @property fuzzy Returns documents that contain terms similar to the search term, as measured by a Levenshtein edit distance. */
  fuzzy?: Partial<Record<<<Field>>, <<QueryDslFuzzyQuery>> | string | <<double>> | boolean>>
  pass:[/**] @property geo_bounding_box Matches geo_point and geo_shape values that intersect a bounding box. */
  geo_bounding_box?: <<QueryDslGeoBoundingBoxQuery>>
  pass:[/**] @property geo_distance Matches `geo_point` and `geo_shape` values within a given distance of a geopoint. */
  geo_distance?: <<QueryDslGeoDistanceQuery>>
  geo_polygon?: <<QueryDslGeoPolygonQuery>>
  pass:[/**] @property geo_shape Filter documents indexed using either the `geo_shape` or the `geo_point` type. */
  geo_shape?: <<QueryDslGeoShapeQuery>>
  pass:[/**] @property has_child Returns parent documents whose joined child documents match a provided query. */
  has_child?: <<QueryDslHasChildQuery>>
  pass:[/**] @property has_parent Returns child documents whose joined parent document matches a provided query. */
  has_parent?: <<QueryDslHasParentQuery>>
  pass:[/**] @property ids Returns documents based on their IDs. This query uses document IDs stored in the `_id` field. */
  ids?: <<QueryDslIdsQuery>>
  pass:[/**] @property intervals Returns documents based on the order and proximity of matching terms. */
  intervals?: Partial<Record<<<Field>>, <<QueryDslIntervalsQuery>>>>
  pass:[/**] @property knn Finds the k nearest vectors to a query vector, as measured by a similarity metric. knn query finds nearest vectors through approximate search on indexed dense_vectors. */
  knn?: <<KnnQuery>>
  pass:[/**] @property match Returns documents that match a provided text, number, date or boolean value. The provided text is analyzed before matching. */
  match?: Partial<Record<<<Field>>, <<QueryDslMatchQuery>> | string | <<float>> | boolean>>
  pass:[/**] @property match_all Matches all documents, giving them all a `_score` of 1.0. */
  match_all?: <<QueryDslMatchAllQuery>>
  pass:[/**] @property match_bool_prefix Analyzes its input and constructs a `bool` query from the terms. Each term except the last is used in a `term` query. The last term is used in a prefix query. */
  match_bool_prefix?: Partial<Record<<<Field>>, <<QueryDslMatchBoolPrefixQuery>> | string>>
  pass:[/**] @property match_none Matches no documents. */
  match_none?: <<QueryDslMatchNoneQuery>>
  pass:[/**] @property match_phrase Analyzes the text and creates a phrase query out of the analyzed text. */
  match_phrase?: Partial<Record<<<Field>>, <<QueryDslMatchPhraseQuery>> | string>>
  pass:[/**] @property match_phrase_prefix Returns documents that contain the words of a provided text, in the same order as provided. The last term of the provided text is treated as a prefix, matching any words that begin with that term. */
  match_phrase_prefix?: Partial<Record<<<Field>>, <<QueryDslMatchPhrasePrefixQuery>> | string>>
  pass:[/**] @property more_like_this Returns documents that are "like" a given set of documents. */
  more_like_this?: <<QueryDslMoreLikeThisQuery>>
  pass:[/**] @property multi_match Enables you to search for a provided text, number, date or boolean value across multiple fields. The provided text is analyzed before matching. */
  multi_match?: <<QueryDslMultiMatchQuery>>
  pass:[/**] @property nested Wraps another query to search nested fields. If an object matches the search, the nested query returns the root parent document. */
  nested?: <<QueryDslNestedQuery>>
  pass:[/**] @property parent_id Returns child documents joined to a specific parent document. */
  parent_id?: <<QueryDslParentIdQuery>>
  pass:[/**] @property percolate Matches queries stored in an index. */
  percolate?: <<QueryDslPercolateQuery>>
  pass:[/**] @property pinned Promotes selected documents to rank higher than those matching a given query. */
  pinned?: <<QueryDslPinnedQuery>>
  pass:[/**] @property prefix Returns documents that contain a specific prefix in a provided field. */
  prefix?: Partial<Record<<<Field>>, <<QueryDslPrefixQuery>> | string>>
  pass:[/**] @property query_string Returns documents based on a provided query string, using a parser with a strict syntax. */
  query_string?: <<QueryDslQueryStringQuery>>
  pass:[/**] @property range Returns documents that contain terms within a provided range. */
  range?: Partial<Record<<<Field>>, <<QueryDslRangeQuery>>>>
  pass:[/**] @property rank_feature Boosts the relevance score of documents based on the numeric value of a `rank_feature` or `rank_features` field. */
  rank_feature?: <<QueryDslRankFeatureQuery>>
  pass:[/**] @property regexp Returns documents that contain terms matching a regular expression. */
  regexp?: Partial<Record<<<Field>>, <<QueryDslRegexpQuery>> | string>>
  rule?: <<QueryDslRuleQuery>>
  pass:[/**] @property script Filters documents based on a provided script. The script query is typically used in a filter context. */
  script?: <<QueryDslScriptQuery>>
  pass:[/**] @property script_score Uses a script to provide a custom score for returned documents. */
  script_score?: <<QueryDslScriptScoreQuery>>
  pass:[/**] @property semantic A semantic query to semantic_text field types */
  semantic?: <<QueryDslSemanticQuery>>
  pass:[/**] @property shape Queries documents that contain fields indexed using the `shape` type. */
  shape?: <<QueryDslShapeQuery>>
  pass:[/**] @property simple_query_string Returns documents based on a provided query string, using a parser with a limited but fault-tolerant syntax. */
  simple_query_string?: <<QueryDslSimpleQueryStringQuery>>
  pass:[/**] @property span_containing Returns matches which enclose another span query. */
  span_containing?: <<QueryDslSpanContainingQuery>>
  pass:[/**] @property span_field_masking Wrapper to allow span queries to participate in composite single-field span queries by _lying_ about their search field. */
  span_field_masking?: <<QueryDslSpanFieldMaskingQuery>>
  pass:[/**] @property span_first Matches spans near the beginning of a field. */
  span_first?: <<QueryDslSpanFirstQuery>>
  pass:[/**] @property span_multi Allows you to wrap a multi term query (one of `wildcard`, `fuzzy`, `prefix`, `range`, or `regexp` query) as a `span` query, so it can be nested. */
  span_multi?: <<QueryDslSpanMultiTermQuery>>
  pass:[/**] @property span_near Matches spans which are near one another. You can specify `slop`, the maximum number of intervening unmatched positions, as well as whether matches are required to be in-order. */
  span_near?: <<QueryDslSpanNearQuery>>
  pass:[/**] @property span_not Removes matches which overlap with another span query or which are within x tokens before (controlled by the parameter `pre`) or y tokens after (controlled by the parameter `post`) another span query. */
  span_not?: <<QueryDslSpanNotQuery>>
  pass:[/**] @property span_or Matches the union of its span clauses. */
  span_or?: <<QueryDslSpanOrQuery>>
  pass:[/**] @property span_term Matches spans containing a term. */
  span_term?: Partial<Record<<<Field>>, <<QueryDslSpanTermQuery>> | string>>
  pass:[/**] @property span_within Returns matches which are enclosed inside another span query. */
  span_within?: <<QueryDslSpanWithinQuery>>
  pass:[/**] @property sparse_vector Using input query vectors or a natural language processing model to convert a query into a list of token-weight pairs, queries against a sparse vector field. */
  sparse_vector?: <<QueryDslSparseVectorQuery>>
  pass:[/**] @property term Returns documents that contain an exact term in a provided field. To return a document, the query term must exactly match the queried field's value, including whitespace and capitalization. */
  term?: Partial<Record<<<Field>>, <<QueryDslTermQuery>> | <<FieldValue>>>>
  pass:[/**] @property terms Returns documents that contain one or more exact terms in a provided field. To return a document, one or more terms must exactly match a field value, including whitespace and capitalization. */
  terms?: <<QueryDslTermsQuery>>
  pass:[/**] @property terms_set Returns documents that contain a minimum number of exact terms in a provided field. To return a document, a required number of terms must exactly match the field values, including whitespace and capitalization. */
  terms_set?: Partial<Record<<<Field>>, <<QueryDslTermsSetQuery>>>>
  pass:[/**] @property text_expansion Uses a natural language processing model to convert the query text into a list of token-weight pairs which are then used in a query against a sparse vector or rank features field. */
  text_expansion?: Partial<Record<<<Field>>, <<QueryDslTextExpansionQuery>>>>
  pass:[/**] @property weighted_tokens Supports returning text_expansion query results by sending in precomputed tokens with the query. */
  weighted_tokens?: Partial<Record<<<Field>>, <<QueryDslWeightedTokensQuery>>>>
  pass:[/**] @property wildcard Returns documents that contain terms matching a wildcard pattern. */
  wildcard?: Partial<Record<<<Field>>, <<QueryDslWildcardQuery>> | string>>
  pass:[/**] @property wrapper A query that accepts any other query as base64 encoded string. */
  wrapper?: <<QueryDslWrapperQuery>>
  type?: <<QueryDslTypeQuery>>
}
----


[discrete]
[[QueryDslQueryStringQuery]]
=== QueryDslQueryStringQuery

[source,ts,subs=+macros]
----
interface QueryDslQueryStringQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property allow_leading_wildcard If `true`, the wildcard characters `*` and `?` are allowed as the first character of the query string. */
  allow_leading_wildcard?: boolean
  pass:[/**] @property analyzer Analyzer used to convert text in the query string into tokens. */
  analyzer?: string
  pass:[/**] @property analyze_wildcard If `true`, the query attempts to analyze wildcard terms in the query string. */
  analyze_wildcard?: boolean
  pass:[/**] @property auto_generate_synonyms_phrase_query If `true`, match phrase queries are automatically created for multi-term synonyms. */
  auto_generate_synonyms_phrase_query?: boolean
  pass:[/**] @property default_field Default field to search if no field is provided in the query string. Supports wildcards (`*`). Defaults to the `index.query.default_field` index setting, which has a default value of `*`. */
  default_field?: <<Field>>
  pass:[/**] @property default_operator Default boolean logic used to interpret text in the query string if no operators are specified. */
  default_operator?: <<QueryDslOperator>>
  pass:[/**] @property enable_position_increments If `true`, enable position increments in queries constructed from a `query_string` search. */
  enable_position_increments?: boolean
  escape?: boolean
  pass:[/**] @property fields Array of fields to search. Supports wildcards (`*`). */
  fields?: <<Field>>[]
  pass:[/**] @property fuzziness Maximum edit distance allowed for fuzzy matching. */
  fuzziness?: <<Fuzziness>>
  pass:[/**] @property fuzzy_max_expansions Maximum number of terms to which the query expands for fuzzy matching. */
  fuzzy_max_expansions?: <<integer>>
  pass:[/**] @property fuzzy_prefix_length Number of beginning characters left unchanged for fuzzy matching. */
  fuzzy_prefix_length?: <<integer>>
  pass:[/**] @property fuzzy_rewrite Method used to rewrite the query. */
  fuzzy_rewrite?: <<MultiTermQueryRewrite>>
  pass:[/**] @property fuzzy_transpositions If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`). */
  fuzzy_transpositions?: boolean
  pass:[/**] @property lenient If `true`, format-based errors, such as providing a text value for a numeric field, are ignored. */
  lenient?: boolean
  pass:[/**] @property max_determinized_states Maximum number of automaton states required for the query. */
  max_determinized_states?: <<integer>>
  pass:[/**] @property minimum_should_match Minimum number of clauses that must match for a document to be returned. */
  minimum_should_match?: <<MinimumShouldMatch>>
  pass:[/**] @property phrase_slop Maximum number of positions allowed between matching tokens for phrases. */
  phrase_slop?: <<double>>
  pass:[/**] @property query Query string you wish to parse and use for search. */
  query: string
  pass:[/**] @property quote_analyzer Analyzer used to convert quoted text in the query string into tokens. For quoted text, this parameter overrides the analyzer specified in the `analyzer` parameter. */
  quote_analyzer?: string
  pass:[/**] @property quote_field_suffix Suffix appended to quoted text in the query string. You can use this suffix to use a different analysis method for exact matches. */
  quote_field_suffix?: string
  pass:[/**] @property rewrite Method used to rewrite the query. */
  rewrite?: <<MultiTermQueryRewrite>>
  pass:[/**] @property tie_breaker How to combine the queries generated from the individual search terms in the resulting `dis_max` query. */
  tie_breaker?: <<double>>
  pass:[/**] @property time_zone Coordinated Universal Time (UTC) offset or IANA time zone used to convert date values in the query string to UTC. */
  time_zone?: <<TimeZone>>
  pass:[/**] @property type Determines how the query matches and scores documents. */
  type?: <<QueryDslTextQueryType>>
}
----


[discrete]
[[QueryDslRandomScoreFunction]]
=== QueryDslRandomScoreFunction

[source,ts,subs=+macros]
----
interface QueryDslRandomScoreFunction {
  field?: <<Field>>
  seed?: <<long>> | string
}
----


[discrete]
[[QueryDslRangeQuery]]
=== QueryDslRangeQuery

[source,ts,subs=+macros]
----
type QueryDslRangeQuery = <<QueryDslUntypedRangeQuery>> | <<QueryDslDateRangeQuery>> | <<QueryDslNumberRangeQuery>> | <<QueryDslTermRangeQuery>>
----


[discrete]
[[QueryDslRangeQueryBase]]
=== QueryDslRangeQueryBase

[source,ts,subs=+macros]
----
interface QueryDslRangeQueryBase<T = unknown> extends <<QueryDslQueryBase>> {
  pass:[/**] @property relation Indicates how the range query matches values for `range` fields. */
  relation?: <<QueryDslRangeRelation>>
  pass:[/**] @property gt Greater than. */
  gt?: T
  pass:[/**] @property gte Greater than or equal to. */
  gte?: T
  pass:[/**] @property lt Less than. */
  lt?: T
  pass:[/**] @property lte Less than or equal to. */
  lte?: T
  from?: T | null
  to?: T | null
}
----


[discrete]
[[QueryDslRangeRelation]]
=== QueryDslRangeRelation

[source,ts,subs=+macros]
----
type QueryDslRangeRelation = 'within' | 'contains' | 'intersects'
----


[discrete]
[[QueryDslRankFeatureFunction]]
=== QueryDslRankFeatureFunction

[source,ts,subs=+macros]
----
interface QueryDslRankFeatureFunction {}
----


[discrete]
[[QueryDslRankFeatureFunctionLinear]]
=== QueryDslRankFeatureFunctionLinear

[source,ts,subs=+macros]
----
interface QueryDslRankFeatureFunctionLinear {}
----


[discrete]
[[QueryDslRankFeatureFunctionLogarithm]]
=== QueryDslRankFeatureFunctionLogarithm

[source,ts,subs=+macros]
----
interface QueryDslRankFeatureFunctionLogarithm {
  pass:[/**] @property scaling_factor Configurable scaling factor. */
  scaling_factor: <<float>>
}
----


[discrete]
[[QueryDslRankFeatureFunctionSaturation]]
=== QueryDslRankFeatureFunctionSaturation

[source,ts,subs=+macros]
----
interface QueryDslRankFeatureFunctionSaturation {
  pass:[/**] @property pivot Configurable pivot value so that the result will be less than 0.5. */
  pivot?: <<float>>
}
----


[discrete]
[[QueryDslRankFeatureFunctionSigmoid]]
=== QueryDslRankFeatureFunctionSigmoid

[source,ts,subs=+macros]
----
interface QueryDslRankFeatureFunctionSigmoid {
  pass:[/**] @property pivot Configurable pivot value so that the result will be less than 0.5. */
  pivot: <<float>>
  pass:[/**] @property exponent Configurable Exponent. */
  exponent: <<float>>
}
----


[discrete]
[[QueryDslRankFeatureQuery]]
=== QueryDslRankFeatureQuery

[source,ts,subs=+macros]
----
interface QueryDslRankFeatureQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property field `rank_feature` or `rank_features` field used to boost relevance scores. */
  field: <<Field>>
  pass:[/**] @property saturation Saturation function used to boost relevance scores based on the value of the rank feature `field`. */
  saturation?: <<QueryDslRankFeatureFunctionSaturation>>
  pass:[/**] @property log Logarithmic function used to boost relevance scores based on the value of the rank feature `field`. */
  log?: <<QueryDslRankFeatureFunctionLogarithm>>
  pass:[/**] @property linear Linear function used to boost relevance scores based on the value of the rank feature `field`. */
  linear?: <<QueryDslRankFeatureFunctionLinear>>
  pass:[/**] @property sigmoid Sigmoid function used to boost relevance scores based on the value of the rank feature `field`. */
  sigmoid?: <<QueryDslRankFeatureFunctionSigmoid>>
}
----


[discrete]
[[QueryDslRegexpQuery]]
=== QueryDslRegexpQuery

[source,ts,subs=+macros]
----
interface QueryDslRegexpQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property case_insensitive Allows case insensitive matching of the regular expression value with the indexed field values when set to `true`. When `false`, case sensitivity of matching depends on the underlying field’s mapping. */
  case_insensitive?: boolean
  pass:[/**] @property flags Enables optional operators for the regular expression. */
  flags?: string
  pass:[/**] @property max_determinized_states Maximum number of automaton states required for the query. */
  max_determinized_states?: <<integer>>
  pass:[/**] @property rewrite Method used to rewrite the query. */
  rewrite?: <<MultiTermQueryRewrite>>
  pass:[/**] @property value Regular expression for terms you wish to find in the provided field. */
  value: string
}
----


[discrete]
[[QueryDslRuleQuery]]
=== QueryDslRuleQuery

[source,ts,subs=+macros]
----
interface QueryDslRuleQuery extends <<QueryDslQueryBase>> {
  organic: <<QueryDslQueryContainer>>
  ruleset_ids: <<Id>>[]
  match_criteria: any
}
----


[discrete]
[[QueryDslScriptQuery]]
=== QueryDslScriptQuery

[source,ts,subs=+macros]
----
interface QueryDslScriptQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property script Contains a script to run as a query. This script must return a boolean value, `true` or `false`. */
  script: <<Script>> | string
}
----


[discrete]
[[QueryDslScriptScoreFunction]]
=== QueryDslScriptScoreFunction

[source,ts,subs=+macros]
----
interface QueryDslScriptScoreFunction {
  pass:[/**] @property script A script that computes a score. */
  script: <<Script>> | string
}
----


[discrete]
[[QueryDslScriptScoreQuery]]
=== QueryDslScriptScoreQuery

[source,ts,subs=+macros]
----
interface QueryDslScriptScoreQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property min_score Documents with a score lower than this floating point number are excluded from the search results. */
  min_score?: <<float>>
  pass:[/**] @property query Query used to return documents. */
  query: <<QueryDslQueryContainer>>
  pass:[/**] @property script <<Script>> used to compute the score of documents returned by the query. Important: final relevance scores from the `script_score` query cannot be negative. */
  script: <<Script>> | string
}
----


[discrete]
[[QueryDslSemanticQuery]]
=== QueryDslSemanticQuery

[source,ts,subs=+macros]
----
interface QueryDslSemanticQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property field The field to query, which must be a semantic_text field type */
  field: string
  pass:[/**] @property query The query text */
  query: string
}
----


[discrete]
[[QueryDslShapeFieldQuery]]
=== QueryDslShapeFieldQuery

[source,ts,subs=+macros]
----
interface QueryDslShapeFieldQuery {
  pass:[/**] @property indexed_shape Queries using a pre-indexed shape. */
  indexed_shape?: <<QueryDslFieldLookup>>
  pass:[/**] @property relation Spatial relation between the query shape and the document shape. */
  relation?: <<GeoShapeRelation>>
  pass:[/**] @property shape Queries using an inline shape definition in GeoJSON or Well Known Text (WKT) format. */
  shape?: <<GeoShape>>
}
----


[discrete]
[[QueryDslShapeQuery]]
=== QueryDslShapeQuery

[source,ts,subs=+macros]
----
interface QueryDslShapeQueryKeys extends <<QueryDslQueryBase>> {
  ignore_unmapped?: boolean
}
type QueryDslShapeQuery = QueryDslShapeQueryKeys
  & { [property: string]: <<QueryDslShapeFieldQuery>> | boolean | <<float>> | string }
----


[discrete]
[[QueryDslSimpleQueryStringFlag]]
=== QueryDslSimpleQueryStringFlag

[source,ts,subs=+macros]
----
type QueryDslSimpleQueryStringFlag = 'NONE' | 'AND' | 'NOT' | 'OR' | 'PREFIX' | 'PHRASE' | 'PRECEDENCE' | 'ESCAPE' | 'WHITESPACE' | 'FUZZY' | 'NEAR' | 'SLOP' | 'ALL'
----


[discrete]
[[QueryDslSimpleQueryStringFlags]]
=== QueryDslSimpleQueryStringFlags

[source,ts,subs=+macros]
----
type QueryDslSimpleQueryStringFlags = <<SpecUtilsPipeSeparatedFlags>><<<QueryDslSimpleQueryStringFlag>>>
----


[discrete]
[[QueryDslSimpleQueryStringQuery]]
=== QueryDslSimpleQueryStringQuery

[source,ts,subs=+macros]
----
interface QueryDslSimpleQueryStringQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property analyzer Analyzer used to convert text in the query string into tokens. */
  analyzer?: string
  pass:[/**] @property analyze_wildcard If `true`, the query attempts to analyze wildcard terms in the query string. */
  analyze_wildcard?: boolean
  pass:[/**] @property auto_generate_synonyms_phrase_query If `true`, the parser creates a match_phrase query for each multi-position token. */
  auto_generate_synonyms_phrase_query?: boolean
  pass:[/**] @property default_operator Default boolean logic used to interpret text in the query string if no operators are specified. */
  default_operator?: <<QueryDslOperator>>
  pass:[/**] @property fields Array of fields you wish to search. Accepts wildcard expressions. You also can boost relevance scores for matches to particular fields using a caret (`^`) notation. Defaults to the `index.query.default_field index` setting, which has a default value of `*`. */
  fields?: <<Field>>[]
  pass:[/**] @property flags List of enabled operators for the simple query string syntax. */
  flags?: <<QueryDslSimpleQueryStringFlags>>
  pass:[/**] @property fuzzy_max_expansions Maximum number of terms to which the query expands for fuzzy matching. */
  fuzzy_max_expansions?: <<integer>>
  pass:[/**] @property fuzzy_prefix_length Number of beginning characters left unchanged for fuzzy matching. */
  fuzzy_prefix_length?: <<integer>>
  pass:[/**] @property fuzzy_transpositions If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`). */
  fuzzy_transpositions?: boolean
  pass:[/**] @property lenient If `true`, format-based errors, such as providing a text value for a numeric field, are ignored. */
  lenient?: boolean
  pass:[/**] @property minimum_should_match Minimum number of clauses that must match for a document to be returned. */
  minimum_should_match?: <<MinimumShouldMatch>>
  pass:[/**] @property query Query string in the simple query string syntax you wish to parse and use for search. */
  query: string
  pass:[/**] @property quote_field_suffix Suffix appended to quoted text in the query string. */
  quote_field_suffix?: string
}
----


[discrete]
[[QueryDslSpanContainingQuery]]
=== QueryDslSpanContainingQuery

[source,ts,subs=+macros]
----
interface QueryDslSpanContainingQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property big Can be any span query. Matching spans from `big` that contain matches from `little` are returned. */
  big: <<QueryDslSpanQuery>>
  pass:[/**] @property little Can be any span query. Matching spans from `big` that contain matches from `little` are returned. */
  little: <<QueryDslSpanQuery>>
}
----


[discrete]
[[QueryDslSpanFieldMaskingQuery]]
=== QueryDslSpanFieldMaskingQuery

[source,ts,subs=+macros]
----
interface QueryDslSpanFieldMaskingQuery extends <<QueryDslQueryBase>> {
  field: <<Field>>
  query: <<QueryDslSpanQuery>>
}
----


[discrete]
[[QueryDslSpanFirstQuery]]
=== QueryDslSpanFirstQuery

[source,ts,subs=+macros]
----
interface QueryDslSpanFirstQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property end Controls the maximum end position permitted in a match. */
  end: <<integer>>
  pass:[/**] @property match Can be any other span type query. */
  match: <<QueryDslSpanQuery>>
}
----


[discrete]
[[QueryDslSpanGapQuery]]
=== QueryDslSpanGapQuery

[source,ts,subs=+macros]
----
type QueryDslSpanGapQuery = Partial<Record<<<Field>>, <<integer>>>>
----


[discrete]
[[QueryDslSpanMultiTermQuery]]
=== QueryDslSpanMultiTermQuery

[source,ts,subs=+macros]
----
interface QueryDslSpanMultiTermQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property match Should be a multi term query (one of `wildcard`, `fuzzy`, `prefix`, `range`, or `regexp` query). */
  match: <<QueryDslQueryContainer>>
}
----


[discrete]
[[QueryDslSpanNearQuery]]
=== QueryDslSpanNearQuery

[source,ts,subs=+macros]
----
interface QueryDslSpanNearQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property clauses Array of one or more other span type queries. */
  clauses: <<QueryDslSpanQuery>>[]
  pass:[/**] @property in_order Controls whether matches are required to be in-order. */
  in_order?: boolean
  pass:[/**] @property slop Controls the maximum number of intervening unmatched positions permitted. */
  slop?: <<integer>>
}
----


[discrete]
[[QueryDslSpanNotQuery]]
=== QueryDslSpanNotQuery

[source,ts,subs=+macros]
----
interface QueryDslSpanNotQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property dist The number of tokens from within the include span that can’t have overlap with the exclude span. Equivalent to setting both `pre` and `post`. */
  dist?: <<integer>>
  pass:[/**] @property exclude Span query whose matches must not overlap those returned. */
  exclude: <<QueryDslSpanQuery>>
  pass:[/**] @property include Span query whose matches are filtered. */
  include: <<QueryDslSpanQuery>>
  pass:[/**] @property post The number of tokens after the include span that can’t have overlap with the exclude span. */
  post?: <<integer>>
  pass:[/**] @property pre The number of tokens before the include span that can’t have overlap with the exclude span. */
  pre?: <<integer>>
}
----


[discrete]
[[QueryDslSpanOrQuery]]
=== QueryDslSpanOrQuery

[source,ts,subs=+macros]
----
interface QueryDslSpanOrQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property clauses Array of one or more other span type queries. */
  clauses: <<QueryDslSpanQuery>>[]
}
----


[discrete]
[[QueryDslSpanQuery]]
=== QueryDslSpanQuery

[source,ts,subs=+macros]
----
interface QueryDslSpanQuery {
  pass:[/**] @property span_containing Accepts a list of span queries, but only returns those spans which also match a second span query. */
  span_containing?: <<QueryDslSpanContainingQuery>>
  pass:[/**] @property span_field_masking Allows queries like `span_near` or `span_or` across different fields. */
  span_field_masking?: <<QueryDslSpanFieldMaskingQuery>>
  pass:[/**] @property span_first Accepts another span query whose matches must appear within the first N positions of the field. */
  span_first?: <<QueryDslSpanFirstQuery>>
  span_gap?: <<QueryDslSpanGapQuery>>
  pass:[/**] @property span_multi Wraps a `term`, `range`, `prefix`, `wildcard`, `regexp`, or `fuzzy` query. */
  span_multi?: <<QueryDslSpanMultiTermQuery>>
  pass:[/**] @property span_near Accepts multiple span queries whose matches must be within the specified distance of each other, and possibly in the same order. */
  span_near?: <<QueryDslSpanNearQuery>>
  pass:[/**] @property span_not Wraps another span query, and excludes any documents which match that query. */
  span_not?: <<QueryDslSpanNotQuery>>
  pass:[/**] @property span_or Combines multiple span queries and returns documents which match any of the specified queries. */
  span_or?: <<QueryDslSpanOrQuery>>
  pass:[/**] @property span_term The equivalent of the `term` query but for use with other span queries. */
  span_term?: Partial<Record<<<Field>>, <<QueryDslSpanTermQuery>> | string>>
  pass:[/**] @property span_within The result from a single span query is returned as <<long>> is its span falls within the spans returned by a list of other span queries. */
  span_within?: <<QueryDslSpanWithinQuery>>
}
----


[discrete]
[[QueryDslSpanTermQuery]]
=== QueryDslSpanTermQuery

[source,ts,subs=+macros]
----
interface QueryDslSpanTermQuery extends <<QueryDslQueryBase>> {
  value: string
}
----


[discrete]
[[QueryDslSpanWithinQuery]]
=== QueryDslSpanWithinQuery

[source,ts,subs=+macros]
----
interface QueryDslSpanWithinQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property big Can be any span query. Matching spans from `little` that are enclosed within `big` are returned. */
  big: <<QueryDslSpanQuery>>
  pass:[/**] @property little Can be any span query. Matching spans from `little` that are enclosed within `big` are returned. */
  little: <<QueryDslSpanQuery>>
}
----


[discrete]
[[QueryDslSparseVectorQuery]]
=== QueryDslSparseVectorQuery

[source,ts,subs=+macros]
----
interface QueryDslSparseVectorQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property field The name of the field that contains the token-weight pairs to be searched against. This field must be a mapped sparse_vector field. */
  field: <<Field>>
  pass:[/**] @property query_vector Dictionary of precomputed sparse vectors and their associated weights. Only one of inference_id or query_vector may be supplied in a request. */
  query_vector?: Record<string, <<float>>>
  pass:[/**] @property inference_id The inference ID to use to convert the query text into token-weight pairs. It must be the same inference ID that was used to create the tokens from the input text. Only one of inference_id and query_vector is allowed. If inference_id is specified, query must also be specified. Only one of inference_id or query_vector may be supplied in a request. */
  inference_id?: <<Id>>
  pass:[/**] @property query The query text you want to use for search. If inference_id is specified, query must also be specified. */
  query?: string
  pass:[/**] @property prune Whether to perform pruning, omitting the non-significant tokens from the query to improve query performance. If prune is true but the pruning_config is not specified, pruning will occur but default values will be used. Default: false */
  prune?: boolean
  pass:[/**] @property pruning_config Optional pruning configuration. If enabled, this will omit non-significant tokens from the query in order to improve query performance. This is only used if prune is set to true. If prune is set to true but pruning_config is not specified, default values will be used. */
  pruning_config?: <<QueryDslTokenPruningConfig>>
}
----


[discrete]
[[QueryDslTermQuery]]
=== QueryDslTermQuery

[source,ts,subs=+macros]
----
interface QueryDslTermQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property value Term you wish to find in the provided field. */
  value: <<FieldValue>>
  pass:[/**] @property case_insensitive Allows ASCII case insensitive matching of the value with the indexed field values when set to `true`. When `false`, the case sensitivity of matching depends on the underlying field’s mapping. */
  case_insensitive?: boolean
}
----


[discrete]
[[QueryDslTermRangeQuery]]
=== QueryDslTermRangeQuery

[source,ts,subs=+macros]
----
interface QueryDslTermRangeQuery extends <<QueryDslRangeQueryBase>><string> {}
----


[discrete]
[[QueryDslTermsLookup]]
=== QueryDslTermsLookup

[source,ts,subs=+macros]
----
interface QueryDslTermsLookup {
  index: <<IndexName>>
  id: <<Id>>
  path: <<Field>>
  routing?: <<Routing>>
}
----


[discrete]
[[QueryDslTermsQuery]]
=== QueryDslTermsQuery

[source,ts,subs=+macros]
----
interface QueryDslTermsQueryKeys extends <<QueryDslQueryBase>> {}
type QueryDslTermsQuery = QueryDslTermsQueryKeys
  & { [property: string]: <<QueryDslTermsQueryField>> | <<float>> | string }
----


[discrete]
[[QueryDslTermsQueryField]]
=== QueryDslTermsQueryField

[source,ts,subs=+macros]
----
type QueryDslTermsQueryField = <<FieldValue>>[] | <<QueryDslTermsLookup>>
----


[discrete]
[[QueryDslTermsSetQuery]]
=== QueryDslTermsSetQuery

[source,ts,subs=+macros]
----
interface QueryDslTermsSetQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property minimum_should_match Specification describing number of matching terms required to return a document. */
  minimum_should_match?: <<MinimumShouldMatch>>
  pass:[/**] @property minimum_should_match_field Numeric field containing the number of matching terms required to return a document. */
  minimum_should_match_field?: <<Field>>
  pass:[/**] @property minimum_should_match_script Custom script containing the number of matching terms required to return a document. */
  minimum_should_match_script?: <<Script>> | string
  pass:[/**] @property terms Array of terms you wish to find in the provided field. */
  terms: string[]
}
----


[discrete]
[[QueryDslTextExpansionQuery]]
=== QueryDslTextExpansionQuery

[source,ts,subs=+macros]
----
interface QueryDslTextExpansionQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property model_id The text expansion NLP model to use */
  model_id: string
  pass:[/**] @property model_text The query text */
  model_text: string
  pass:[/**] @property pruning_config Token pruning configurations */
  pruning_config?: <<QueryDslTokenPruningConfig>>
}
----


[discrete]
[[QueryDslTextQueryType]]
=== QueryDslTextQueryType

[source,ts,subs=+macros]
----
type QueryDslTextQueryType = 'best_fields' | 'most_fields' | 'cross_fields' | 'phrase' | 'phrase_prefix' | 'bool_prefix'
----


[discrete]
[[QueryDslTokenPruningConfig]]
=== QueryDslTokenPruningConfig

[source,ts,subs=+macros]
----
interface QueryDslTokenPruningConfig {
  pass:[/**] @property tokens_freq_ratio_threshold Tokens whose frequency is more than this threshold times the average frequency of all tokens in the specified field are considered outliers and pruned. */
  tokens_freq_ratio_threshold?: <<integer>>
  pass:[/**] @property tokens_weight_threshold Tokens whose weight is less than this threshold are considered nonsignificant and pruned. */
  tokens_weight_threshold?: <<float>>
  pass:[/**] @property only_score_pruned_tokens Whether to only score pruned tokens, vs only scoring kept tokens. */
  only_score_pruned_tokens?: boolean
}
----


[discrete]
[[QueryDslTypeQuery]]
=== QueryDslTypeQuery

[source,ts,subs=+macros]
----
interface QueryDslTypeQuery extends <<QueryDslQueryBase>> {
  value: string
}
----


[discrete]
[[QueryDslUntypedDecayFunction]]
=== QueryDslUntypedDecayFunction

[source,ts,subs=+macros]
----
interface QueryDslUntypedDecayFunctionKeys extends <<QueryDslDecayFunctionBase>><any, any> {}
type QueryDslUntypedDecayFunction = QueryDslUntypedDecayFunctionKeys
  & { [property: string]: <<QueryDslDecayPlacement>> | <<QueryDslMultiValueMode>> }
----


[discrete]
[[QueryDslUntypedDistanceFeatureQuery]]
=== QueryDslUntypedDistanceFeatureQuery

[source,ts,subs=+macros]
----
interface QueryDslUntypedDistanceFeatureQuery extends <<QueryDslDistanceFeatureQueryBase>><any, any> {}
----


[discrete]
[[QueryDslUntypedRangeQuery]]
=== QueryDslUntypedRangeQuery

[source,ts,subs=+macros]
----
interface QueryDslUntypedRangeQuery extends <<QueryDslRangeQueryBase>><any> {
  pass:[/**] @property format Date format used to convert `date` values in the query. */
  format?: <<DateFormat>>
  pass:[/**] @property time_zone Coordinated Universal Time (UTC) offset or IANA time zone used to convert `date` values in the query to UTC. */
  time_zone?: <<TimeZone>>
}
----


[discrete]
[[QueryDslWeightedTokensQuery]]
=== QueryDslWeightedTokensQuery

[source,ts,subs=+macros]
----
interface QueryDslWeightedTokensQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property tokens The tokens representing this query */
  tokens: Record<string, <<float>>>
  pass:[/**] @property pruning_config Token pruning configurations */
  pruning_config?: <<QueryDslTokenPruningConfig>>
}
----


[discrete]
[[QueryDslWildcardQuery]]
=== QueryDslWildcardQuery

[source,ts,subs=+macros]
----
interface QueryDslWildcardQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property case_insensitive Allows case insensitive matching of the pattern with the indexed field values when set to true. Default is false which means the case sensitivity of matching depends on the underlying field’s mapping. */
  case_insensitive?: boolean
  pass:[/**] @property rewrite Method used to rewrite the query. */
  rewrite?: <<MultiTermQueryRewrite>>
  pass:[/**] @property value Wildcard pattern for terms you wish to find in the provided field. Required, when wildcard is not set. */
  value?: string
  pass:[/**] @property wildcard Wildcard pattern for terms you wish to find in the provided field. Required, when value is not set. */
  wildcard?: string
}
----


[discrete]
[[QueryDslWrapperQuery]]
=== QueryDslWrapperQuery

[source,ts,subs=+macros]
----
interface QueryDslWrapperQuery extends <<QueryDslQueryBase>> {
  pass:[/**] @property query A base64 encoded query. The binary data format can be any of JSON, YAML, CBOR or SMILE encodings */
  query: string
}
----


[discrete]
[[QueryDslZeroTermsQuery]]
=== QueryDslZeroTermsQuery

[source,ts,subs=+macros]
----
type QueryDslZeroTermsQuery = 'all' | 'none'
----

