[[reference-shared-types-nodes-types]]

=== `Nodes` types

////////
===========================================================================================================================
||                                                                                                                       ||
||                                                                                                                       ||
||                                                                                                                       ||
||        ██████╗ ███████╗ █████╗ ██████╗ ███╗   ███╗███████╗                                                            ||
||        ██╔══██╗██╔════╝██╔══██╗██╔══██╗████╗ ████║██╔════╝                                                            ||
||        ██████╔╝█████╗  ███████║██║  ██║██╔████╔██║█████╗                                                              ||
||        ██╔══██╗██╔══╝  ██╔══██║██║  ██║██║╚██╔╝██║██╔══╝                                                              ||
||        ██║  ██║███████╗██║  ██║██████╔╝██║ ╚═╝ ██║███████╗                                                            ||
||        ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝     ╚═╝╚══════╝                                                            ||
||                                                                                                                       ||
||                                                                                                                       ||
||    This file is autogenerated, DO NOT send pull requests that changes this file directly.                             ||
||    You should update the script that does the generation, which can be found in:                                      ||
||    https://github.com/elastic/elastic-client-generator-js                                                             ||
||                                                                                                                       ||
||    You can run the script with the following command:                                                                 ||
||       npm run elasticsearch -- --version <version>                                                                    ||
||                                                                                                                       ||
||                                                                                                                       ||
||                                                                                                                       ||
===========================================================================================================================
////////
++++
<style>
.lang-ts a.xref {
  text-decoration: underline !important;
}
</style>
++++


[discrete]
[[NodesAdaptiveSelection]]
=== NodesAdaptiveSelection

[source,ts,subs=+macros]
----
interface NodesAdaptiveSelection {
  pass:[/**] @property avg_queue_size The exponentially weighted moving average queue size of search requests on the keyed node. */
  avg_queue_size?: <<long>>
  pass:[/**] @property avg_response_time The exponentially weighted moving average response time of search requests on the keyed node. */
  avg_response_time?: <<Duration>>
  pass:[/**] @property avg_response_time_ns The exponentially weighted moving average response time, in nanoseconds, of search requests on the keyed node. */
  avg_response_time_ns?: <<long>>
  pass:[/**] @property avg_service_time The exponentially weighted moving average service time of search requests on the keyed node. */
  avg_service_time?: <<Duration>>
  pass:[/**] @property avg_service_time_ns The exponentially weighted moving average service time, in nanoseconds, of search requests on the keyed node. */
  avg_service_time_ns?: <<long>>
  pass:[/**] @property outgoing_searches The number of outstanding search requests to the keyed node from the node these stats are for. */
  outgoing_searches?: <<long>>
  pass:[/**] @property rank The rank of this node; used for shard selection when routing search requests. */
  rank?: string
}
----


[discrete]
[[NodesBreaker]]
=== NodesBreaker

[source,ts,subs=+macros]
----
interface NodesBreaker {
  pass:[/**] @property estimated_size Estimated memory used for the operation. */
  estimated_size?: string
  pass:[/**] @property estimated_size_in_bytes Estimated memory used, in bytes, for the operation. */
  estimated_size_in_bytes?: <<long>>
  pass:[/**] @property limit_size Memory limit for the circuit breaker. */
  limit_size?: string
  pass:[/**] @property limit_size_in_bytes Memory limit, in bytes, for the circuit breaker. */
  limit_size_in_bytes?: <<long>>
  pass:[/**] @property overhead A constant that all estimates for the circuit breaker are multiplied with to calculate a final estimate. */
  overhead?: <<float>>
  pass:[/**] @property tripped Total number of times the circuit breaker has been triggered and prevented an out of memory error. */
  tripped?: <<float>>
}
----


[discrete]
[[NodesCgroup]]
=== NodesCgroup

[source,ts,subs=+macros]
----
interface NodesCgroup {
  pass:[/**] @property cpuacct Contains statistics about `cpuacct` control group for the node. */
  cpuacct?: <<NodesCpuAcct>>
  pass:[/**] @property cpu Contains statistics about `cpu` control group for the node. */
  cpu?: <<NodesCgroupCpu>>
  pass:[/**] @property memory Contains statistics about the memory control group for the node. */
  memory?: <<NodesCgroupMemory>>
}
----


[discrete]
[[NodesCgroupCpu]]
=== NodesCgroupCpu

[source,ts,subs=+macros]
----
interface NodesCgroupCpu {
  pass:[/**] @property control_group The `cpu` control group to which the Elasticsearch process belongs. */
  control_group?: string
  pass:[/**] @property cfs_period_micros The period of time, in microseconds, for how regularly all tasks in the same cgroup as the Elasticsearch process should have their access to CPU resources reallocated. */
  cfs_period_micros?: <<integer>>
  pass:[/**] @property cfs_quota_micros The total amount of time, in microseconds, for which all tasks in the same cgroup as the Elasticsearch process can run during one period `cfs_period_micros`. */
  cfs_quota_micros?: <<integer>>
  pass:[/**] @property stat Contains CPU statistics for the node. */
  stat?: <<NodesCgroupCpuStat>>
}
----


[discrete]
[[NodesCgroupCpuStat]]
=== NodesCgroupCpuStat

[source,ts,subs=+macros]
----
interface NodesCgroupCpuStat {
  pass:[/**] @property number_of_elapsed_periods The number of reporting periods (as specified by `cfs_period_micros`) that have elapsed. */
  number_of_elapsed_periods?: <<long>>
  pass:[/**] @property number_of_times_throttled The number of times all tasks in the same cgroup as the Elasticsearch process have been throttled. */
  number_of_times_throttled?: <<long>>
  pass:[/**] @property time_throttled_nanos The total amount of time, in nanoseconds, for which all tasks in the same cgroup as the Elasticsearch process have been throttled. */
  time_throttled_nanos?: <<DurationValue>><<<UnitNanos>>>
}
----


[discrete]
[[NodesCgroupMemory]]
=== NodesCgroupMemory

[source,ts,subs=+macros]
----
interface NodesCgroupMemory {
  pass:[/**] @property control_group The `memory` control group to which the Elasticsearch process belongs. */
  control_group?: string
  pass:[/**] @property limit_in_bytes The maximum amount of user memory (including file cache) allowed for all tasks in the same cgroup as the Elasticsearch process. This value can be too big to store in a `<<long>>`, so is returned as a string so that the value returned can exactly match what the underlying operating system interface returns. Any value that is too large to parse into a `<<long>>` almost certainly means no limit has been set for the cgroup. */
  limit_in_bytes?: string
  pass:[/**] @property usage_in_bytes The total current memory usage by processes in the cgroup, in bytes, by all tasks in the same cgroup as the Elasticsearch process. This value is stored as a string for consistency with `limit_in_bytes`. */
  usage_in_bytes?: string
}
----


[discrete]
[[NodesClient]]
=== NodesClient

[source,ts,subs=+macros]
----
interface NodesClient {
  pass:[/**] @property id Unique ID for the HTTP client. */
  id?: <<long>>
  pass:[/**] @property agent Reported agent for the HTTP client. If unavailable, this property is not included in the response. */
  agent?: string
  pass:[/**] @property local_address Local address for the HTTP connection. */
  local_address?: string
  pass:[/**] @property remote_address Remote address for the HTTP connection. */
  remote_address?: string
  pass:[/**] @property last_uri The URI of the client’s most recent request. */
  last_uri?: string
  pass:[/**] @property opened_time_millis Time at which the client opened the connection. */
  opened_time_millis?: <<long>>
  pass:[/**] @property closed_time_millis Time at which the client closed the connection if the connection is closed. */
  closed_time_millis?: <<long>>
  pass:[/**] @property last_request_time_millis Time of the most recent request from this client. */
  last_request_time_millis?: <<long>>
  pass:[/**] @property request_count Number of requests from this client. */
  request_count?: <<long>>
  pass:[/**] @property request_size_bytes Cumulative size in bytes of all requests from this client. */
  request_size_bytes?: <<long>>
  pass:[/**] @property x_opaque_id Value from the client’s `x-opaque-id` HTTP header. If unavailable, this property is not included in the response. */
  x_opaque_id?: string
}
----


[discrete]
[[NodesClusterAppliedStats]]
=== NodesClusterAppliedStats

[source,ts,subs=+macros]
----
interface NodesClusterAppliedStats {
  recordings?: <<NodesRecording>>[]
}
----


[discrete]
[[NodesClusterStateQueue]]
=== NodesClusterStateQueue

[source,ts,subs=+macros]
----
interface NodesClusterStateQueue {
  pass:[/**] @property total Total number of cluster states in queue. */
  total?: <<long>>
  pass:[/**] @property pending Number of pending cluster states in queue. */
  pending?: <<long>>
  pass:[/**] @property committed Number of committed cluster states in queue. */
  committed?: <<long>>
}
----


[discrete]
[[NodesClusterStateUpdate]]
=== NodesClusterStateUpdate

[source,ts,subs=+macros]
----
interface NodesClusterStateUpdate {
  pass:[/**] @property count The number of cluster state update attempts that did not change the cluster state since the node started. */
  count: <<long>>
  pass:[/**] @property computation_time The cumulative amount of time spent computing no-op cluster state updates since the node started. */
  computation_time?: <<Duration>>
  pass:[/**] @property computation_time_millis The cumulative amount of time, in milliseconds, spent computing no-op cluster state updates since the node started. */
  computation_time_millis?: <<DurationValue>><<<UnitMillis>>>
  pass:[/**] @property publication_time The cumulative amount of time spent publishing cluster state updates which ultimately succeeded, which includes everything from the start of the publication (just after the computation of the new cluster state) until the publication has finished and the master node is ready to start processing the next state update. This includes the time measured by `context_construction_time`, `commit_time`, `completion_time` and `master_apply_time`. */
  publication_time?: <<Duration>>
  pass:[/**] @property publication_time_millis The cumulative amount of time, in milliseconds, spent publishing cluster state updates which ultimately succeeded, which includes everything from the start of the publication (just after the computation of the new cluster state) until the publication has finished and the master node is ready to start processing the next state update. This includes the time measured by `context_construction_time`, `commit_time`, `completion_time` and `master_apply_time`. */
  publication_time_millis?: <<DurationValue>><<<UnitMillis>>>
  pass:[/**] @property context_construction_time The cumulative amount of time spent constructing a publication context since the node started for publications that ultimately succeeded. This statistic includes the time spent computing the difference between the current and new cluster state preparing a serialized representation of this difference. */
  context_construction_time?: <<Duration>>
  pass:[/**] @property context_construction_time_millis The cumulative amount of time, in milliseconds, spent constructing a publication context since the node started for publications that ultimately succeeded. This statistic includes the time spent computing the difference between the current and new cluster state preparing a serialized representation of this difference. */
  context_construction_time_millis?: <<DurationValue>><<<UnitMillis>>>
  pass:[/**] @property commit_time The cumulative amount of time spent waiting for a successful cluster state update to commit, which measures the time from the start of each publication until a majority of the master-eligible nodes have written the state to disk and confirmed the write to the elected master. */
  commit_time?: <<Duration>>
  pass:[/**] @property commit_time_millis The cumulative amount of time, in milliseconds, spent waiting for a successful cluster state update to commit, which measures the time from the start of each publication until a majority of the master-eligible nodes have written the state to disk and confirmed the write to the elected master. */
  commit_time_millis?: <<DurationValue>><<<UnitMillis>>>
  pass:[/**] @property completion_time The cumulative amount of time spent waiting for a successful cluster state update to complete, which measures the time from the start of each publication until all the other nodes have notified the elected master that they have applied the cluster state. */
  completion_time?: <<Duration>>
  pass:[/**] @property completion_time_millis The cumulative amount of time, in milliseconds, spent waiting for a successful cluster state update to complete, which measures the time from the start of each publication until all the other nodes have notified the elected master that they have applied the cluster state. */
  completion_time_millis?: <<DurationValue>><<<UnitMillis>>>
  pass:[/**] @property master_apply_time The cumulative amount of time spent successfully applying cluster state updates on the elected master since the node started. */
  master_apply_time?: <<Duration>>
  pass:[/**] @property master_apply_time_millis The cumulative amount of time, in milliseconds, spent successfully applying cluster state updates on the elected master since the node started. */
  master_apply_time_millis?: <<DurationValue>><<<UnitMillis>>>
  pass:[/**] @property notification_time The cumulative amount of time spent notifying listeners of a no-op cluster state update since the node started. */
  notification_time?: <<Duration>>
  pass:[/**] @property notification_time_millis The cumulative amount of time, in milliseconds, spent notifying listeners of a no-op cluster state update since the node started. */
  notification_time_millis?: <<DurationValue>><<<UnitMillis>>>
}
----


[discrete]
[[NodesContext]]
=== NodesContext

[source,ts,subs=+macros]
----
interface NodesContext {
  context?: string
  compilations?: <<long>>
  cache_evictions?: <<long>>
  compilation_limit_triggered?: <<long>>
}
----


[discrete]
[[NodesCpu]]
=== NodesCpu

[source,ts,subs=+macros]
----
interface NodesCpu {
  percent?: <<integer>>
  sys?: <<Duration>>
  sys_in_millis?: <<DurationValue>><<<UnitMillis>>>
  total?: <<Duration>>
  total_in_millis?: <<DurationValue>><<<UnitMillis>>>
  user?: <<Duration>>
  user_in_millis?: <<DurationValue>><<<UnitMillis>>>
  load_average?: Record<string, <<double>>>
}
----


[discrete]
[[NodesCpuAcct]]
=== NodesCpuAcct

[source,ts,subs=+macros]
----
interface NodesCpuAcct {
  pass:[/**] @property control_group The `cpuacct` control group to which the Elasticsearch process belongs. */
  control_group?: string
  pass:[/**] @property usage_nanos The total CPU time, in nanoseconds, consumed by all tasks in the same cgroup as the Elasticsearch process. */
  usage_nanos?: <<DurationValue>><<<UnitNanos>>>
}
----


[discrete]
[[NodesDataPathStats]]
=== NodesDataPathStats

[source,ts,subs=+macros]
----
interface NodesDataPathStats {
  pass:[/**] @property available Total amount of disk space available to this Java virtual machine on this file store. */
  available?: string
  pass:[/**] @property available_in_bytes Total number of bytes available to this Java virtual machine on this file store. */
  available_in_bytes?: <<long>>
  disk_queue?: string
  disk_reads?: <<long>>
  disk_read_size?: string
  disk_read_size_in_bytes?: <<long>>
  disk_writes?: <<long>>
  disk_write_size?: string
  disk_write_size_in_bytes?: <<long>>
  pass:[/**] @property free Total amount of unallocated disk space in the file store. */
  free?: string
  pass:[/**] @property free_in_bytes Total number of unallocated bytes in the file store. */
  free_in_bytes?: <<long>>
  pass:[/**] @property mount Mount point of the file store (for example: `/dev/sda2`). */
  mount?: string
  pass:[/**] @property path Path to the file store. */
  path?: string
  pass:[/**] @property total Total size of the file store. */
  total?: string
  pass:[/**] @property total_in_bytes Total size of the file store in bytes. */
  total_in_bytes?: <<long>>
  pass:[/**] @property type Type of the file store (ex: ext4). */
  type?: string
}
----


[discrete]
[[NodesDiscovery]]
=== NodesDiscovery

[source,ts,subs=+macros]
----
interface NodesDiscovery {
  pass:[/**] @property cluster_state_queue Contains statistics for the cluster state queue of the node. */
  cluster_state_queue?: <<NodesClusterStateQueue>>
  pass:[/**] @property published_cluster_states Contains statistics for the published cluster states of the node. */
  published_cluster_states?: <<NodesPublishedClusterStates>>
  pass:[/**] @property cluster_state_update Contains low-level statistics about how <<long>> various activities took during cluster state updates while the node was the elected master. Omitted if the node is not master-eligible. Every field whose name ends in `_time` within this object is also represented as a raw number of milliseconds in a field whose name ends in `_time_millis`. The human-readable fields with a `_time` suffix are only returned if requested with the `?human=true` query parameter. */
  cluster_state_update?: Record<string, <<NodesClusterStateUpdate>>>
  serialized_cluster_states?: <<NodesSerializedClusterState>>
  cluster_applier_stats?: <<NodesClusterAppliedStats>>
}
----


[discrete]
[[NodesExtendedMemoryStats]]
=== NodesExtendedMemoryStats

[source,ts,subs=+macros]
----
interface NodesExtendedMemoryStats extends <<NodesMemoryStats>> {
  pass:[/**] @property free_percent <<Percentage>> of free memory. */
  free_percent?: <<integer>>
  pass:[/**] @property used_percent <<Percentage>> of used memory. */
  used_percent?: <<integer>>
}
----


[discrete]
[[NodesFileSystem]]
=== NodesFileSystem

[source,ts,subs=+macros]
----
interface NodesFileSystem {
  pass:[/**] @property data List of all file stores. */
  data?: <<NodesDataPathStats>>[]
  pass:[/**] @property timestamp Last time the file stores statistics were refreshed. Recorded in milliseconds since the Unix Epoch. */
  timestamp?: <<long>>
  pass:[/**] @property total Contains statistics for all file stores of the node. */
  total?: <<NodesFileSystemTotal>>
  pass:[/**] @property io_stats Contains I/O statistics for the node. */
  io_stats?: <<NodesIoStats>>
}
----


[discrete]
[[NodesFileSystemTotal]]
=== NodesFileSystemTotal

[source,ts,subs=+macros]
----
interface NodesFileSystemTotal {
  pass:[/**] @property available Total disk space available to this Java virtual machine on all file stores. Depending on OS or process level restrictions, this might appear less than `free`. This is the actual amount of free disk space the Elasticsearch node can utilise. */
  available?: string
  pass:[/**] @property available_in_bytes Total number of bytes available to this Java virtual machine on all file stores. Depending on OS or process level restrictions, this might appear less than `free_in_bytes`. This is the actual amount of free disk space the Elasticsearch node can utilise. */
  available_in_bytes?: <<long>>
  pass:[/**] @property free Total unallocated disk space in all file stores. */
  free?: string
  pass:[/**] @property free_in_bytes Total number of unallocated bytes in all file stores. */
  free_in_bytes?: <<long>>
  pass:[/**] @property total Total size of all file stores. */
  total?: string
  pass:[/**] @property total_in_bytes Total size of all file stores in bytes. */
  total_in_bytes?: <<long>>
}
----


[discrete]
[[NodesGarbageCollector]]
=== NodesGarbageCollector

[source,ts,subs=+macros]
----
interface NodesGarbageCollector {
  pass:[/**] @property collectors Contains statistics about JVM garbage collectors for the node. */
  collectors?: Record<string, <<NodesGarbageCollectorTotal>>>
}
----


[discrete]
[[NodesGarbageCollectorTotal]]
=== NodesGarbageCollectorTotal

[source,ts,subs=+macros]
----
interface NodesGarbageCollectorTotal {
  pass:[/**] @property collection_count Total number of JVM garbage collectors that collect objects. */
  collection_count?: <<long>>
  pass:[/**] @property collection_time Total time spent by JVM collecting objects. */
  collection_time?: string
  pass:[/**] @property collection_time_in_millis Total time, in milliseconds, spent by JVM collecting objects. */
  collection_time_in_millis?: <<long>>
}
----


[discrete]
[[NodesHttp]]
=== NodesHttp

[source,ts,subs=+macros]
----
interface NodesHttp {
  pass:[/**] @property current_open Current number of open HTTP connections for the node. */
  current_open?: <<integer>>
  pass:[/**] @property total_opened Total number of HTTP connections opened for the node. */
  total_opened?: <<long>>
  pass:[/**] @property clients Information on current and recently-closed HTTP client connections. Clients that have been closed longer than the `http.client_stats.closed_channels.max_age` setting will not be represented here. */
  clients?: <<NodesClient>>[]
  pass:[/**] @property routes Detailed HTTP stats broken down by route */
  routes: Record<string, <<NodesHttpRoute>>>
}
----


[discrete]
[[NodesHttpRoute]]
=== NodesHttpRoute

[source,ts,subs=+macros]
----
interface NodesHttpRoute {
  requests: <<NodesHttpRouteRequests>>
  responses: <<NodesHttpRouteResponses>>
}
----


[discrete]
[[NodesHttpRouteRequests]]
=== NodesHttpRouteRequests

[source,ts,subs=+macros]
----
interface NodesHttpRouteRequests {
  count: <<long>>
  total_size_in_bytes: <<long>>
  size_histogram: <<NodesSizeHttpHistogram>>[]
}
----


[discrete]
[[NodesHttpRouteResponses]]
=== NodesHttpRouteResponses

[source,ts,subs=+macros]
----
interface NodesHttpRouteResponses {
  count: <<long>>
  total_size_in_bytes: <<long>>
  handling_time_histogram: <<NodesTimeHttpHistogram>>[]
  size_histogram: <<NodesSizeHttpHistogram>>[]
}
----


[discrete]
[[NodesIndexingPressure]]
=== NodesIndexingPressure

[source,ts,subs=+macros]
----
interface NodesIndexingPressure {
  pass:[/**] @property memory Contains statistics for memory consumption from indexing load. */
  memory?: <<NodesIndexingPressureMemory>>
}
----


[discrete]
[[NodesIndexingPressureMemory]]
=== NodesIndexingPressureMemory

[source,ts,subs=+macros]
----
interface NodesIndexingPressureMemory {
  pass:[/**] @property limit Configured memory limit for the indexing requests. Replica requests have an automatic limit that is 1.5x this value. */
  limit?: <<ByteSize>>
  pass:[/**] @property limit_in_bytes Configured memory limit, in bytes, for the indexing requests. Replica requests have an automatic limit that is 1.5x this value. */
  limit_in_bytes?: <<long>>
  pass:[/**] @property current Contains statistics for current indexing load. */
  current?: <<NodesPressureMemory>>
  pass:[/**] @property total Contains statistics for the cumulative indexing load since the node started. */
  total?: <<NodesPressureMemory>>
}
----


[discrete]
[[NodesIngest]]
=== NodesIngest

[source,ts,subs=+macros]
----
interface NodesIngest {
  pass:[/**] @property pipelines Contains statistics about ingest pipelines for the node. */
  pipelines?: Record<string, <<NodesIngestStats>>>
  pass:[/**] @property total Contains statistics about ingest operations for the node. */
  total?: <<NodesIngestTotal>>
}
----


[discrete]
[[NodesIngestStats]]
=== NodesIngestStats

[source,ts,subs=+macros]
----
interface NodesIngestStats {
  pass:[/**] @property count Total number of documents ingested during the lifetime of this node. */
  count: <<long>>
  pass:[/**] @property current Total number of documents currently being ingested. */
  current: <<long>>
  pass:[/**] @property failed Total number of failed ingest operations during the lifetime of this node. */
  failed: <<long>>
  pass:[/**] @property processors Total number of ingest processors. */
  processors: Record<string, <<NodesKeyedProcessor>>>[]
  pass:[/**] @property time_in_millis Total time, in milliseconds, spent preprocessing ingest documents during the lifetime of this node. */
  time_in_millis: <<DurationValue>><<<UnitMillis>>>
  pass:[/**] @property ingested_as_first_pipeline_in_bytes Total number of bytes of all documents ingested by the pipeline. This field is only present on pipelines which are the first to process a document. Thus, it is not present on pipelines which only serve as a final pipeline after a default pipeline, a pipeline run after a reroute processor, or pipelines in pipeline processors. */
  ingested_as_first_pipeline_in_bytes: <<long>>
  pass:[/**] @property produced_as_first_pipeline_in_bytes Total number of bytes of all documents produced by the pipeline. This field is only present on pipelines which are the first to process a document. Thus, it is not present on pipelines which only serve as a final pipeline after a default pipeline, a pipeline run after a reroute processor, or pipelines in pipeline processors. In situations where there are subsequent pipelines, the value represents the size of the document after all pipelines have run. */
  produced_as_first_pipeline_in_bytes: <<long>>
}
----


[discrete]
[[NodesIngestTotal]]
=== NodesIngestTotal

[source,ts,subs=+macros]
----
interface NodesIngestTotal {
  pass:[/**] @property count Total number of documents ingested during the lifetime of this node. */
  count: <<long>>
  pass:[/**] @property current Total number of documents currently being ingested. */
  current: <<long>>
  pass:[/**] @property failed Total number of failed ingest operations during the lifetime of this node. */
  failed: <<long>>
  pass:[/**] @property time_in_millis Total time, in milliseconds, spent preprocessing ingest documents during the lifetime of this node. */
  time_in_millis: <<DurationValue>><<<UnitMillis>>>
}
----


[discrete]
[[NodesIoStatDevice]]
=== NodesIoStatDevice

[source,ts,subs=+macros]
----
interface NodesIoStatDevice {
  pass:[/**] @property device_name The Linux device name. */
  device_name?: string
  pass:[/**] @property operations The total number of read and write operations for the device completed since starting Elasticsearch. */
  operations?: <<long>>
  pass:[/**] @property read_kilobytes The total number of kilobytes read for the device since starting Elasticsearch. */
  read_kilobytes?: <<long>>
  pass:[/**] @property read_operations The total number of read operations for the device completed since starting Elasticsearch. */
  read_operations?: <<long>>
  pass:[/**] @property write_kilobytes The total number of kilobytes written for the device since starting Elasticsearch. */
  write_kilobytes?: <<long>>
  pass:[/**] @property write_operations The total number of write operations for the device completed since starting Elasticsearch. */
  write_operations?: <<long>>
}
----


[discrete]
[[NodesIoStats]]
=== NodesIoStats

[source,ts,subs=+macros]
----
interface NodesIoStats {
  pass:[/**] @property devices Array of disk metrics for each device that is backing an Elasticsearch data path. These disk metrics are probed periodically and averages between the last probe and the current probe are computed. */
  devices?: <<NodesIoStatDevice>>[]
  pass:[/**] @property total The sum of the disk metrics for all devices that back an Elasticsearch data path. */
  total?: <<NodesIoStatDevice>>
}
----


[discrete]
[[NodesJvm]]
=== NodesJvm

[source,ts,subs=+macros]
----
interface NodesJvm {
  pass:[/**] @property buffer_pools Contains statistics about JVM buffer pools for the node. */
  buffer_pools?: Record<string, <<NodesNodeBufferPool>>>
  pass:[/**] @property classes Contains statistics about classes loaded by JVM for the node. */
  classes?: <<NodesJvmClasses>>
  pass:[/**] @property gc Contains statistics about JVM garbage collectors for the node. */
  gc?: <<NodesGarbageCollector>>
  pass:[/**] @property mem Contains JVM memory usage statistics for the node. */
  mem?: <<NodesJvmMemoryStats>>
  pass:[/**] @property threads Contains statistics about JVM thread usage for the node. */
  threads?: <<NodesJvmThreads>>
  pass:[/**] @property timestamp Last time JVM statistics were refreshed. */
  timestamp?: <<long>>
  pass:[/**] @property uptime Human-readable JVM uptime. Only returned if the `human` query parameter is `true`. */
  uptime?: string
  pass:[/**] @property uptime_in_millis JVM uptime in milliseconds. */
  uptime_in_millis?: <<long>>
}
----


[discrete]
[[NodesJvmClasses]]
=== NodesJvmClasses

[source,ts,subs=+macros]
----
interface NodesJvmClasses {
  pass:[/**] @property current_loaded_count Number of classes currently loaded by JVM. */
  current_loaded_count?: <<long>>
  pass:[/**] @property total_loaded_count Total number of classes loaded since the JVM started. */
  total_loaded_count?: <<long>>
  pass:[/**] @property total_unloaded_count Total number of classes unloaded since the JVM started. */
  total_unloaded_count?: <<long>>
}
----


[discrete]
[[NodesJvmMemoryStats]]
=== NodesJvmMemoryStats

[source,ts,subs=+macros]
----
interface NodesJvmMemoryStats {
  pass:[/**] @property heap_used_in_bytes Memory, in bytes, currently in use by the heap. */
  heap_used_in_bytes?: <<long>>
  pass:[/**] @property heap_used_percent <<Percentage>> of memory currently in use by the heap. */
  heap_used_percent?: <<long>>
  pass:[/**] @property heap_committed_in_bytes Amount of memory, in bytes, available for use by the heap. */
  heap_committed_in_bytes?: <<long>>
  pass:[/**] @property heap_max_in_bytes Maximum amount of memory, in bytes, available for use by the heap. */
  heap_max_in_bytes?: <<long>>
  pass:[/**] @property non_heap_used_in_bytes Non-heap memory used, in bytes. */
  non_heap_used_in_bytes?: <<long>>
  pass:[/**] @property non_heap_committed_in_bytes Amount of non-heap memory available, in bytes. */
  non_heap_committed_in_bytes?: <<long>>
  pass:[/**] @property pools Contains statistics about heap memory usage for the node. */
  pools?: Record<string, <<NodesPool>>>
}
----


[discrete]
[[NodesJvmThreads]]
=== NodesJvmThreads

[source,ts,subs=+macros]
----
interface NodesJvmThreads {
  pass:[/**] @property count Number of active threads in use by JVM. */
  count?: <<long>>
  pass:[/**] @property peak_count Highest number of threads used by JVM. */
  peak_count?: <<long>>
}
----


[discrete]
[[NodesKeyedProcessor]]
=== NodesKeyedProcessor

[source,ts,subs=+macros]
----
interface NodesKeyedProcessor {
  stats?: <<NodesProcessor>>
  type?: string
}
----


[discrete]
[[NodesMemoryStats]]
=== NodesMemoryStats

[source,ts,subs=+macros]
----
interface NodesMemoryStats {
  pass:[/**] @property adjusted_total_in_bytes If the amount of physical memory has been overridden using the `es`.`total_memory_bytes` system property then this reports the overridden value in bytes. Otherwise it reports the same value as `total_in_bytes`. */
  adjusted_total_in_bytes?: <<long>>
  resident?: string
  resident_in_bytes?: <<long>>
  share?: string
  share_in_bytes?: <<long>>
  total_virtual?: string
  total_virtual_in_bytes?: <<long>>
  pass:[/**] @property total_in_bytes Total amount of physical memory in bytes. */
  total_in_bytes?: <<long>>
  pass:[/**] @property free_in_bytes Amount of free physical memory in bytes. */
  free_in_bytes?: <<long>>
  pass:[/**] @property used_in_bytes Amount of used physical memory in bytes. */
  used_in_bytes?: <<long>>
}
----


[discrete]
[[NodesNodeBufferPool]]
=== NodesNodeBufferPool

[source,ts,subs=+macros]
----
interface NodesNodeBufferPool {
  pass:[/**] @property count Number of buffer pools. */
  count?: <<long>>
  pass:[/**] @property total_capacity Total capacity of buffer pools. */
  total_capacity?: string
  pass:[/**] @property total_capacity_in_bytes Total capacity of buffer pools in bytes. */
  total_capacity_in_bytes?: <<long>>
  pass:[/**] @property used Size of buffer pools. */
  used?: string
  pass:[/**] @property used_in_bytes Size of buffer pools in bytes. */
  used_in_bytes?: <<long>>
}
----


[discrete]
[[NodesNodeReloadError]]
=== NodesNodeReloadError

[source,ts,subs=+macros]
----
interface NodesNodeReloadError {
  name: <<Name>>
  reload_exception?: <<ErrorCause>>
}
----


[discrete]
[[NodesNodeReloadResult]]
=== NodesNodeReloadResult

[source,ts,subs=+macros]
----
type NodesNodeReloadResult = <<NodesStats>> | <<NodesNodeReloadError>>
----


[discrete]
[[NodesNodesResponseBase]]
=== NodesNodesResponseBase

[source,ts,subs=+macros]
----
interface NodesNodesResponseBase {
  pass:[/**] @property _nodes Contains statistics about the number of nodes selected by the request’s node filters. */
  _nodes?: <<NodeStatistics>>
}
----


[discrete]
[[NodesOperatingSystem]]
=== NodesOperatingSystem

[source,ts,subs=+macros]
----
interface NodesOperatingSystem {
  cpu?: <<NodesCpu>>
  mem?: <<NodesExtendedMemoryStats>>
  swap?: <<NodesMemoryStats>>
  cgroup?: <<NodesCgroup>>
  timestamp?: <<long>>
}
----


[discrete]
[[NodesPool]]
=== NodesPool

[source,ts,subs=+macros]
----
interface NodesPool {
  pass:[/**] @property used_in_bytes Memory, in bytes, used by the heap. */
  used_in_bytes?: <<long>>
  pass:[/**] @property max_in_bytes Maximum amount of memory, in bytes, available for use by the heap. */
  max_in_bytes?: <<long>>
  pass:[/**] @property peak_used_in_bytes Largest amount of memory, in bytes, historically used by the heap. */
  peak_used_in_bytes?: <<long>>
  pass:[/**] @property peak_max_in_bytes Largest amount of memory, in bytes, historically used by the heap. */
  peak_max_in_bytes?: <<long>>
}
----


[discrete]
[[NodesPressureMemory]]
=== NodesPressureMemory

[source,ts,subs=+macros]
----
interface NodesPressureMemory {
  pass:[/**] @property all Memory consumed by indexing requests in the coordinating, primary, or replica stage. */
  all?: <<ByteSize>>
  pass:[/**] @property all_in_bytes Memory consumed, in bytes, by indexing requests in the coordinating, primary, or replica stage. */
  all_in_bytes?: <<long>>
  pass:[/**] @property combined_coordinating_and_primary Memory consumed by indexing requests in the coordinating or primary stage. This value is not the sum of coordinating and primary as a node can reuse the coordinating memory if the primary stage is executed locally. */
  combined_coordinating_and_primary?: <<ByteSize>>
  pass:[/**] @property combined_coordinating_and_primary_in_bytes Memory consumed, in bytes, by indexing requests in the coordinating or primary stage. This value is not the sum of coordinating and primary as a node can reuse the coordinating memory if the primary stage is executed locally. */
  combined_coordinating_and_primary_in_bytes?: <<long>>
  pass:[/**] @property coordinating Memory consumed by indexing requests in the coordinating stage. */
  coordinating?: <<ByteSize>>
  pass:[/**] @property coordinating_in_bytes Memory consumed, in bytes, by indexing requests in the coordinating stage. */
  coordinating_in_bytes?: <<long>>
  pass:[/**] @property primary Memory consumed by indexing requests in the primary stage. */
  primary?: <<ByteSize>>
  pass:[/**] @property primary_in_bytes Memory consumed, in bytes, by indexing requests in the primary stage. */
  primary_in_bytes?: <<long>>
  pass:[/**] @property replica Memory consumed by indexing requests in the replica stage. */
  replica?: <<ByteSize>>
  pass:[/**] @property replica_in_bytes Memory consumed, in bytes, by indexing requests in the replica stage. */
  replica_in_bytes?: <<long>>
  pass:[/**] @property coordinating_rejections Number of indexing requests rejected in the coordinating stage. */
  coordinating_rejections?: <<long>>
  pass:[/**] @property primary_rejections Number of indexing requests rejected in the primary stage. */
  primary_rejections?: <<long>>
  pass:[/**] @property replica_rejections Number of indexing requests rejected in the replica stage. */
  replica_rejections?: <<long>>
}
----


[discrete]
[[NodesProcess]]
=== NodesProcess

[source,ts,subs=+macros]
----
interface NodesProcess {
  pass:[/**] @property cpu Contains CPU statistics for the node. */
  cpu?: <<NodesCpu>>
  pass:[/**] @property mem Contains virtual memory statistics for the node. */
  mem?: <<NodesMemoryStats>>
  pass:[/**] @property open_file_descriptors Number of opened file descriptors associated with the current or `-1` if not supported. */
  open_file_descriptors?: <<integer>>
  pass:[/**] @property max_file_descriptors Maximum number of file descriptors allowed on the system, or `-1` if not supported. */
  max_file_descriptors?: <<integer>>
  pass:[/**] @property timestamp Last time the statistics were refreshed. Recorded in milliseconds since the Unix Epoch. */
  timestamp?: <<long>>
}
----


[discrete]
[[NodesProcessor]]
=== NodesProcessor

[source,ts,subs=+macros]
----
interface NodesProcessor {
  pass:[/**] @property count Number of documents transformed by the processor. */
  count?: <<long>>
  pass:[/**] @property current Number of documents currently being transformed by the processor. */
  current?: <<long>>
  pass:[/**] @property failed Number of failed operations for the processor. */
  failed?: <<long>>
  pass:[/**] @property time_in_millis Time, in milliseconds, spent by the processor transforming documents. */
  time_in_millis?: <<DurationValue>><<<UnitMillis>>>
}
----


[discrete]
[[NodesPublishedClusterStates]]
=== NodesPublishedClusterStates

[source,ts,subs=+macros]
----
interface NodesPublishedClusterStates {
  pass:[/**] @property full_states Number of published cluster states. */
  full_states?: <<long>>
  pass:[/**] @property incompatible_diffs Number of incompatible differences between published cluster states. */
  incompatible_diffs?: <<long>>
  pass:[/**] @property compatible_diffs Number of compatible differences between published cluster states. */
  compatible_diffs?: <<long>>
}
----


[discrete]
[[NodesRecording]]
=== NodesRecording

[source,ts,subs=+macros]
----
interface NodesRecording {
  name?: string
  cumulative_execution_count?: <<long>>
  cumulative_execution_time?: <<Duration>>
  cumulative_execution_time_millis?: <<DurationValue>><<<UnitMillis>>>
}
----


[discrete]
[[NodesRepositoryLocation]]
=== NodesRepositoryLocation

[source,ts,subs=+macros]
----
interface NodesRepositoryLocation {
  base_path: string
  pass:[/**] @property container Container name (Azure) */
  container?: string
  pass:[/**] @property bucket Bucket name (GCP, S3) */
  bucket?: string
}
----


[discrete]
[[NodesRepositoryMeteringInformation]]
=== NodesRepositoryMeteringInformation

[source,ts,subs=+macros]
----
interface NodesRepositoryMeteringInformation {
  pass:[/**] @property repository_name Repository name. */
  repository_name: <<Name>>
  pass:[/**] @property repository_type Repository type. */
  repository_type: string
  pass:[/**] @property repository_location Represents an unique location within the repository. */
  repository_location: <<NodesRepositoryLocation>>
  pass:[/**] @property repository_ephemeral_id An identifier that changes every time the repository is updated. */
  repository_ephemeral_id: <<Id>>
  pass:[/**] @property repository_started_at Time the repository was created or updated. Recorded in milliseconds since the Unix Epoch. */
  repository_started_at: <<EpochTime>><<<UnitMillis>>>
  pass:[/**] @property repository_stopped_at Time the repository was deleted or updated. Recorded in milliseconds since the Unix Epoch. */
  repository_stopped_at?: <<EpochTime>><<<UnitMillis>>>
  pass:[/**] @property archived A flag that tells whether or not this object has been archived. When a repository is closed or updated the repository metering information is archived and kept for a certain period of time. This allows retrieving the repository metering information of previous repository instantiations. */
  archived: boolean
  pass:[/**] @property cluster_version The cluster state version when this object was archived, this field can be used as a logical timestamp to delete all the archived metrics up to an observed version. This field is only present for archived repository metering information objects. The main purpose of this field is to avoid possible race conditions during repository metering information deletions, i.e. deleting archived repositories metering information that we haven’t observed yet. */
  cluster_version?: <<VersionNumber>>
  pass:[/**] @property request_counts An object with the number of request performed against the repository grouped by request type. */
  request_counts: <<NodesRequestCounts>>
}
----


[discrete]
[[NodesRequestCounts]]
=== NodesRequestCounts

[source,ts,subs=+macros]
----
interface NodesRequestCounts {
  pass:[/**] @property GetBlobProperties Number of Get Blob Properties requests (Azure) */
  GetBlobProperties?: <<long>>
  pass:[/**] @property GetBlob Number of Get Blob requests (Azure) */
  GetBlob?: <<long>>
  pass:[/**] @property ListBlobs Number of List Blobs requests (Azure) */
  ListBlobs?: <<long>>
  pass:[/**] @property PutBlob Number of Put Blob requests (Azure) */
  PutBlob?: <<long>>
  pass:[/**] @property PutBlock Number of Put Block (Azure) */
  PutBlock?: <<long>>
  pass:[/**] @property PutBlockList Number of Put Block List requests */
  PutBlockList?: <<long>>
  pass:[/**] @property GetObject Number of get object requests (GCP, S3) */
  GetObject?: <<long>>
  pass:[/**] @property ListObjects Number of list objects requests (GCP, S3) */
  ListObjects?: <<long>>
  pass:[/**] @property InsertObject Number of insert object requests, including simple, multipart and resumable uploads. Resumable uploads can perform multiple http requests to insert a single object but they are considered as a single request since they are billed as an individual operation. (GCP) */
  InsertObject?: <<long>>
  pass:[/**] @property PutObject Number of PutObject requests (S3) */
  PutObject?: <<long>>
  pass:[/**] @property PutMultipartObject Number of Multipart requests, including CreateMultipartUpload, UploadPart and CompleteMultipartUpload requests (S3) */
  PutMultipartObject?: <<long>>
}
----


[discrete]
[[NodesScriptCache]]
=== NodesScriptCache

[source,ts,subs=+macros]
----
interface NodesScriptCache {
  pass:[/**] @property cache_evictions Total number of times the script cache has evicted old data. */
  cache_evictions?: <<long>>
  pass:[/**] @property compilation_limit_triggered Total number of times the script compilation circuit breaker has limited inline script compilations. */
  compilation_limit_triggered?: <<long>>
  pass:[/**] @property compilations Total number of inline script compilations performed by the node. */
  compilations?: <<long>>
  context?: string
}
----


[discrete]
[[NodesScripting]]
=== NodesScripting

[source,ts,subs=+macros]
----
interface NodesScripting {
  pass:[/**] @property cache_evictions Total number of times the script cache has evicted old data. */
  cache_evictions?: <<long>>
  pass:[/**] @property compilations Total number of inline script compilations performed by the node. */
  compilations?: <<long>>
  pass:[/**] @property compilations_history Contains this recent history of script compilations. */
  compilations_history?: Record<string, <<long>>>
  pass:[/**] @property compilation_limit_triggered Total number of times the script compilation circuit breaker has limited inline script compilations. */
  compilation_limit_triggered?: <<long>>
  contexts?: <<NodesContext>>[]
}
----


[discrete]
[[NodesSerializedClusterState]]
=== NodesSerializedClusterState

[source,ts,subs=+macros]
----
interface NodesSerializedClusterState {
  pass:[/**] @property full_states Number of published cluster states. */
  full_states?: <<NodesSerializedClusterStateDetail>>
  diffs?: <<NodesSerializedClusterStateDetail>>
}
----


[discrete]
[[NodesSerializedClusterStateDetail]]
=== NodesSerializedClusterStateDetail

[source,ts,subs=+macros]
----
interface NodesSerializedClusterStateDetail {
  count?: <<long>>
  uncompressed_size?: string
  uncompressed_size_in_bytes?: <<long>>
  compressed_size?: string
  compressed_size_in_bytes?: <<long>>
}
----


[discrete]
[[NodesSizeHttpHistogram]]
=== NodesSizeHttpHistogram

[source,ts,subs=+macros]
----
interface NodesSizeHttpHistogram {
  count: <<long>>
  ge_bytes?: <<long>>
  lt_bytes?: <<long>>
}
----


[discrete]
[[NodesStats]]
=== NodesStats

[source,ts,subs=+macros]
----
interface NodesStats {
  pass:[/**] @property adaptive_selection Statistics about adaptive replica selection. */
  adaptive_selection?: Record<string, <<NodesAdaptiveSelection>>>
  pass:[/**] @property breakers Statistics about the field data circuit breaker. */
  breakers?: Record<string, <<NodesBreaker>>>
  pass:[/**] @property fs File system information, data path, free disk space, read/write stats. */
  fs?: <<NodesFileSystem>>
  pass:[/**] @property host Network host for the node, based on the network host setting. */
  host?: <<Host>>
  pass:[/**] @property http HTTP connection information. */
  http?: <<NodesHttp>>
  pass:[/**] @property ingest Statistics about ingest preprocessing. */
  ingest?: <<NodesIngest>>
  pass:[/**] @property ip IP address and port for the node. */
  ip?: <<Ip>> | <<Ip>>[]
  pass:[/**] @property jvm JVM stats, memory pool information, garbage collection, buffer pools, number of loaded/unloaded classes. */
  jvm?: <<NodesJvm>>
  pass:[/**] @property name Human-readable identifier for the node. Based on the node name setting. */
  name?: <<Name>>
  pass:[/**] @property os Operating system stats, load average, mem, swap. */
  os?: <<NodesOperatingSystem>>
  pass:[/**] @property process Process statistics, memory consumption, cpu usage, open file descriptors. */
  process?: <<NodesProcess>>
  pass:[/**] @property roles Roles assigned to the node. */
  roles?: <<NodeRoles>>
  pass:[/**] @property script Contains script statistics for the node. */
  script?: <<NodesScripting>>
  script_cache?: Record<string, <<NodesScriptCache>> | <<NodesScriptCache>>[]>
  pass:[/**] @property thread_pool Statistics about each thread pool, including current size, queue and rejected tasks. */
  thread_pool?: Record<string, <<NodesThreadCount>>>
  timestamp?: <<long>>
  pass:[/**] @property transport Transport statistics about sent and received bytes in cluster communication. */
  transport?: <<NodesTransport>>
  pass:[/**] @property transport_address <<Host>> and port for the transport layer, used for internal communication between nodes in a cluster. */
  transport_address?: <<TransportAddress>>
  pass:[/**] @property attributes Contains a list of attributes for the node. */
  attributes?: Record<<<Field>>, string>
  pass:[/**] @property discovery Contains node discovery statistics for the node. */
  discovery?: <<NodesDiscovery>>
  pass:[/**] @property indexing_pressure Contains indexing pressure statistics for the node. */
  indexing_pressure?: <<NodesIndexingPressure>>
  pass:[/**] @property indices <<Indices>> stats about size, document count, indexing and deletion times, search times, field cache size, merges and flushes. */
  indices?: IndicesStatsShardStats
}
----


[discrete]
[[NodesThreadCount]]
=== NodesThreadCount

[source,ts,subs=+macros]
----
interface NodesThreadCount {
  pass:[/**] @property active Number of active threads in the thread pool. */
  active?: <<long>>
  pass:[/**] @property completed Number of tasks completed by the thread pool executor. */
  completed?: <<long>>
  pass:[/**] @property largest Highest number of active threads in the thread pool. */
  largest?: <<long>>
  pass:[/**] @property queue Number of tasks in queue for the thread pool. */
  queue?: <<long>>
  pass:[/**] @property rejected Number of tasks rejected by the thread pool executor. */
  rejected?: <<long>>
  pass:[/**] @property threads Number of threads in the thread pool. */
  threads?: <<long>>
}
----


[discrete]
[[NodesTimeHttpHistogram]]
=== NodesTimeHttpHistogram

[source,ts,subs=+macros]
----
interface NodesTimeHttpHistogram {
  count: <<long>>
  ge_millis?: <<long>>
  lt_millis?: <<long>>
}
----


[discrete]
[[NodesTransport]]
=== NodesTransport

[source,ts,subs=+macros]
----
interface NodesTransport {
  pass:[/**] @property inbound_handling_time_histogram The distribution of the time spent handling each inbound message on a transport thread, represented as a histogram. */
  inbound_handling_time_histogram?: <<NodesTransportHistogram>>[]
  pass:[/**] @property outbound_handling_time_histogram The distribution of the time spent sending each outbound transport message on a transport thread, represented as a histogram. */
  outbound_handling_time_histogram?: <<NodesTransportHistogram>>[]
  pass:[/**] @property rx_count Total number of RX (receive) packets received by the node during internal cluster communication. */
  rx_count?: <<long>>
  pass:[/**] @property rx_size Size of RX packets received by the node during internal cluster communication. */
  rx_size?: string
  pass:[/**] @property rx_size_in_bytes Size, in bytes, of RX packets received by the node during internal cluster communication. */
  rx_size_in_bytes?: <<long>>
  pass:[/**] @property server_open Current number of inbound TCP connections used for internal communication between nodes. */
  server_open?: <<integer>>
  pass:[/**] @property tx_count Total number of TX (transmit) packets sent by the node during internal cluster communication. */
  tx_count?: <<long>>
  pass:[/**] @property tx_size Size of TX packets sent by the node during internal cluster communication. */
  tx_size?: string
  pass:[/**] @property tx_size_in_bytes Size, in bytes, of TX packets sent by the node during internal cluster communication. */
  tx_size_in_bytes?: <<long>>
  pass:[/**] @property total_outbound_connections The cumulative number of outbound transport connections that this node has opened since it started. Each transport connection may comprise multiple TCP connections but is only counted once in this statistic. Transport connections are typically <<long>>-lived so this statistic should remain constant in a stable cluster. */
  total_outbound_connections?: <<long>>
}
----


[discrete]
[[NodesTransportHistogram]]
=== NodesTransportHistogram

[source,ts,subs=+macros]
----
interface NodesTransportHistogram {
  pass:[/**] @property count The number of times a transport thread took a period of time within the bounds of this bucket to handle an inbound message. */
  count?: <<long>>
  pass:[/**] @property lt_millis The exclusive upper bound of the bucket in milliseconds. May be omitted on the last bucket if this bucket has no upper bound. */
  lt_millis?: <<long>>
  pass:[/**] @property ge_millis The inclusive lower bound of the bucket in milliseconds. May be omitted on the first bucket if this bucket has no lower bound. */
  ge_millis?: <<long>>
}
----


