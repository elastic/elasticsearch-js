/*
 * Licensed to Elasticsearch B.V. under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch B.V. licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/* eslint-disable import/export */
/* eslint-disable @typescript-eslint/no-misused-new */
/* eslint-disable @typescript-eslint/no-extraneous-class */
/* eslint-disable @typescript-eslint/no-unused-vars */

// This file was automatically generated by elastic/elastic-client-generator-js
// DO NOT MODIFY IT BY HAND. Instead, modify the source open api file,
// and elastic/elastic-client-generator-js to regenerate this file again.

import {
  Transport,
  TransportRequestOptions,
  TransportRequestOptionsWithMeta,
  TransportRequestOptionsWithOutMeta,
  TransportResult
} from '@elastic/transport'
import * as T from '../types'
import * as TB from '../typesWithBodyKey'
interface That { transport: Transport }

export default class Ml {
  transport: Transport
  constructor (transport: Transport) {
    this.transport = transport
  }

  async closeJob (this: That, params: T.MlCloseJobRequest | TB.MlCloseJobRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlCloseJobResponse>
  async closeJob (this: That, params: T.MlCloseJobRequest | TB.MlCloseJobRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlCloseJobResponse, unknown>>
  async closeJob (this: That, params: T.MlCloseJobRequest | TB.MlCloseJobRequest, options?: TransportRequestOptions): Promise<T.MlCloseJobResponse>
  async closeJob (this: That, params: T.MlCloseJobRequest | TB.MlCloseJobRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['job_id']
    const acceptedQuery: string[] = ['allow_no_match', 'allow_no_jobs', 'force', 'timeout', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'POST'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_close`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async deleteCalendar (this: That, params: T.MlDeleteCalendarRequest | TB.MlDeleteCalendarRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlDeleteCalendarResponse>
  async deleteCalendar (this: That, params: T.MlDeleteCalendarRequest | TB.MlDeleteCalendarRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlDeleteCalendarResponse, unknown>>
  async deleteCalendar (this: That, params: T.MlDeleteCalendarRequest | TB.MlDeleteCalendarRequest, options?: TransportRequestOptions): Promise<T.MlDeleteCalendarResponse>
  async deleteCalendar (this: That, params: T.MlDeleteCalendarRequest | TB.MlDeleteCalendarRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['calendar_id']
    const acceptedQuery: string[] = ['error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'DELETE'
    const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async deleteCalendarEvent (this: That, params: T.MlDeleteCalendarEventRequest | TB.MlDeleteCalendarEventRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlDeleteCalendarEventResponse>
  async deleteCalendarEvent (this: That, params: T.MlDeleteCalendarEventRequest | TB.MlDeleteCalendarEventRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlDeleteCalendarEventResponse, unknown>>
  async deleteCalendarEvent (this: That, params: T.MlDeleteCalendarEventRequest | TB.MlDeleteCalendarEventRequest, options?: TransportRequestOptions): Promise<T.MlDeleteCalendarEventResponse>
  async deleteCalendarEvent (this: That, params: T.MlDeleteCalendarEventRequest | TB.MlDeleteCalendarEventRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['calendar_id', 'event_id']
    const acceptedQuery: string[] = ['error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'DELETE'
    const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}/events/${encodeURIComponent(params.event_id.toString())}`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async deleteCalendarJob (this: That, params: T.MlDeleteCalendarJobRequest | TB.MlDeleteCalendarJobRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlDeleteCalendarJobResponse>
  async deleteCalendarJob (this: That, params: T.MlDeleteCalendarJobRequest | TB.MlDeleteCalendarJobRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlDeleteCalendarJobResponse, unknown>>
  async deleteCalendarJob (this: That, params: T.MlDeleteCalendarJobRequest | TB.MlDeleteCalendarJobRequest, options?: TransportRequestOptions): Promise<T.MlDeleteCalendarJobResponse>
  async deleteCalendarJob (this: That, params: T.MlDeleteCalendarJobRequest | TB.MlDeleteCalendarJobRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['calendar_id', 'job_id']
    const acceptedQuery: string[] = ['error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'DELETE'
    const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}/jobs/${encodeURIComponent(params.job_id.toString())}`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async deleteDataFrameAnalytics (this: That, params: T.MlDeleteDataFrameAnalyticsRequest | TB.MlDeleteDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlDeleteDataFrameAnalyticsResponse>
  async deleteDataFrameAnalytics (this: That, params: T.MlDeleteDataFrameAnalyticsRequest | TB.MlDeleteDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlDeleteDataFrameAnalyticsResponse, unknown>>
  async deleteDataFrameAnalytics (this: That, params: T.MlDeleteDataFrameAnalyticsRequest | TB.MlDeleteDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<T.MlDeleteDataFrameAnalyticsResponse>
  async deleteDataFrameAnalytics (this: That, params: T.MlDeleteDataFrameAnalyticsRequest | TB.MlDeleteDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['id']
    const acceptedQuery: string[] = ['force', 'timeout', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'DELETE'
    const path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async deleteDatafeed (this: That, params: T.MlDeleteDatafeedRequest | TB.MlDeleteDatafeedRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlDeleteDatafeedResponse>
  async deleteDatafeed (this: That, params: T.MlDeleteDatafeedRequest | TB.MlDeleteDatafeedRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlDeleteDatafeedResponse, unknown>>
  async deleteDatafeed (this: That, params: T.MlDeleteDatafeedRequest | TB.MlDeleteDatafeedRequest, options?: TransportRequestOptions): Promise<T.MlDeleteDatafeedResponse>
  async deleteDatafeed (this: That, params: T.MlDeleteDatafeedRequest | TB.MlDeleteDatafeedRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['datafeed_id']
    const acceptedQuery: string[] = ['force', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'DELETE'
    const path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async deleteExpiredData (this: That, params?: T.MlDeleteExpiredDataRequest | TB.MlDeleteExpiredDataRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlDeleteExpiredDataResponse>
  async deleteExpiredData (this: That, params?: T.MlDeleteExpiredDataRequest | TB.MlDeleteExpiredDataRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlDeleteExpiredDataResponse, unknown>>
  async deleteExpiredData (this: That, params?: T.MlDeleteExpiredDataRequest | TB.MlDeleteExpiredDataRequest, options?: TransportRequestOptions): Promise<T.MlDeleteExpiredDataResponse>
  async deleteExpiredData (this: That, params?: T.MlDeleteExpiredDataRequest | TB.MlDeleteExpiredDataRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['job_id']
    const acceptedQuery: string[] = ['error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params?.body ?? undefined

    params = params ?? {}
    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    let method = ''
    let path = ''
    if (params.job_id != null) {
      method = 'DELETE'
      path = `/_ml/_delete_expired_data/${encodeURIComponent(params.job_id.toString())}`
    } else {
      method = 'DELETE'
      path = '/_ml/_delete_expired_data'
    }
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async deleteFilter (this: That, params: T.MlDeleteFilterRequest | TB.MlDeleteFilterRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlDeleteFilterResponse>
  async deleteFilter (this: That, params: T.MlDeleteFilterRequest | TB.MlDeleteFilterRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlDeleteFilterResponse, unknown>>
  async deleteFilter (this: That, params: T.MlDeleteFilterRequest | TB.MlDeleteFilterRequest, options?: TransportRequestOptions): Promise<T.MlDeleteFilterResponse>
  async deleteFilter (this: That, params: T.MlDeleteFilterRequest | TB.MlDeleteFilterRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['filter_id']
    const acceptedQuery: string[] = ['error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'DELETE'
    const path = `/_ml/filters/${encodeURIComponent(params.filter_id.toString())}`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async deleteForecast (this: That, params: T.MlDeleteForecastRequest | TB.MlDeleteForecastRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlDeleteForecastResponse>
  async deleteForecast (this: That, params: T.MlDeleteForecastRequest | TB.MlDeleteForecastRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlDeleteForecastResponse, unknown>>
  async deleteForecast (this: That, params: T.MlDeleteForecastRequest | TB.MlDeleteForecastRequest, options?: TransportRequestOptions): Promise<T.MlDeleteForecastResponse>
  async deleteForecast (this: That, params: T.MlDeleteForecastRequest | TB.MlDeleteForecastRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['job_id', 'forecast_id']
    const acceptedQuery: string[] = ['allow_no_forecasts', 'timeout', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    let method = ''
    let path = ''
    if (params.job_id != null && params.forecast_id != null) {
      method = 'DELETE'
      path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_forecast/${encodeURIComponent(params.forecast_id.toString())}`
    } else {
      method = 'DELETE'
      path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_forecast`
    }
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async deleteJob (this: That, params: T.MlDeleteJobRequest | TB.MlDeleteJobRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlDeleteJobResponse>
  async deleteJob (this: That, params: T.MlDeleteJobRequest | TB.MlDeleteJobRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlDeleteJobResponse, unknown>>
  async deleteJob (this: That, params: T.MlDeleteJobRequest | TB.MlDeleteJobRequest, options?: TransportRequestOptions): Promise<T.MlDeleteJobResponse>
  async deleteJob (this: That, params: T.MlDeleteJobRequest | TB.MlDeleteJobRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['job_id']
    const acceptedQuery: string[] = ['force', 'wait_for_completion', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'DELETE'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async deleteModelSnapshot (this: That, params: T.MlDeleteModelSnapshotRequest | TB.MlDeleteModelSnapshotRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlDeleteModelSnapshotResponse>
  async deleteModelSnapshot (this: That, params: T.MlDeleteModelSnapshotRequest | TB.MlDeleteModelSnapshotRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlDeleteModelSnapshotResponse, unknown>>
  async deleteModelSnapshot (this: That, params: T.MlDeleteModelSnapshotRequest | TB.MlDeleteModelSnapshotRequest, options?: TransportRequestOptions): Promise<T.MlDeleteModelSnapshotResponse>
  async deleteModelSnapshot (this: That, params: T.MlDeleteModelSnapshotRequest | TB.MlDeleteModelSnapshotRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['job_id', 'snapshot_id']
    const acceptedQuery: string[] = ['error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'DELETE'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots/${encodeURIComponent(params.snapshot_id.toString())}`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async deleteTrainedModel (this: That, params: T.MlDeleteTrainedModelRequest | TB.MlDeleteTrainedModelRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlDeleteTrainedModelResponse>
  async deleteTrainedModel (this: That, params: T.MlDeleteTrainedModelRequest | TB.MlDeleteTrainedModelRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlDeleteTrainedModelResponse, unknown>>
  async deleteTrainedModel (this: That, params: T.MlDeleteTrainedModelRequest | TB.MlDeleteTrainedModelRequest, options?: TransportRequestOptions): Promise<T.MlDeleteTrainedModelResponse>
  async deleteTrainedModel (this: That, params: T.MlDeleteTrainedModelRequest | TB.MlDeleteTrainedModelRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['model_id']
    const acceptedQuery: string[] = ['error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'DELETE'
    const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async deleteTrainedModelAlias (this: That, params: T.MlDeleteTrainedModelAliasRequest | TB.MlDeleteTrainedModelAliasRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlDeleteTrainedModelAliasResponse>
  async deleteTrainedModelAlias (this: That, params: T.MlDeleteTrainedModelAliasRequest | TB.MlDeleteTrainedModelAliasRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlDeleteTrainedModelAliasResponse, unknown>>
  async deleteTrainedModelAlias (this: That, params: T.MlDeleteTrainedModelAliasRequest | TB.MlDeleteTrainedModelAliasRequest, options?: TransportRequestOptions): Promise<T.MlDeleteTrainedModelAliasResponse>
  async deleteTrainedModelAlias (this: That, params: T.MlDeleteTrainedModelAliasRequest | TB.MlDeleteTrainedModelAliasRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['model_alias', 'model_id']
    const acceptedQuery: string[] = ['error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'DELETE'
    const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/model_aliases/${encodeURIComponent(params.model_alias.toString())}`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async estimateModelMemory (this: That, params?: T.MlEstimateModelMemoryRequest | TB.MlEstimateModelMemoryRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlEstimateModelMemoryResponse>
  async estimateModelMemory (this: That, params?: T.MlEstimateModelMemoryRequest | TB.MlEstimateModelMemoryRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlEstimateModelMemoryResponse, unknown>>
  async estimateModelMemory (this: That, params?: T.MlEstimateModelMemoryRequest | TB.MlEstimateModelMemoryRequest, options?: TransportRequestOptions): Promise<T.MlEstimateModelMemoryResponse>
  async estimateModelMemory (this: That, params?: T.MlEstimateModelMemoryRequest | TB.MlEstimateModelMemoryRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = []
    const acceptedQuery: string[] = ['error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params?.body ?? undefined

    params = params ?? {}
    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'POST'
    const path = '/_ml/anomaly_detectors/_estimate_model_memory'
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async evaluateDataFrame (this: That, params: T.MlEvaluateDataFrameRequest | TB.MlEvaluateDataFrameRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlEvaluateDataFrameResponse>
  async evaluateDataFrame (this: That, params: T.MlEvaluateDataFrameRequest | TB.MlEvaluateDataFrameRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlEvaluateDataFrameResponse, unknown>>
  async evaluateDataFrame (this: That, params: T.MlEvaluateDataFrameRequest | TB.MlEvaluateDataFrameRequest, options?: TransportRequestOptions): Promise<T.MlEvaluateDataFrameResponse>
  async evaluateDataFrame (this: That, params: T.MlEvaluateDataFrameRequest | TB.MlEvaluateDataFrameRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = []
    const acceptedQuery: string[] = ['error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'POST'
    const path = '/_ml/data_frame/_evaluate'
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async explainDataFrameAnalytics (this: That, params: T.MlExplainDataFrameAnalyticsRequest | TB.MlExplainDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlExplainDataFrameAnalyticsResponse>
  async explainDataFrameAnalytics (this: That, params: T.MlExplainDataFrameAnalyticsRequest | TB.MlExplainDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlExplainDataFrameAnalyticsResponse, unknown>>
  async explainDataFrameAnalytics (this: That, params: T.MlExplainDataFrameAnalyticsRequest | TB.MlExplainDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<T.MlExplainDataFrameAnalyticsResponse>
  async explainDataFrameAnalytics (this: That, params: T.MlExplainDataFrameAnalyticsRequest | TB.MlExplainDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['id']
    const acceptedQuery: string[] = ['error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    let method = ''
    let path = ''
    if (params.id != null) {
      method = body != null ? 'POST' : 'GET'
      path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}/_explain`
    } else {
      method = body != null ? 'POST' : 'GET'
      path = '/_ml/data_frame/analytics/_explain'
    }
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async flushJob (this: That, params: T.MlFlushJobRequest | TB.MlFlushJobRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlFlushJobResponse>
  async flushJob (this: That, params: T.MlFlushJobRequest | TB.MlFlushJobRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlFlushJobResponse, unknown>>
  async flushJob (this: That, params: T.MlFlushJobRequest | TB.MlFlushJobRequest, options?: TransportRequestOptions): Promise<T.MlFlushJobResponse>
  async flushJob (this: That, params: T.MlFlushJobRequest | TB.MlFlushJobRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['job_id']
    const acceptedQuery: string[] = ['skip_time', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'POST'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_flush`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async forecast (this: That, params: T.MlForecastRequest | TB.MlForecastRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlForecastResponse>
  async forecast (this: That, params: T.MlForecastRequest | TB.MlForecastRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlForecastResponse, unknown>>
  async forecast (this: That, params: T.MlForecastRequest | TB.MlForecastRequest, options?: TransportRequestOptions): Promise<T.MlForecastResponse>
  async forecast (this: That, params: T.MlForecastRequest | TB.MlForecastRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['job_id']
    const acceptedQuery: string[] = ['error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'POST'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_forecast`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async getBuckets (this: That, params: T.MlGetBucketsRequest | TB.MlGetBucketsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetBucketsResponse>
  async getBuckets (this: That, params: T.MlGetBucketsRequest | TB.MlGetBucketsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetBucketsResponse, unknown>>
  async getBuckets (this: That, params: T.MlGetBucketsRequest | TB.MlGetBucketsRequest, options?: TransportRequestOptions): Promise<T.MlGetBucketsResponse>
  async getBuckets (this: That, params: T.MlGetBucketsRequest | TB.MlGetBucketsRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['job_id', 'timestamp']
    const acceptedQuery: string[] = ['from', 'size', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    let method = ''
    let path = ''
    if (params.job_id != null && params.timestamp != null) {
      method = body != null ? 'POST' : 'GET'
      path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/buckets/${encodeURIComponent(params.timestamp.toString())}`
    } else {
      method = body != null ? 'POST' : 'GET'
      path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/buckets`
    }
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async getCalendarEvents (this: That, params: T.MlGetCalendarEventsRequest | TB.MlGetCalendarEventsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetCalendarEventsResponse>
  async getCalendarEvents (this: That, params: T.MlGetCalendarEventsRequest | TB.MlGetCalendarEventsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetCalendarEventsResponse, unknown>>
  async getCalendarEvents (this: That, params: T.MlGetCalendarEventsRequest | TB.MlGetCalendarEventsRequest, options?: TransportRequestOptions): Promise<T.MlGetCalendarEventsResponse>
  async getCalendarEvents (this: That, params: T.MlGetCalendarEventsRequest | TB.MlGetCalendarEventsRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['calendar_id']
    const acceptedQuery: string[] = ['job_id', 'end', 'from', 'start', 'size', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'GET'
    const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}/events`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async getCalendars (this: That, params?: T.MlGetCalendarsRequest | TB.MlGetCalendarsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetCalendarsResponse>
  async getCalendars (this: That, params?: T.MlGetCalendarsRequest | TB.MlGetCalendarsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetCalendarsResponse, unknown>>
  async getCalendars (this: That, params?: T.MlGetCalendarsRequest | TB.MlGetCalendarsRequest, options?: TransportRequestOptions): Promise<T.MlGetCalendarsResponse>
  async getCalendars (this: That, params?: T.MlGetCalendarsRequest | TB.MlGetCalendarsRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['calendar_id']
    const acceptedQuery: string[] = ['from', 'size', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params?.body ?? undefined

    params = params ?? {}
    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    let method = ''
    let path = ''
    if (params.calendar_id != null) {
      method = body != null ? 'POST' : 'GET'
      path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}`
    } else {
      method = body != null ? 'POST' : 'GET'
      path = '/_ml/calendars'
    }
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async getCategories (this: That, params: T.MlGetCategoriesRequest | TB.MlGetCategoriesRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetCategoriesResponse>
  async getCategories (this: That, params: T.MlGetCategoriesRequest | TB.MlGetCategoriesRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetCategoriesResponse, unknown>>
  async getCategories (this: That, params: T.MlGetCategoriesRequest | TB.MlGetCategoriesRequest, options?: TransportRequestOptions): Promise<T.MlGetCategoriesResponse>
  async getCategories (this: That, params: T.MlGetCategoriesRequest | TB.MlGetCategoriesRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['job_id', 'category_id']
    const acceptedQuery: string[] = ['from', 'size', 'partition_field_value', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    let method = ''
    let path = ''
    if (params.job_id != null && params.category_id != null) {
      method = body != null ? 'POST' : 'GET'
      path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/categories/${encodeURIComponent(params.category_id.toString())}`
    } else {
      method = body != null ? 'POST' : 'GET'
      path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/categories/`
    }
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async getDataFrameAnalytics (this: That, params?: T.MlGetDataFrameAnalyticsRequest | TB.MlGetDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetDataFrameAnalyticsResponse>
  async getDataFrameAnalytics (this: That, params?: T.MlGetDataFrameAnalyticsRequest | TB.MlGetDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetDataFrameAnalyticsResponse, unknown>>
  async getDataFrameAnalytics (this: That, params?: T.MlGetDataFrameAnalyticsRequest | TB.MlGetDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<T.MlGetDataFrameAnalyticsResponse>
  async getDataFrameAnalytics (this: That, params?: T.MlGetDataFrameAnalyticsRequest | TB.MlGetDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['id']
    const acceptedQuery: string[] = ['allow_no_match', 'from', 'size', 'exclude_generated', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params?.body ?? undefined

    params = params ?? {}
    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    let method = ''
    let path = ''
    if (params.id != null) {
      method = 'GET'
      path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}`
    } else {
      method = 'GET'
      path = '/_ml/data_frame/analytics'
    }
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async getDataFrameAnalyticsStats (this: That, params?: T.MlGetDataFrameAnalyticsStatsRequest | TB.MlGetDataFrameAnalyticsStatsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetDataFrameAnalyticsStatsResponse>
  async getDataFrameAnalyticsStats (this: That, params?: T.MlGetDataFrameAnalyticsStatsRequest | TB.MlGetDataFrameAnalyticsStatsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetDataFrameAnalyticsStatsResponse, unknown>>
  async getDataFrameAnalyticsStats (this: That, params?: T.MlGetDataFrameAnalyticsStatsRequest | TB.MlGetDataFrameAnalyticsStatsRequest, options?: TransportRequestOptions): Promise<T.MlGetDataFrameAnalyticsStatsResponse>
  async getDataFrameAnalyticsStats (this: That, params?: T.MlGetDataFrameAnalyticsStatsRequest | TB.MlGetDataFrameAnalyticsStatsRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['id']
    const acceptedQuery: string[] = ['allow_no_match', 'from', 'size', 'verbose', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params?.body ?? undefined

    params = params ?? {}
    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    let method = ''
    let path = ''
    if (params.id != null) {
      method = 'GET'
      path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}/_stats`
    } else {
      method = 'GET'
      path = '/_ml/data_frame/analytics/_stats'
    }
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async getDatafeedStats (this: That, params?: T.MlGetDatafeedStatsRequest | TB.MlGetDatafeedStatsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetDatafeedStatsResponse>
  async getDatafeedStats (this: That, params?: T.MlGetDatafeedStatsRequest | TB.MlGetDatafeedStatsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetDatafeedStatsResponse, unknown>>
  async getDatafeedStats (this: That, params?: T.MlGetDatafeedStatsRequest | TB.MlGetDatafeedStatsRequest, options?: TransportRequestOptions): Promise<T.MlGetDatafeedStatsResponse>
  async getDatafeedStats (this: That, params?: T.MlGetDatafeedStatsRequest | TB.MlGetDatafeedStatsRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['datafeed_id']
    const acceptedQuery: string[] = ['allow_no_datafeeds', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params?.body ?? undefined

    params = params ?? {}
    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    let method = ''
    let path = ''
    if (params.datafeed_id != null) {
      method = 'GET'
      path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}/_stats`
    } else {
      method = 'GET'
      path = '/_ml/datafeeds/_stats'
    }
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async getDatafeeds (this: That, params?: T.MlGetDatafeedsRequest | TB.MlGetDatafeedsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetDatafeedsResponse>
  async getDatafeeds (this: That, params?: T.MlGetDatafeedsRequest | TB.MlGetDatafeedsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetDatafeedsResponse, unknown>>
  async getDatafeeds (this: That, params?: T.MlGetDatafeedsRequest | TB.MlGetDatafeedsRequest, options?: TransportRequestOptions): Promise<T.MlGetDatafeedsResponse>
  async getDatafeeds (this: That, params?: T.MlGetDatafeedsRequest | TB.MlGetDatafeedsRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['datafeed_id']
    const acceptedQuery: string[] = ['allow_no_datafeeds', 'exclude_generated', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params?.body ?? undefined

    params = params ?? {}
    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    let method = ''
    let path = ''
    if (params.datafeed_id != null) {
      method = 'GET'
      path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}`
    } else {
      method = 'GET'
      path = '/_ml/datafeeds'
    }
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async getFilters (this: That, params?: T.MlGetFiltersRequest | TB.MlGetFiltersRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetFiltersResponse>
  async getFilters (this: That, params?: T.MlGetFiltersRequest | TB.MlGetFiltersRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetFiltersResponse, unknown>>
  async getFilters (this: That, params?: T.MlGetFiltersRequest | TB.MlGetFiltersRequest, options?: TransportRequestOptions): Promise<T.MlGetFiltersResponse>
  async getFilters (this: That, params?: T.MlGetFiltersRequest | TB.MlGetFiltersRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['filter_id']
    const acceptedQuery: string[] = ['from', 'size', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params?.body ?? undefined

    params = params ?? {}
    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    let method = ''
    let path = ''
    if (params.filter_id != null) {
      method = 'GET'
      path = `/_ml/filters/${encodeURIComponent(params.filter_id.toString())}`
    } else {
      method = 'GET'
      path = '/_ml/filters'
    }
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async getInfluencers (this: That, params: T.MlGetInfluencersRequest | TB.MlGetInfluencersRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetInfluencersResponse>
  async getInfluencers (this: That, params: T.MlGetInfluencersRequest | TB.MlGetInfluencersRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetInfluencersResponse, unknown>>
  async getInfluencers (this: That, params: T.MlGetInfluencersRequest | TB.MlGetInfluencersRequest, options?: TransportRequestOptions): Promise<T.MlGetInfluencersResponse>
  async getInfluencers (this: That, params: T.MlGetInfluencersRequest | TB.MlGetInfluencersRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['job_id']
    const acceptedQuery: string[] = ['desc', 'end', 'exclude_interim', 'influencer_score', 'from', 'size', 'sort', 'start', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = body != null ? 'POST' : 'GET'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/influencers`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async getJobStats (this: That, params?: T.MlGetJobStatsRequest | TB.MlGetJobStatsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetJobStatsResponse>
  async getJobStats (this: That, params?: T.MlGetJobStatsRequest | TB.MlGetJobStatsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetJobStatsResponse, unknown>>
  async getJobStats (this: That, params?: T.MlGetJobStatsRequest | TB.MlGetJobStatsRequest, options?: TransportRequestOptions): Promise<T.MlGetJobStatsResponse>
  async getJobStats (this: That, params?: T.MlGetJobStatsRequest | TB.MlGetJobStatsRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['job_id']
    const acceptedQuery: string[] = ['allow_no_jobs', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params?.body ?? undefined

    params = params ?? {}
    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    let method = ''
    let path = ''
    if (params.job_id != null) {
      method = 'GET'
      path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_stats`
    } else {
      method = 'GET'
      path = '/_ml/anomaly_detectors/_stats'
    }
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async getJobs (this: That, params?: T.MlGetJobsRequest | TB.MlGetJobsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetJobsResponse>
  async getJobs (this: That, params?: T.MlGetJobsRequest | TB.MlGetJobsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetJobsResponse, unknown>>
  async getJobs (this: That, params?: T.MlGetJobsRequest | TB.MlGetJobsRequest, options?: TransportRequestOptions): Promise<T.MlGetJobsResponse>
  async getJobs (this: That, params?: T.MlGetJobsRequest | TB.MlGetJobsRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['job_id']
    const acceptedQuery: string[] = ['allow_no_match', 'allow_no_jobs', 'exclude_generated', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params?.body ?? undefined

    params = params ?? {}
    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    let method = ''
    let path = ''
    if (params.job_id != null) {
      method = 'GET'
      path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}`
    } else {
      method = 'GET'
      path = '/_ml/anomaly_detectors'
    }
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async getModelSnapshots (this: That, params: T.MlGetModelSnapshotsRequest | TB.MlGetModelSnapshotsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetModelSnapshotsResponse>
  async getModelSnapshots (this: That, params: T.MlGetModelSnapshotsRequest | TB.MlGetModelSnapshotsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetModelSnapshotsResponse, unknown>>
  async getModelSnapshots (this: That, params: T.MlGetModelSnapshotsRequest | TB.MlGetModelSnapshotsRequest, options?: TransportRequestOptions): Promise<T.MlGetModelSnapshotsResponse>
  async getModelSnapshots (this: That, params: T.MlGetModelSnapshotsRequest | TB.MlGetModelSnapshotsRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['job_id', 'snapshot_id']
    const acceptedQuery: string[] = ['desc', 'from', 'size', 'sort', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    let method = ''
    let path = ''
    if (params.job_id != null && params.snapshot_id != null) {
      method = body != null ? 'POST' : 'GET'
      path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots/${encodeURIComponent(params.snapshot_id.toString())}`
    } else {
      method = body != null ? 'POST' : 'GET'
      path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots`
    }
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async getOverallBuckets (this: That, params: T.MlGetOverallBucketsRequest | TB.MlGetOverallBucketsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetOverallBucketsResponse>
  async getOverallBuckets (this: That, params: T.MlGetOverallBucketsRequest | TB.MlGetOverallBucketsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetOverallBucketsResponse, unknown>>
  async getOverallBuckets (this: That, params: T.MlGetOverallBucketsRequest | TB.MlGetOverallBucketsRequest, options?: TransportRequestOptions): Promise<T.MlGetOverallBucketsResponse>
  async getOverallBuckets (this: That, params: T.MlGetOverallBucketsRequest | TB.MlGetOverallBucketsRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['job_id']
    const acceptedQuery: string[] = ['bucket_span', 'overall_score', 'top_n', 'end', 'start', 'exclude_interim', 'allow_no_match', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = body != null ? 'POST' : 'GET'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/overall_buckets`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async getRecords (this: That, params: T.MlGetRecordsRequest | TB.MlGetRecordsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetRecordsResponse>
  async getRecords (this: That, params: T.MlGetRecordsRequest | TB.MlGetRecordsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetRecordsResponse, unknown>>
  async getRecords (this: That, params: T.MlGetRecordsRequest | TB.MlGetRecordsRequest, options?: TransportRequestOptions): Promise<T.MlGetRecordsResponse>
  async getRecords (this: That, params: T.MlGetRecordsRequest | TB.MlGetRecordsRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['job_id']
    const acceptedQuery: string[] = ['from', 'size', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = body != null ? 'POST' : 'GET'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/records`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async getTrainedModelDeploymentStats (this: That, params?: T.TODO | TB.TODO, options?: TransportRequestOptionsWithOutMeta): Promise<T.TODO>
  async getTrainedModelDeploymentStats (this: That, params?: T.TODO | TB.TODO, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.TODO, unknown>>
  async getTrainedModelDeploymentStats (this: That, params?: T.TODO | TB.TODO, options?: TransportRequestOptions): Promise<T.TODO>
  async getTrainedModelDeploymentStats (this: That, params?: T.TODO | TB.TODO, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['model_id']
    const acceptedQuery: string[] = []
    const querystring: Record<string, any> = {}
    let body: Record<string, any> = params?.body ?? undefined

    params = params ?? {}
    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        body[key] = params[key]
      }
    }

    const method = 'GET'
    const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/deployment/_stats`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async getTrainedModels (this: That, params?: T.MlGetTrainedModelsRequest | TB.MlGetTrainedModelsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetTrainedModelsResponse>
  async getTrainedModels (this: That, params?: T.MlGetTrainedModelsRequest | TB.MlGetTrainedModelsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetTrainedModelsResponse, unknown>>
  async getTrainedModels (this: That, params?: T.MlGetTrainedModelsRequest | TB.MlGetTrainedModelsRequest, options?: TransportRequestOptions): Promise<T.MlGetTrainedModelsResponse>
  async getTrainedModels (this: That, params?: T.MlGetTrainedModelsRequest | TB.MlGetTrainedModelsRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['model_id']
    const acceptedQuery: string[] = ['allow_no_match', 'decompress_definition', 'exclude_generated', 'from', 'include', 'size', 'tags', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params?.body ?? undefined

    params = params ?? {}
    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    let method = ''
    let path = ''
    if (params.model_id != null) {
      method = 'GET'
      path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}`
    } else {
      method = 'GET'
      path = '/_ml/trained_models'
    }
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async getTrainedModelsStats (this: That, params?: T.MlGetTrainedModelsStatsRequest | TB.MlGetTrainedModelsStatsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetTrainedModelsStatsResponse>
  async getTrainedModelsStats (this: That, params?: T.MlGetTrainedModelsStatsRequest | TB.MlGetTrainedModelsStatsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetTrainedModelsStatsResponse, unknown>>
  async getTrainedModelsStats (this: That, params?: T.MlGetTrainedModelsStatsRequest | TB.MlGetTrainedModelsStatsRequest, options?: TransportRequestOptions): Promise<T.MlGetTrainedModelsStatsResponse>
  async getTrainedModelsStats (this: That, params?: T.MlGetTrainedModelsStatsRequest | TB.MlGetTrainedModelsStatsRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['model_id']
    const acceptedQuery: string[] = ['allow_no_match', 'from', 'size', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params?.body ?? undefined

    params = params ?? {}
    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    let method = ''
    let path = ''
    if (params.model_id != null) {
      method = 'GET'
      path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/_stats`
    } else {
      method = 'GET'
      path = '/_ml/trained_models/_stats'
    }
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async inferTrainedModelDeployment (this: That, params?: T.TODO | TB.TODO, options?: TransportRequestOptionsWithOutMeta): Promise<T.TODO>
  async inferTrainedModelDeployment (this: That, params?: T.TODO | TB.TODO, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.TODO, unknown>>
  async inferTrainedModelDeployment (this: That, params?: T.TODO | TB.TODO, options?: TransportRequestOptions): Promise<T.TODO>
  async inferTrainedModelDeployment (this: That, params?: T.TODO | TB.TODO, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['model_id']
    const acceptedQuery: string[] = ['timeout']
    const querystring: Record<string, any> = {}
    let body: Record<string, any> = params?.body ?? undefined

    params = params ?? {}
    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        body[key] = params[key]
      }
    }

    const method = 'POST'
    const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/deployment/_infer`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async info (this: That, params?: T.MlInfoRequest | TB.MlInfoRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlInfoResponse>
  async info (this: That, params?: T.MlInfoRequest | TB.MlInfoRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlInfoResponse, unknown>>
  async info (this: That, params?: T.MlInfoRequest | TB.MlInfoRequest, options?: TransportRequestOptions): Promise<T.MlInfoResponse>
  async info (this: That, params?: T.MlInfoRequest | TB.MlInfoRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = []
    const acceptedQuery: string[] = ['error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params?.body ?? undefined

    params = params ?? {}
    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'GET'
    const path = '/_ml/info'
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async openJob (this: That, params: T.MlOpenJobRequest | TB.MlOpenJobRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlOpenJobResponse>
  async openJob (this: That, params: T.MlOpenJobRequest | TB.MlOpenJobRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlOpenJobResponse, unknown>>
  async openJob (this: That, params: T.MlOpenJobRequest | TB.MlOpenJobRequest, options?: TransportRequestOptions): Promise<T.MlOpenJobResponse>
  async openJob (this: That, params: T.MlOpenJobRequest | TB.MlOpenJobRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['job_id']
    const acceptedQuery: string[] = ['error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'POST'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_open`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async postCalendarEvents (this: That, params: T.MlPostCalendarEventsRequest | TB.MlPostCalendarEventsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlPostCalendarEventsResponse>
  async postCalendarEvents (this: That, params: T.MlPostCalendarEventsRequest | TB.MlPostCalendarEventsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlPostCalendarEventsResponse, unknown>>
  async postCalendarEvents (this: That, params: T.MlPostCalendarEventsRequest | TB.MlPostCalendarEventsRequest, options?: TransportRequestOptions): Promise<T.MlPostCalendarEventsResponse>
  async postCalendarEvents (this: That, params: T.MlPostCalendarEventsRequest | TB.MlPostCalendarEventsRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['calendar_id']
    const acceptedQuery: string[] = ['error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'POST'
    const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}/events`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async postData<TData = unknown> (this: That, params: T.MlPostDataRequest<TData> | TB.MlPostDataRequest<TData>, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlPostDataResponse>
  async postData<TData = unknown> (this: That, params: T.MlPostDataRequest<TData> | TB.MlPostDataRequest<TData>, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlPostDataResponse, unknown>>
  async postData<TData = unknown> (this: That, params: T.MlPostDataRequest<TData> | TB.MlPostDataRequest<TData>, options?: TransportRequestOptions): Promise<T.MlPostDataResponse>
  async postData<TData = unknown> (this: That, params: T.MlPostDataRequest<TData> | TB.MlPostDataRequest<TData>, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['job_id']
    const acceptedQuery: string[] = ['reset_end', 'reset_start', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: any = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'POST'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_data`
    return await this.transport.request({ path, method, querystring, bulkBody: body }, options)
  }

  async previewDataFrameAnalytics (this: That, params?: T.MlPreviewDataFrameAnalyticsRequest | TB.MlPreviewDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlPreviewDataFrameAnalyticsResponse>
  async previewDataFrameAnalytics (this: That, params?: T.MlPreviewDataFrameAnalyticsRequest | TB.MlPreviewDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlPreviewDataFrameAnalyticsResponse, unknown>>
  async previewDataFrameAnalytics (this: That, params?: T.MlPreviewDataFrameAnalyticsRequest | TB.MlPreviewDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<T.MlPreviewDataFrameAnalyticsResponse>
  async previewDataFrameAnalytics (this: That, params?: T.MlPreviewDataFrameAnalyticsRequest | TB.MlPreviewDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['id']
    const acceptedQuery: string[] = ['error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params?.body ?? undefined

    params = params ?? {}
    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    let method = ''
    let path = ''
    if (params.id != null) {
      method = body != null ? 'POST' : 'GET'
      path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}/_preview`
    } else {
      method = body != null ? 'POST' : 'GET'
      path = '/_ml/data_frame/analytics/_preview'
    }
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async previewDatafeed<TDocument = unknown> (this: That, params?: T.MlPreviewDatafeedRequest | TB.MlPreviewDatafeedRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlPreviewDatafeedResponse<TDocument>>
  async previewDatafeed<TDocument = unknown> (this: That, params?: T.MlPreviewDatafeedRequest | TB.MlPreviewDatafeedRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlPreviewDatafeedResponse<TDocument>, unknown>>
  async previewDatafeed<TDocument = unknown> (this: That, params?: T.MlPreviewDatafeedRequest | TB.MlPreviewDatafeedRequest, options?: TransportRequestOptions): Promise<T.MlPreviewDatafeedResponse<TDocument>>
  async previewDatafeed<TDocument = unknown> (this: That, params?: T.MlPreviewDatafeedRequest | TB.MlPreviewDatafeedRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['datafeed_id']
    const acceptedQuery: string[] = ['error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params?.body ?? undefined

    params = params ?? {}
    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    let method = ''
    let path = ''
    if (params.datafeed_id != null) {
      method = body != null ? 'POST' : 'GET'
      path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}/_preview`
    } else {
      method = body != null ? 'POST' : 'GET'
      path = '/_ml/datafeeds/_preview'
    }
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async putCalendar (this: That, params: T.MlPutCalendarRequest | TB.MlPutCalendarRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlPutCalendarResponse>
  async putCalendar (this: That, params: T.MlPutCalendarRequest | TB.MlPutCalendarRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlPutCalendarResponse, unknown>>
  async putCalendar (this: That, params: T.MlPutCalendarRequest | TB.MlPutCalendarRequest, options?: TransportRequestOptions): Promise<T.MlPutCalendarResponse>
  async putCalendar (this: That, params: T.MlPutCalendarRequest | TB.MlPutCalendarRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['calendar_id']
    const acceptedQuery: string[] = ['error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'PUT'
    const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async putCalendarJob (this: That, params: T.MlPutCalendarJobRequest | TB.MlPutCalendarJobRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlPutCalendarJobResponse>
  async putCalendarJob (this: That, params: T.MlPutCalendarJobRequest | TB.MlPutCalendarJobRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlPutCalendarJobResponse, unknown>>
  async putCalendarJob (this: That, params: T.MlPutCalendarJobRequest | TB.MlPutCalendarJobRequest, options?: TransportRequestOptions): Promise<T.MlPutCalendarJobResponse>
  async putCalendarJob (this: That, params: T.MlPutCalendarJobRequest | TB.MlPutCalendarJobRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['calendar_id', 'job_id']
    const acceptedQuery: string[] = ['error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'PUT'
    const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}/jobs/${encodeURIComponent(params.job_id.toString())}`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async putDataFrameAnalytics (this: That, params: T.MlPutDataFrameAnalyticsRequest | TB.MlPutDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlPutDataFrameAnalyticsResponse>
  async putDataFrameAnalytics (this: That, params: T.MlPutDataFrameAnalyticsRequest | TB.MlPutDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlPutDataFrameAnalyticsResponse, unknown>>
  async putDataFrameAnalytics (this: That, params: T.MlPutDataFrameAnalyticsRequest | TB.MlPutDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<T.MlPutDataFrameAnalyticsResponse>
  async putDataFrameAnalytics (this: That, params: T.MlPutDataFrameAnalyticsRequest | TB.MlPutDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['id']
    const acceptedQuery: string[] = ['error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'PUT'
    const path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async putDatafeed (this: That, params: T.MlPutDatafeedRequest | TB.MlPutDatafeedRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlPutDatafeedResponse>
  async putDatafeed (this: That, params: T.MlPutDatafeedRequest | TB.MlPutDatafeedRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlPutDatafeedResponse, unknown>>
  async putDatafeed (this: That, params: T.MlPutDatafeedRequest | TB.MlPutDatafeedRequest, options?: TransportRequestOptions): Promise<T.MlPutDatafeedResponse>
  async putDatafeed (this: That, params: T.MlPutDatafeedRequest | TB.MlPutDatafeedRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['datafeed_id']
    const acceptedQuery: string[] = ['allow_no_indices', 'expand_wildcards', 'ignore_throttled', 'ignore_unavailable', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'PUT'
    const path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async putFilter (this: That, params: T.MlPutFilterRequest | TB.MlPutFilterRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlPutFilterResponse>
  async putFilter (this: That, params: T.MlPutFilterRequest | TB.MlPutFilterRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlPutFilterResponse, unknown>>
  async putFilter (this: That, params: T.MlPutFilterRequest | TB.MlPutFilterRequest, options?: TransportRequestOptions): Promise<T.MlPutFilterResponse>
  async putFilter (this: That, params: T.MlPutFilterRequest | TB.MlPutFilterRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['filter_id']
    const acceptedQuery: string[] = ['error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'PUT'
    const path = `/_ml/filters/${encodeURIComponent(params.filter_id.toString())}`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async putJob (this: That, params: T.MlPutJobRequest | TB.MlPutJobRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlPutJobResponse>
  async putJob (this: That, params: T.MlPutJobRequest | TB.MlPutJobRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlPutJobResponse, unknown>>
  async putJob (this: That, params: T.MlPutJobRequest | TB.MlPutJobRequest, options?: TransportRequestOptions): Promise<T.MlPutJobResponse>
  async putJob (this: That, params: T.MlPutJobRequest | TB.MlPutJobRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['job_id']
    const acceptedQuery: string[] = ['error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'PUT'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async putTrainedModel (this: That, params: T.MlPutTrainedModelRequest | TB.MlPutTrainedModelRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlPutTrainedModelResponse>
  async putTrainedModel (this: That, params: T.MlPutTrainedModelRequest | TB.MlPutTrainedModelRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlPutTrainedModelResponse, unknown>>
  async putTrainedModel (this: That, params: T.MlPutTrainedModelRequest | TB.MlPutTrainedModelRequest, options?: TransportRequestOptions): Promise<T.MlPutTrainedModelResponse>
  async putTrainedModel (this: That, params: T.MlPutTrainedModelRequest | TB.MlPutTrainedModelRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['model_id']
    const acceptedQuery: string[] = ['error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'PUT'
    const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async putTrainedModelAlias (this: That, params: T.MlPutTrainedModelAliasRequest | TB.MlPutTrainedModelAliasRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlPutTrainedModelAliasResponse>
  async putTrainedModelAlias (this: That, params: T.MlPutTrainedModelAliasRequest | TB.MlPutTrainedModelAliasRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlPutTrainedModelAliasResponse, unknown>>
  async putTrainedModelAlias (this: That, params: T.MlPutTrainedModelAliasRequest | TB.MlPutTrainedModelAliasRequest, options?: TransportRequestOptions): Promise<T.MlPutTrainedModelAliasResponse>
  async putTrainedModelAlias (this: That, params: T.MlPutTrainedModelAliasRequest | TB.MlPutTrainedModelAliasRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['model_alias', 'model_id']
    const acceptedQuery: string[] = ['reassign', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'PUT'
    const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/model_aliases/${encodeURIComponent(params.model_alias.toString())}`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async putTrainedModelDefinitionPart (this: That, params?: T.TODO | TB.TODO, options?: TransportRequestOptionsWithOutMeta): Promise<T.TODO>
  async putTrainedModelDefinitionPart (this: That, params?: T.TODO | TB.TODO, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.TODO, unknown>>
  async putTrainedModelDefinitionPart (this: That, params?: T.TODO | TB.TODO, options?: TransportRequestOptions): Promise<T.TODO>
  async putTrainedModelDefinitionPart (this: That, params?: T.TODO | TB.TODO, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['model_id', 'part']
    const acceptedQuery: string[] = []
    const querystring: Record<string, any> = {}
    let body: Record<string, any> = params?.body ?? undefined

    params = params ?? {}
    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        body[key] = params[key]
      }
    }

    const method = 'PUT'
    const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/definition/${encodeURIComponent(params.part.toString())}`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async putTrainedModelVocabulary (this: That, params?: T.TODO | TB.TODO, options?: TransportRequestOptionsWithOutMeta): Promise<T.TODO>
  async putTrainedModelVocabulary (this: That, params?: T.TODO | TB.TODO, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.TODO, unknown>>
  async putTrainedModelVocabulary (this: That, params?: T.TODO | TB.TODO, options?: TransportRequestOptions): Promise<T.TODO>
  async putTrainedModelVocabulary (this: That, params?: T.TODO | TB.TODO, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['model_id']
    const acceptedQuery: string[] = []
    const querystring: Record<string, any> = {}
    let body: Record<string, any> = params?.body ?? undefined

    params = params ?? {}
    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        body[key] = params[key]
      }
    }

    const method = 'PUT'
    const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/vocabulary`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async resetJob (this: That, params: T.MlResetJobRequest | TB.MlResetJobRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlResetJobResponse>
  async resetJob (this: That, params: T.MlResetJobRequest | TB.MlResetJobRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlResetJobResponse, unknown>>
  async resetJob (this: That, params: T.MlResetJobRequest | TB.MlResetJobRequest, options?: TransportRequestOptions): Promise<T.MlResetJobResponse>
  async resetJob (this: That, params: T.MlResetJobRequest | TB.MlResetJobRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['job_id']
    const acceptedQuery: string[] = ['wait_for_completion', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'POST'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_reset`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async revertModelSnapshot (this: That, params: T.MlRevertModelSnapshotRequest | TB.MlRevertModelSnapshotRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlRevertModelSnapshotResponse>
  async revertModelSnapshot (this: That, params: T.MlRevertModelSnapshotRequest | TB.MlRevertModelSnapshotRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlRevertModelSnapshotResponse, unknown>>
  async revertModelSnapshot (this: That, params: T.MlRevertModelSnapshotRequest | TB.MlRevertModelSnapshotRequest, options?: TransportRequestOptions): Promise<T.MlRevertModelSnapshotResponse>
  async revertModelSnapshot (this: That, params: T.MlRevertModelSnapshotRequest | TB.MlRevertModelSnapshotRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['job_id', 'snapshot_id']
    const acceptedQuery: string[] = ['error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'POST'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots/${encodeURIComponent(params.snapshot_id.toString())}/_revert`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async setUpgradeMode (this: That, params?: T.MlSetUpgradeModeRequest | TB.MlSetUpgradeModeRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlSetUpgradeModeResponse>
  async setUpgradeMode (this: That, params?: T.MlSetUpgradeModeRequest | TB.MlSetUpgradeModeRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlSetUpgradeModeResponse, unknown>>
  async setUpgradeMode (this: That, params?: T.MlSetUpgradeModeRequest | TB.MlSetUpgradeModeRequest, options?: TransportRequestOptions): Promise<T.MlSetUpgradeModeResponse>
  async setUpgradeMode (this: That, params?: T.MlSetUpgradeModeRequest | TB.MlSetUpgradeModeRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = []
    const acceptedQuery: string[] = ['enabled', 'timeout', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params?.body ?? undefined

    params = params ?? {}
    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'POST'
    const path = '/_ml/set_upgrade_mode'
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async startDataFrameAnalytics (this: That, params: T.MlStartDataFrameAnalyticsRequest | TB.MlStartDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlStartDataFrameAnalyticsResponse>
  async startDataFrameAnalytics (this: That, params: T.MlStartDataFrameAnalyticsRequest | TB.MlStartDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlStartDataFrameAnalyticsResponse, unknown>>
  async startDataFrameAnalytics (this: That, params: T.MlStartDataFrameAnalyticsRequest | TB.MlStartDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<T.MlStartDataFrameAnalyticsResponse>
  async startDataFrameAnalytics (this: That, params: T.MlStartDataFrameAnalyticsRequest | TB.MlStartDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['id']
    const acceptedQuery: string[] = ['timeout', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'POST'
    const path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}/_start`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async startDatafeed (this: That, params: T.MlStartDatafeedRequest | TB.MlStartDatafeedRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlStartDatafeedResponse>
  async startDatafeed (this: That, params: T.MlStartDatafeedRequest | TB.MlStartDatafeedRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlStartDatafeedResponse, unknown>>
  async startDatafeed (this: That, params: T.MlStartDatafeedRequest | TB.MlStartDatafeedRequest, options?: TransportRequestOptions): Promise<T.MlStartDatafeedResponse>
  async startDatafeed (this: That, params: T.MlStartDatafeedRequest | TB.MlStartDatafeedRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['datafeed_id']
    const acceptedQuery: string[] = ['error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'POST'
    const path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}/_start`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async startTrainedModelDeployment (this: That, params?: T.TODO | TB.TODO, options?: TransportRequestOptionsWithOutMeta): Promise<T.TODO>
  async startTrainedModelDeployment (this: That, params?: T.TODO | TB.TODO, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.TODO, unknown>>
  async startTrainedModelDeployment (this: That, params?: T.TODO | TB.TODO, options?: TransportRequestOptions): Promise<T.TODO>
  async startTrainedModelDeployment (this: That, params?: T.TODO | TB.TODO, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['model_id']
    const acceptedQuery: string[] = ['timeout', 'wait_for']
    const querystring: Record<string, any> = {}
    let body: Record<string, any> = params?.body ?? undefined

    params = params ?? {}
    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        body[key] = params[key]
      }
    }

    const method = 'POST'
    const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/deployment/_start`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async stopDataFrameAnalytics (this: That, params: T.MlStopDataFrameAnalyticsRequest | TB.MlStopDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlStopDataFrameAnalyticsResponse>
  async stopDataFrameAnalytics (this: That, params: T.MlStopDataFrameAnalyticsRequest | TB.MlStopDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlStopDataFrameAnalyticsResponse, unknown>>
  async stopDataFrameAnalytics (this: That, params: T.MlStopDataFrameAnalyticsRequest | TB.MlStopDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<T.MlStopDataFrameAnalyticsResponse>
  async stopDataFrameAnalytics (this: That, params: T.MlStopDataFrameAnalyticsRequest | TB.MlStopDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['id']
    const acceptedQuery: string[] = ['allow_no_match', 'force', 'timeout', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'POST'
    const path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}/_stop`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async stopDatafeed (this: That, params: T.MlStopDatafeedRequest | TB.MlStopDatafeedRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlStopDatafeedResponse>
  async stopDatafeed (this: That, params: T.MlStopDatafeedRequest | TB.MlStopDatafeedRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlStopDatafeedResponse, unknown>>
  async stopDatafeed (this: That, params: T.MlStopDatafeedRequest | TB.MlStopDatafeedRequest, options?: TransportRequestOptions): Promise<T.MlStopDatafeedResponse>
  async stopDatafeed (this: That, params: T.MlStopDatafeedRequest | TB.MlStopDatafeedRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['datafeed_id']
    const acceptedQuery: string[] = ['allow_no_match', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'POST'
    const path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}/_stop`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async stopTrainedModelDeployment (this: That, params?: T.TODO | TB.TODO, options?: TransportRequestOptionsWithOutMeta): Promise<T.TODO>
  async stopTrainedModelDeployment (this: That, params?: T.TODO | TB.TODO, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.TODO, unknown>>
  async stopTrainedModelDeployment (this: That, params?: T.TODO | TB.TODO, options?: TransportRequestOptions): Promise<T.TODO>
  async stopTrainedModelDeployment (this: That, params?: T.TODO | TB.TODO, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['model_id']
    const acceptedQuery: string[] = []
    const querystring: Record<string, any> = {}
    let body: Record<string, any> = params?.body ?? undefined

    params = params ?? {}
    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        body[key] = params[key]
      }
    }

    const method = 'POST'
    const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/deployment/_stop`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async updateDataFrameAnalytics (this: That, params: T.MlUpdateDataFrameAnalyticsRequest | TB.MlUpdateDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlUpdateDataFrameAnalyticsResponse>
  async updateDataFrameAnalytics (this: That, params: T.MlUpdateDataFrameAnalyticsRequest | TB.MlUpdateDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlUpdateDataFrameAnalyticsResponse, unknown>>
  async updateDataFrameAnalytics (this: That, params: T.MlUpdateDataFrameAnalyticsRequest | TB.MlUpdateDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<T.MlUpdateDataFrameAnalyticsResponse>
  async updateDataFrameAnalytics (this: That, params: T.MlUpdateDataFrameAnalyticsRequest | TB.MlUpdateDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['id']
    const acceptedQuery: string[] = ['error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'POST'
    const path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}/_update`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async updateDatafeed (this: That, params?: T.TODO | TB.TODO, options?: TransportRequestOptionsWithOutMeta): Promise<T.TODO>
  async updateDatafeed (this: That, params?: T.TODO | TB.TODO, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.TODO, unknown>>
  async updateDatafeed (this: That, params?: T.TODO | TB.TODO, options?: TransportRequestOptions): Promise<T.TODO>
  async updateDatafeed (this: That, params?: T.TODO | TB.TODO, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['datafeed_id']
    const acceptedQuery: string[] = ['ignore_unavailable', 'allow_no_indices', 'ignore_throttled', 'expand_wildcards']
    const querystring: Record<string, any> = {}
    let body: Record<string, any> = params?.body ?? undefined

    params = params ?? {}
    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        body[key] = params[key]
      }
    }

    const method = 'POST'
    const path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}/_update`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async updateFilter (this: That, params: T.MlUpdateFilterRequest | TB.MlUpdateFilterRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlUpdateFilterResponse>
  async updateFilter (this: That, params: T.MlUpdateFilterRequest | TB.MlUpdateFilterRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlUpdateFilterResponse, unknown>>
  async updateFilter (this: That, params: T.MlUpdateFilterRequest | TB.MlUpdateFilterRequest, options?: TransportRequestOptions): Promise<T.MlUpdateFilterResponse>
  async updateFilter (this: That, params: T.MlUpdateFilterRequest | TB.MlUpdateFilterRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['filter_id']
    const acceptedQuery: string[] = ['error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'POST'
    const path = `/_ml/filters/${encodeURIComponent(params.filter_id.toString())}/_update`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async updateJob (this: That, params: T.MlUpdateJobRequest | TB.MlUpdateJobRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlUpdateJobResponse>
  async updateJob (this: That, params: T.MlUpdateJobRequest | TB.MlUpdateJobRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlUpdateJobResponse, unknown>>
  async updateJob (this: That, params: T.MlUpdateJobRequest | TB.MlUpdateJobRequest, options?: TransportRequestOptions): Promise<T.MlUpdateJobResponse>
  async updateJob (this: That, params: T.MlUpdateJobRequest | TB.MlUpdateJobRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['job_id']
    const acceptedQuery: string[] = ['error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'POST'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_update`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async updateModelSnapshot (this: That, params: T.MlUpdateModelSnapshotRequest | TB.MlUpdateModelSnapshotRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlUpdateModelSnapshotResponse>
  async updateModelSnapshot (this: That, params: T.MlUpdateModelSnapshotRequest | TB.MlUpdateModelSnapshotRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlUpdateModelSnapshotResponse, unknown>>
  async updateModelSnapshot (this: That, params: T.MlUpdateModelSnapshotRequest | TB.MlUpdateModelSnapshotRequest, options?: TransportRequestOptions): Promise<T.MlUpdateModelSnapshotResponse>
  async updateModelSnapshot (this: That, params: T.MlUpdateModelSnapshotRequest | TB.MlUpdateModelSnapshotRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['job_id', 'snapshot_id']
    const acceptedQuery: string[] = ['error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'POST'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots/${encodeURIComponent(params.snapshot_id.toString())}/_update`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async upgradeJobSnapshot (this: That, params: T.MlUpgradeJobSnapshotRequest | TB.MlUpgradeJobSnapshotRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlUpgradeJobSnapshotResponse>
  async upgradeJobSnapshot (this: That, params: T.MlUpgradeJobSnapshotRequest | TB.MlUpgradeJobSnapshotRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlUpgradeJobSnapshotResponse, unknown>>
  async upgradeJobSnapshot (this: That, params: T.MlUpgradeJobSnapshotRequest | TB.MlUpgradeJobSnapshotRequest, options?: TransportRequestOptions): Promise<T.MlUpgradeJobSnapshotResponse>
  async upgradeJobSnapshot (this: That, params: T.MlUpgradeJobSnapshotRequest | TB.MlUpgradeJobSnapshotRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = ['job_id', 'snapshot_id']
    const acceptedQuery: string[] = ['wait_for_completion', 'timeout', 'error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'POST'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots/${encodeURIComponent(params.snapshot_id.toString())}/_upgrade`
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async validate (this: That, params?: T.MlValidateRequest | TB.MlValidateRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlValidateResponse>
  async validate (this: That, params?: T.MlValidateRequest | TB.MlValidateRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlValidateResponse, unknown>>
  async validate (this: That, params?: T.MlValidateRequest | TB.MlValidateRequest, options?: TransportRequestOptions): Promise<T.MlValidateResponse>
  async validate (this: That, params?: T.MlValidateRequest | TB.MlValidateRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = []
    const acceptedQuery: string[] = ['error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: Record<string, any> = params?.body ?? undefined

    params = params ?? {}
    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'POST'
    const path = '/_ml/anomaly_detectors/_validate'
    return await this.transport.request({ path, method, querystring, body }, options)
  }

  async validateDetector (this: That, params: T.MlValidateDetectorRequest | TB.MlValidateDetectorRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlValidateDetectorResponse>
  async validateDetector (this: That, params: T.MlValidateDetectorRequest | TB.MlValidateDetectorRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlValidateDetectorResponse, unknown>>
  async validateDetector (this: That, params: T.MlValidateDetectorRequest | TB.MlValidateDetectorRequest, options?: TransportRequestOptions): Promise<T.MlValidateDetectorResponse>
  async validateDetector (this: That, params: T.MlValidateDetectorRequest | TB.MlValidateDetectorRequest, options?: TransportRequestOptions): Promise<any> {
    const acceptedPath: string[] = []
    const acceptedQuery: string[] = ['error_trace', 'filter_path', 'human', 'pretty', 'source_query_string']
    const querystring: Record<string, any> = {}
    // @ts-expect-error
    let body: any = params.body ?? undefined

    for (const key in params) {
      if (acceptedQuery.includes(key)) {
        // @ts-expect-error
        querystring[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body') {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      }
    }

    const method = 'POST'
    const path = '/_ml/anomaly_detectors/_validate/detector'
    return await this.transport.request({ path, method, querystring, body }, options)
  }
}
