/*
 * Copyright Elasticsearch B.V. and contributors
 * SPDX-License-Identifier: Apache-2.0
 */

/* eslint-disable import/export */
/* eslint-disable @typescript-eslint/no-misused-new */
/* eslint-disable @typescript-eslint/no-extraneous-class */
/* eslint-disable @typescript-eslint/no-unused-vars */

// This file was automatically generated by elastic/elastic-client-generator-js
// DO NOT MODIFY IT BY HAND. Instead, modify the source open api file,
// and elastic/elastic-client-generator-js to regenerate this file again.

import {
  Transport,
  TransportRequestMetadata,
  TransportRequestOptions,
  TransportRequestOptionsWithMeta,
  TransportRequestOptionsWithOutMeta,
  TransportResult
} from '@elastic/transport'
import * as T from '../types'
import { kAcceptedParams } from '../../client'

interface That {
  transport: Transport
  [kAcceptedParams]: Record<string, { path: string[], body: string[], query: string[] }>
}

const commonQueryParams = ['error_trace', 'filter_path', 'human', 'pretty']

export default class Ml {
  transport: Transport
  [kAcceptedParams]: Record<string, { path: string[], body: string[], query: string[] }>
  constructor (transport: Transport) {
    this.transport = transport
    this[kAcceptedParams] = {
      'ml.clear_trained_model_deployment_cache': {
        path: [
          'model_id'
        ],
        body: [],
        query: []
      },
      'ml.close_job': {
        path: [
          'job_id'
        ],
        body: [
          'allow_no_match',
          'force',
          'timeout'
        ],
        query: [
          'allow_no_match',
          'force',
          'timeout'
        ]
      },
      'ml.delete_calendar': {
        path: [
          'calendar_id'
        ],
        body: [],
        query: []
      },
      'ml.delete_calendar_event': {
        path: [
          'calendar_id',
          'event_id'
        ],
        body: [],
        query: []
      },
      'ml.delete_calendar_job': {
        path: [
          'calendar_id',
          'job_id'
        ],
        body: [],
        query: []
      },
      'ml.delete_data_frame_analytics': {
        path: [
          'id'
        ],
        body: [],
        query: [
          'force',
          'timeout'
        ]
      },
      'ml.delete_datafeed': {
        path: [
          'datafeed_id'
        ],
        body: [],
        query: [
          'force'
        ]
      },
      'ml.delete_expired_data': {
        path: [
          'job_id'
        ],
        body: [
          'requests_per_second',
          'timeout'
        ],
        query: [
          'requests_per_second',
          'timeout'
        ]
      },
      'ml.delete_filter': {
        path: [
          'filter_id'
        ],
        body: [],
        query: []
      },
      'ml.delete_forecast': {
        path: [
          'job_id',
          'forecast_id'
        ],
        body: [],
        query: [
          'allow_no_forecasts',
          'timeout'
        ]
      },
      'ml.delete_job': {
        path: [
          'job_id'
        ],
        body: [],
        query: [
          'force',
          'delete_user_annotations',
          'wait_for_completion'
        ]
      },
      'ml.delete_model_snapshot': {
        path: [
          'job_id',
          'snapshot_id'
        ],
        body: [],
        query: []
      },
      'ml.delete_trained_model': {
        path: [
          'model_id'
        ],
        body: [],
        query: [
          'force',
          'timeout'
        ]
      },
      'ml.delete_trained_model_alias': {
        path: [
          'model_alias',
          'model_id'
        ],
        body: [],
        query: []
      },
      'ml.estimate_model_memory': {
        path: [],
        body: [
          'analysis_config',
          'max_bucket_cardinality',
          'overall_cardinality'
        ],
        query: []
      },
      'ml.evaluate_data_frame': {
        path: [],
        body: [
          'evaluation',
          'index',
          'query'
        ],
        query: []
      },
      'ml.explain_data_frame_analytics': {
        path: [
          'id'
        ],
        body: [
          'source',
          'dest',
          'analysis',
          'description',
          'model_memory_limit',
          'max_num_threads',
          'analyzed_fields',
          'allow_lazy_start'
        ],
        query: []
      },
      'ml.flush_job': {
        path: [
          'job_id'
        ],
        body: [
          'advance_time',
          'calc_interim',
          'end',
          'skip_time',
          'start'
        ],
        query: [
          'advance_time',
          'calc_interim',
          'end',
          'skip_time',
          'start'
        ]
      },
      'ml.forecast': {
        path: [
          'job_id'
        ],
        body: [
          'duration',
          'expires_in',
          'max_model_memory'
        ],
        query: [
          'duration',
          'expires_in',
          'max_model_memory'
        ]
      },
      'ml.get_buckets': {
        path: [
          'job_id',
          'timestamp'
        ],
        body: [
          'anomaly_score',
          'desc',
          'end',
          'exclude_interim',
          'expand',
          'page',
          'sort',
          'start'
        ],
        query: [
          'anomaly_score',
          'desc',
          'end',
          'exclude_interim',
          'expand',
          'from',
          'size',
          'sort',
          'start'
        ]
      },
      'ml.get_calendar_events': {
        path: [
          'calendar_id'
        ],
        body: [],
        query: [
          'end',
          'from',
          'job_id',
          'size',
          'start'
        ]
      },
      'ml.get_calendars': {
        path: [
          'calendar_id'
        ],
        body: [
          'page'
        ],
        query: [
          'from',
          'size'
        ]
      },
      'ml.get_categories': {
        path: [
          'job_id',
          'category_id'
        ],
        body: [
          'page'
        ],
        query: [
          'from',
          'partition_field_value',
          'size'
        ]
      },
      'ml.get_data_frame_analytics': {
        path: [
          'id'
        ],
        body: [],
        query: [
          'allow_no_match',
          'from',
          'size',
          'exclude_generated'
        ]
      },
      'ml.get_data_frame_analytics_stats': {
        path: [
          'id'
        ],
        body: [],
        query: [
          'allow_no_match',
          'from',
          'size',
          'verbose'
        ]
      },
      'ml.get_datafeed_stats': {
        path: [
          'datafeed_id'
        ],
        body: [],
        query: [
          'allow_no_match'
        ]
      },
      'ml.get_datafeeds': {
        path: [
          'datafeed_id'
        ],
        body: [],
        query: [
          'allow_no_match',
          'exclude_generated'
        ]
      },
      'ml.get_filters': {
        path: [
          'filter_id'
        ],
        body: [],
        query: [
          'from',
          'size'
        ]
      },
      'ml.get_influencers': {
        path: [
          'job_id'
        ],
        body: [
          'page'
        ],
        query: [
          'desc',
          'end',
          'exclude_interim',
          'influencer_score',
          'from',
          'size',
          'sort',
          'start'
        ]
      },
      'ml.get_job_stats': {
        path: [
          'job_id'
        ],
        body: [],
        query: [
          'allow_no_match'
        ]
      },
      'ml.get_jobs': {
        path: [
          'job_id'
        ],
        body: [],
        query: [
          'allow_no_match',
          'exclude_generated'
        ]
      },
      'ml.get_memory_stats': {
        path: [
          'node_id'
        ],
        body: [],
        query: [
          'master_timeout',
          'timeout'
        ]
      },
      'ml.get_model_snapshot_upgrade_stats': {
        path: [
          'job_id',
          'snapshot_id'
        ],
        body: [],
        query: [
          'allow_no_match'
        ]
      },
      'ml.get_model_snapshots': {
        path: [
          'job_id',
          'snapshot_id'
        ],
        body: [
          'desc',
          'end',
          'page',
          'sort',
          'start'
        ],
        query: [
          'desc',
          'end',
          'from',
          'size',
          'sort',
          'start'
        ]
      },
      'ml.get_overall_buckets': {
        path: [
          'job_id'
        ],
        body: [
          'allow_no_match',
          'bucket_span',
          'end',
          'exclude_interim',
          'overall_score',
          'start',
          'top_n'
        ],
        query: [
          'allow_no_match',
          'bucket_span',
          'end',
          'exclude_interim',
          'overall_score',
          'start',
          'top_n'
        ]
      },
      'ml.get_records': {
        path: [
          'job_id'
        ],
        body: [
          'desc',
          'end',
          'exclude_interim',
          'page',
          'record_score',
          'sort',
          'start'
        ],
        query: [
          'desc',
          'end',
          'exclude_interim',
          'from',
          'record_score',
          'size',
          'sort',
          'start'
        ]
      },
      'ml.get_trained_models': {
        path: [
          'model_id'
        ],
        body: [],
        query: [
          'allow_no_match',
          'decompress_definition',
          'exclude_generated',
          'from',
          'include',
          'size',
          'tags'
        ]
      },
      'ml.get_trained_models_stats': {
        path: [
          'model_id'
        ],
        body: [],
        query: [
          'allow_no_match',
          'from',
          'size'
        ]
      },
      'ml.infer_trained_model': {
        path: [
          'model_id'
        ],
        body: [
          'docs',
          'inference_config'
        ],
        query: [
          'timeout'
        ]
      },
      'ml.info': {
        path: [],
        body: [],
        query: []
      },
      'ml.open_job': {
        path: [
          'job_id'
        ],
        body: [
          'timeout'
        ],
        query: [
          'timeout'
        ]
      },
      'ml.post_calendar_events': {
        path: [
          'calendar_id'
        ],
        body: [
          'events'
        ],
        query: []
      },
      'ml.post_data': {
        path: [
          'job_id'
        ],
        body: [
          'data'
        ],
        query: [
          'reset_end',
          'reset_start'
        ]
      },
      'ml.preview_data_frame_analytics': {
        path: [
          'id'
        ],
        body: [
          'config'
        ],
        query: []
      },
      'ml.preview_datafeed': {
        path: [
          'datafeed_id'
        ],
        body: [
          'datafeed_config',
          'job_config'
        ],
        query: [
          'start',
          'end'
        ]
      },
      'ml.put_calendar': {
        path: [
          'calendar_id'
        ],
        body: [
          'job_ids',
          'description'
        ],
        query: []
      },
      'ml.put_calendar_job': {
        path: [
          'calendar_id',
          'job_id'
        ],
        body: [],
        query: []
      },
      'ml.put_data_frame_analytics': {
        path: [
          'id'
        ],
        body: [
          'allow_lazy_start',
          'analysis',
          'analyzed_fields',
          'description',
          'dest',
          'max_num_threads',
          '_meta',
          'model_memory_limit',
          'source',
          'headers',
          'version'
        ],
        query: []
      },
      'ml.put_datafeed': {
        path: [
          'datafeed_id'
        ],
        body: [
          'aggregations',
          'aggs',
          'chunking_config',
          'delayed_data_check_config',
          'frequency',
          'indices',
          'indexes',
          'indices_options',
          'job_id',
          'max_empty_searches',
          'query',
          'query_delay',
          'runtime_mappings',
          'script_fields',
          'scroll_size',
          'headers'
        ],
        query: [
          'allow_no_indices',
          'expand_wildcards',
          'ignore_throttled',
          'ignore_unavailable'
        ]
      },
      'ml.put_filter': {
        path: [
          'filter_id'
        ],
        body: [
          'description',
          'items'
        ],
        query: []
      },
      'ml.put_job': {
        path: [],
        body: [
          'allow_lazy_open',
          'analysis_config',
          'analysis_limits',
          'background_persist_interval',
          'custom_settings',
          'daily_model_snapshot_retention_after_days',
          'data_description',
          'datafeed_config',
          'description',
          'job_id',
          'groups',
          'model_plot_config',
          'model_snapshot_retention_days',
          'renormalization_window_days',
          'results_index_name',
          'results_retention_days'
        ],
        query: [
          'allow_no_indices',
          'expand_wildcards',
          'ignore_throttled',
          'ignore_unavailable'
        ]
      },
      'ml.put_trained_model': {
        path: [
          'model_id'
        ],
        body: [
          'compressed_definition',
          'definition',
          'description',
          'inference_config',
          'input',
          'metadata',
          'model_type',
          'model_size_bytes',
          'platform_architecture',
          'tags',
          'prefix_strings'
        ],
        query: [
          'defer_definition_decompression',
          'wait_for_completion'
        ]
      },
      'ml.put_trained_model_alias': {
        path: [
          'model_alias',
          'model_id'
        ],
        body: [],
        query: [
          'reassign'
        ]
      },
      'ml.put_trained_model_definition_part': {
        path: [
          'model_id',
          'part'
        ],
        body: [
          'definition',
          'total_definition_length',
          'total_parts'
        ],
        query: []
      },
      'ml.put_trained_model_vocabulary': {
        path: [
          'model_id'
        ],
        body: [
          'vocabulary',
          'merges',
          'scores'
        ],
        query: []
      },
      'ml.reset_job': {
        path: [
          'job_id'
        ],
        body: [],
        query: [
          'wait_for_completion',
          'delete_user_annotations'
        ]
      },
      'ml.revert_model_snapshot': {
        path: [
          'job_id',
          'snapshot_id'
        ],
        body: [
          'delete_intervening_results'
        ],
        query: [
          'delete_intervening_results'
        ]
      },
      'ml.set_upgrade_mode': {
        path: [],
        body: [],
        query: [
          'enabled',
          'timeout'
        ]
      },
      'ml.start_data_frame_analytics': {
        path: [
          'id'
        ],
        body: [],
        query: [
          'timeout'
        ]
      },
      'ml.start_datafeed': {
        path: [
          'datafeed_id'
        ],
        body: [
          'end',
          'start',
          'timeout'
        ],
        query: [
          'end',
          'start',
          'timeout'
        ]
      },
      'ml.start_trained_model_deployment': {
        path: [
          'model_id'
        ],
        body: [
          'adaptive_allocations'
        ],
        query: [
          'cache_size',
          'deployment_id',
          'number_of_allocations',
          'priority',
          'queue_capacity',
          'threads_per_allocation',
          'timeout',
          'wait_for'
        ]
      },
      'ml.stop_data_frame_analytics': {
        path: [
          'id'
        ],
        body: [],
        query: [
          'allow_no_match',
          'force',
          'timeout'
        ]
      },
      'ml.stop_datafeed': {
        path: [
          'datafeed_id'
        ],
        body: [
          'allow_no_match',
          'force',
          'timeout'
        ],
        query: [
          'allow_no_match',
          'force',
          'timeout'
        ]
      },
      'ml.stop_trained_model_deployment': {
        path: [
          'model_id'
        ],
        body: [],
        query: [
          'allow_no_match',
          'force'
        ]
      },
      'ml.update_data_frame_analytics': {
        path: [
          'id'
        ],
        body: [
          'description',
          'model_memory_limit',
          'max_num_threads',
          'allow_lazy_start'
        ],
        query: []
      },
      'ml.update_datafeed': {
        path: [
          'datafeed_id'
        ],
        body: [
          'aggregations',
          'chunking_config',
          'delayed_data_check_config',
          'frequency',
          'indices',
          'indexes',
          'indices_options',
          'job_id',
          'max_empty_searches',
          'query',
          'query_delay',
          'runtime_mappings',
          'script_fields',
          'scroll_size'
        ],
        query: [
          'allow_no_indices',
          'expand_wildcards',
          'ignore_throttled',
          'ignore_unavailable'
        ]
      },
      'ml.update_filter': {
        path: [
          'filter_id'
        ],
        body: [
          'add_items',
          'description',
          'remove_items'
        ],
        query: []
      },
      'ml.update_job': {
        path: [
          'job_id'
        ],
        body: [
          'allow_lazy_open',
          'analysis_limits',
          'background_persist_interval',
          'custom_settings',
          'categorization_filters',
          'description',
          'model_plot_config',
          'model_prune_window',
          'daily_model_snapshot_retention_after_days',
          'model_snapshot_retention_days',
          'renormalization_window_days',
          'results_retention_days',
          'groups',
          'detectors',
          'per_partition_categorization'
        ],
        query: []
      },
      'ml.update_model_snapshot': {
        path: [
          'job_id',
          'snapshot_id'
        ],
        body: [
          'description',
          'retain'
        ],
        query: []
      },
      'ml.update_trained_model_deployment': {
        path: [
          'model_id'
        ],
        body: [
          'number_of_allocations',
          'adaptive_allocations'
        ],
        query: [
          'number_of_allocations'
        ]
      },
      'ml.upgrade_job_snapshot': {
        path: [
          'job_id',
          'snapshot_id'
        ],
        body: [],
        query: [
          'wait_for_completion',
          'timeout'
        ]
      },
      'ml.validate': {
        path: [],
        body: [
          'job_id',
          'analysis_config',
          'analysis_limits',
          'data_description',
          'description',
          'model_plot',
          'model_snapshot_id',
          'model_snapshot_retention_days',
          'results_index_name'
        ],
        query: []
      },
      'ml.validate_detector': {
        path: [],
        body: [
          'detector'
        ],
        query: []
      }
    }
  }

  /**
    * Clear trained model deployment cache. Cache will be cleared on all nodes where the trained model is assigned. A trained model deployment may have an inference cache enabled. As requests are handled by each allocated node, their responses may be cached on that individual node. Calling this API clears the caches without restarting the deployment.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-clear-trained-model-deployment-cache | Elasticsearch API documentation}
    */
  async clearTrainedModelDeploymentCache (this: That, params: T.MlClearTrainedModelDeploymentCacheRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlClearTrainedModelDeploymentCacheResponse>
  async clearTrainedModelDeploymentCache (this: That, params: T.MlClearTrainedModelDeploymentCacheRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlClearTrainedModelDeploymentCacheResponse, unknown>>
  async clearTrainedModelDeploymentCache (this: That, params: T.MlClearTrainedModelDeploymentCacheRequest, options?: TransportRequestOptions): Promise<T.MlClearTrainedModelDeploymentCacheResponse>
  async clearTrainedModelDeploymentCache (this: That, params: T.MlClearTrainedModelDeploymentCacheRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.clear_trained_model_deployment_cache']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    const method = 'POST'
    const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/deployment/cache/_clear`
    const meta: TransportRequestMetadata = {
      name: 'ml.clear_trained_model_deployment_cache',
      pathParts: {
        model_id: params.model_id
      },
      acceptedParams: [
        'model_id'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Close anomaly detection jobs. A job can be opened and closed multiple times throughout its lifecycle. A closed job cannot receive data or perform analysis operations, but you can still explore and navigate results. When you close a job, it runs housekeeping tasks such as pruning the model history, flushing buffers, calculating final results and persisting the model snapshots. Depending upon the size of the job, it could take several minutes to close and the equivalent time to re-open. After it is closed, the job has a minimal overhead on the cluster except for maintaining its meta data. Therefore it is a best practice to close jobs that are no longer required to process data. If you close an anomaly detection job whose datafeed is running, the request first tries to stop the datafeed. This behavior is equivalent to calling stop datafeed API with the same timeout and force parameters as the close job request. When a datafeed that has a specified end date stops, it automatically closes its associated job.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-close-job | Elasticsearch API documentation}
    */
  async closeJob (this: That, params: T.MlCloseJobRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlCloseJobResponse>
  async closeJob (this: That, params: T.MlCloseJobRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlCloseJobResponse, unknown>>
  async closeJob (this: That, params: T.MlCloseJobRequest, options?: TransportRequestOptions): Promise<T.MlCloseJobResponse>
  async closeJob (this: That, params: T.MlCloseJobRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.close_job']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = 'POST'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_close`
    const meta: TransportRequestMetadata = {
      name: 'ml.close_job',
      pathParts: {
        job_id: params.job_id
      },
      acceptedParams: [
        'job_id',
        'allow_no_match',
        'force',
        'timeout',
        'allow_no_match',
        'force',
        'timeout'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Delete a calendar. Remove all scheduled events from a calendar, then delete it.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-delete-calendar | Elasticsearch API documentation}
    */
  async deleteCalendar (this: That, params: T.MlDeleteCalendarRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlDeleteCalendarResponse>
  async deleteCalendar (this: That, params: T.MlDeleteCalendarRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlDeleteCalendarResponse, unknown>>
  async deleteCalendar (this: That, params: T.MlDeleteCalendarRequest, options?: TransportRequestOptions): Promise<T.MlDeleteCalendarResponse>
  async deleteCalendar (this: That, params: T.MlDeleteCalendarRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.delete_calendar']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    const method = 'DELETE'
    const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}`
    const meta: TransportRequestMetadata = {
      name: 'ml.delete_calendar',
      pathParts: {
        calendar_id: params.calendar_id
      },
      acceptedParams: [
        'calendar_id'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Delete events from a calendar.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-delete-calendar-event | Elasticsearch API documentation}
    */
  async deleteCalendarEvent (this: That, params: T.MlDeleteCalendarEventRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlDeleteCalendarEventResponse>
  async deleteCalendarEvent (this: That, params: T.MlDeleteCalendarEventRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlDeleteCalendarEventResponse, unknown>>
  async deleteCalendarEvent (this: That, params: T.MlDeleteCalendarEventRequest, options?: TransportRequestOptions): Promise<T.MlDeleteCalendarEventResponse>
  async deleteCalendarEvent (this: That, params: T.MlDeleteCalendarEventRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.delete_calendar_event']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    const method = 'DELETE'
    const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}/events/${encodeURIComponent(params.event_id.toString())}`
    const meta: TransportRequestMetadata = {
      name: 'ml.delete_calendar_event',
      pathParts: {
        calendar_id: params.calendar_id,
        event_id: params.event_id
      },
      acceptedParams: [
        'calendar_id',
        'event_id'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Delete anomaly jobs from a calendar.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-delete-calendar-job | Elasticsearch API documentation}
    */
  async deleteCalendarJob (this: That, params: T.MlDeleteCalendarJobRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlDeleteCalendarJobResponse>
  async deleteCalendarJob (this: That, params: T.MlDeleteCalendarJobRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlDeleteCalendarJobResponse, unknown>>
  async deleteCalendarJob (this: That, params: T.MlDeleteCalendarJobRequest, options?: TransportRequestOptions): Promise<T.MlDeleteCalendarJobResponse>
  async deleteCalendarJob (this: That, params: T.MlDeleteCalendarJobRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.delete_calendar_job']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    const method = 'DELETE'
    const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}/jobs/${encodeURIComponent(params.job_id.toString())}`
    const meta: TransportRequestMetadata = {
      name: 'ml.delete_calendar_job',
      pathParts: {
        calendar_id: params.calendar_id,
        job_id: params.job_id
      },
      acceptedParams: [
        'calendar_id',
        'job_id'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Delete a data frame analytics job.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-delete-data-frame-analytics | Elasticsearch API documentation}
    */
  async deleteDataFrameAnalytics (this: That, params: T.MlDeleteDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlDeleteDataFrameAnalyticsResponse>
  async deleteDataFrameAnalytics (this: That, params: T.MlDeleteDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlDeleteDataFrameAnalyticsResponse, unknown>>
  async deleteDataFrameAnalytics (this: That, params: T.MlDeleteDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<T.MlDeleteDataFrameAnalyticsResponse>
  async deleteDataFrameAnalytics (this: That, params: T.MlDeleteDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.delete_data_frame_analytics']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    const method = 'DELETE'
    const path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}`
    const meta: TransportRequestMetadata = {
      name: 'ml.delete_data_frame_analytics',
      pathParts: {
        id: params.id
      },
      acceptedParams: [
        'id',
        'force',
        'timeout'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Delete a datafeed.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-delete-datafeed | Elasticsearch API documentation}
    */
  async deleteDatafeed (this: That, params: T.MlDeleteDatafeedRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlDeleteDatafeedResponse>
  async deleteDatafeed (this: That, params: T.MlDeleteDatafeedRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlDeleteDatafeedResponse, unknown>>
  async deleteDatafeed (this: That, params: T.MlDeleteDatafeedRequest, options?: TransportRequestOptions): Promise<T.MlDeleteDatafeedResponse>
  async deleteDatafeed (this: That, params: T.MlDeleteDatafeedRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.delete_datafeed']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    const method = 'DELETE'
    const path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}`
    const meta: TransportRequestMetadata = {
      name: 'ml.delete_datafeed',
      pathParts: {
        datafeed_id: params.datafeed_id
      },
      acceptedParams: [
        'datafeed_id',
        'force'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Delete expired ML data. Delete all job results, model snapshots and forecast data that have exceeded their retention days period. Machine learning state documents that are not associated with any job are also deleted. You can limit the request to a single or set of anomaly detection jobs by using a job identifier, a group name, a comma-separated list of jobs, or a wildcard expression. You can delete expired data for all anomaly detection jobs by using `_all`, by specifying `*` as the `<job_id>`, or by omitting the `<job_id>`.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-delete-expired-data | Elasticsearch API documentation}
    */
  async deleteExpiredData (this: That, params?: T.MlDeleteExpiredDataRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlDeleteExpiredDataResponse>
  async deleteExpiredData (this: That, params?: T.MlDeleteExpiredDataRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlDeleteExpiredDataResponse, unknown>>
  async deleteExpiredData (this: That, params?: T.MlDeleteExpiredDataRequest, options?: TransportRequestOptions): Promise<T.MlDeleteExpiredDataResponse>
  async deleteExpiredData (this: That, params?: T.MlDeleteExpiredDataRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.delete_expired_data']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    params = params ?? {}
    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    let method = ''
    let path = ''
    if (params.job_id != null) {
      method = 'DELETE'
      path = `/_ml/_delete_expired_data/${encodeURIComponent(params.job_id.toString())}`
    } else {
      method = 'DELETE'
      path = '/_ml/_delete_expired_data'
    }
    const meta: TransportRequestMetadata = {
      name: 'ml.delete_expired_data',
      pathParts: {
        job_id: params.job_id
      },
      acceptedParams: [
        'job_id',
        'requests_per_second',
        'timeout',
        'requests_per_second',
        'timeout'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Delete a filter. If an anomaly detection job references the filter, you cannot delete the filter. You must update or delete the job before you can delete the filter.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-delete-filter | Elasticsearch API documentation}
    */
  async deleteFilter (this: That, params: T.MlDeleteFilterRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlDeleteFilterResponse>
  async deleteFilter (this: That, params: T.MlDeleteFilterRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlDeleteFilterResponse, unknown>>
  async deleteFilter (this: That, params: T.MlDeleteFilterRequest, options?: TransportRequestOptions): Promise<T.MlDeleteFilterResponse>
  async deleteFilter (this: That, params: T.MlDeleteFilterRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.delete_filter']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    const method = 'DELETE'
    const path = `/_ml/filters/${encodeURIComponent(params.filter_id.toString())}`
    const meta: TransportRequestMetadata = {
      name: 'ml.delete_filter',
      pathParts: {
        filter_id: params.filter_id
      },
      acceptedParams: [
        'filter_id'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Delete forecasts from a job. By default, forecasts are retained for 14 days. You can specify a different retention period with the `expires_in` parameter in the forecast jobs API. The delete forecast API enables you to delete one or more forecasts before they expire.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-delete-forecast | Elasticsearch API documentation}
    */
  async deleteForecast (this: That, params: T.MlDeleteForecastRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlDeleteForecastResponse>
  async deleteForecast (this: That, params: T.MlDeleteForecastRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlDeleteForecastResponse, unknown>>
  async deleteForecast (this: That, params: T.MlDeleteForecastRequest, options?: TransportRequestOptions): Promise<T.MlDeleteForecastResponse>
  async deleteForecast (this: That, params: T.MlDeleteForecastRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.delete_forecast']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    let method = ''
    let path = ''
    if (params.job_id != null && params.forecast_id != null) {
      method = 'DELETE'
      path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_forecast/${encodeURIComponent(params.forecast_id.toString())}`
    } else {
      method = 'DELETE'
      path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_forecast`
    }
    const meta: TransportRequestMetadata = {
      name: 'ml.delete_forecast',
      pathParts: {
        job_id: params.job_id,
        forecast_id: params.forecast_id
      },
      acceptedParams: [
        'job_id',
        'forecast_id',
        'allow_no_forecasts',
        'timeout'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Delete an anomaly detection job. All job configuration, model state and results are deleted. It is not currently possible to delete multiple jobs using wildcards or a comma separated list. If you delete a job that has a datafeed, the request first tries to delete the datafeed. This behavior is equivalent to calling the delete datafeed API with the same timeout and force parameters as the delete job request.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-delete-job | Elasticsearch API documentation}
    */
  async deleteJob (this: That, params: T.MlDeleteJobRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlDeleteJobResponse>
  async deleteJob (this: That, params: T.MlDeleteJobRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlDeleteJobResponse, unknown>>
  async deleteJob (this: That, params: T.MlDeleteJobRequest, options?: TransportRequestOptions): Promise<T.MlDeleteJobResponse>
  async deleteJob (this: That, params: T.MlDeleteJobRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.delete_job']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    const method = 'DELETE'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}`
    const meta: TransportRequestMetadata = {
      name: 'ml.delete_job',
      pathParts: {
        job_id: params.job_id
      },
      acceptedParams: [
        'job_id',
        'force',
        'delete_user_annotations',
        'wait_for_completion'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Delete a model snapshot. You cannot delete the active model snapshot. To delete that snapshot, first revert to a different one. To identify the active model snapshot, refer to the `model_snapshot_id` in the results from the get jobs API.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-delete-model-snapshot | Elasticsearch API documentation}
    */
  async deleteModelSnapshot (this: That, params: T.MlDeleteModelSnapshotRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlDeleteModelSnapshotResponse>
  async deleteModelSnapshot (this: That, params: T.MlDeleteModelSnapshotRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlDeleteModelSnapshotResponse, unknown>>
  async deleteModelSnapshot (this: That, params: T.MlDeleteModelSnapshotRequest, options?: TransportRequestOptions): Promise<T.MlDeleteModelSnapshotResponse>
  async deleteModelSnapshot (this: That, params: T.MlDeleteModelSnapshotRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.delete_model_snapshot']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    const method = 'DELETE'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots/${encodeURIComponent(params.snapshot_id.toString())}`
    const meta: TransportRequestMetadata = {
      name: 'ml.delete_model_snapshot',
      pathParts: {
        job_id: params.job_id,
        snapshot_id: params.snapshot_id
      },
      acceptedParams: [
        'job_id',
        'snapshot_id'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Delete an unreferenced trained model. The request deletes a trained inference model that is not referenced by an ingest pipeline.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-delete-trained-model | Elasticsearch API documentation}
    */
  async deleteTrainedModel (this: That, params: T.MlDeleteTrainedModelRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlDeleteTrainedModelResponse>
  async deleteTrainedModel (this: That, params: T.MlDeleteTrainedModelRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlDeleteTrainedModelResponse, unknown>>
  async deleteTrainedModel (this: That, params: T.MlDeleteTrainedModelRequest, options?: TransportRequestOptions): Promise<T.MlDeleteTrainedModelResponse>
  async deleteTrainedModel (this: That, params: T.MlDeleteTrainedModelRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.delete_trained_model']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    const method = 'DELETE'
    const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}`
    const meta: TransportRequestMetadata = {
      name: 'ml.delete_trained_model',
      pathParts: {
        model_id: params.model_id
      },
      acceptedParams: [
        'model_id',
        'force',
        'timeout'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Delete a trained model alias. This API deletes an existing model alias that refers to a trained model. If the model alias is missing or refers to a model other than the one identified by the `model_id`, this API returns an error.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-delete-trained-model-alias | Elasticsearch API documentation}
    */
  async deleteTrainedModelAlias (this: That, params: T.MlDeleteTrainedModelAliasRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlDeleteTrainedModelAliasResponse>
  async deleteTrainedModelAlias (this: That, params: T.MlDeleteTrainedModelAliasRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlDeleteTrainedModelAliasResponse, unknown>>
  async deleteTrainedModelAlias (this: That, params: T.MlDeleteTrainedModelAliasRequest, options?: TransportRequestOptions): Promise<T.MlDeleteTrainedModelAliasResponse>
  async deleteTrainedModelAlias (this: That, params: T.MlDeleteTrainedModelAliasRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.delete_trained_model_alias']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    const method = 'DELETE'
    const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/model_aliases/${encodeURIComponent(params.model_alias.toString())}`
    const meta: TransportRequestMetadata = {
      name: 'ml.delete_trained_model_alias',
      pathParts: {
        model_alias: params.model_alias,
        model_id: params.model_id
      },
      acceptedParams: [
        'model_alias',
        'model_id'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Estimate job model memory usage. Make an estimation of the memory usage for an anomaly detection job model. The estimate is based on analysis configuration details for the job and cardinality estimates for the fields it references.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-estimate-model-memory | Elasticsearch API documentation}
    */
  async estimateModelMemory (this: That, params?: T.MlEstimateModelMemoryRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlEstimateModelMemoryResponse>
  async estimateModelMemory (this: That, params?: T.MlEstimateModelMemoryRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlEstimateModelMemoryResponse, unknown>>
  async estimateModelMemory (this: That, params?: T.MlEstimateModelMemoryRequest, options?: TransportRequestOptions): Promise<T.MlEstimateModelMemoryResponse>
  async estimateModelMemory (this: That, params?: T.MlEstimateModelMemoryRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.estimate_model_memory']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    params = params ?? {}
    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = 'POST'
    const path = '/_ml/anomaly_detectors/_estimate_model_memory'
    const meta: TransportRequestMetadata = {
      name: 'ml.estimate_model_memory',
      acceptedParams: [
        'analysis_config',
        'max_bucket_cardinality',
        'overall_cardinality'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Evaluate data frame analytics. The API packages together commonly used evaluation metrics for various types of machine learning features. This has been designed for use on indexes created by data frame analytics. Evaluation requires both a ground truth field and an analytics result field to be present.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-evaluate-data-frame | Elasticsearch API documentation}
    */
  async evaluateDataFrame (this: That, params: T.MlEvaluateDataFrameRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlEvaluateDataFrameResponse>
  async evaluateDataFrame (this: That, params: T.MlEvaluateDataFrameRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlEvaluateDataFrameResponse, unknown>>
  async evaluateDataFrame (this: That, params: T.MlEvaluateDataFrameRequest, options?: TransportRequestOptions): Promise<T.MlEvaluateDataFrameResponse>
  async evaluateDataFrame (this: That, params: T.MlEvaluateDataFrameRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.evaluate_data_frame']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = 'POST'
    const path = '/_ml/data_frame/_evaluate'
    const meta: TransportRequestMetadata = {
      name: 'ml.evaluate_data_frame',
      acceptedParams: [
        'evaluation',
        'index',
        'query'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Explain data frame analytics config. This API provides explanations for a data frame analytics config that either exists already or one that has not been created yet. The following explanations are provided: * which fields are included or not in the analysis and why, * how much memory is estimated to be required. The estimate can be used when deciding the appropriate value for model_memory_limit setting later on. If you have object fields or fields that are excluded via source filtering, they are not included in the explanation.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-explain-data-frame-analytics | Elasticsearch API documentation}
    */
  async explainDataFrameAnalytics (this: That, params?: T.MlExplainDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlExplainDataFrameAnalyticsResponse>
  async explainDataFrameAnalytics (this: That, params?: T.MlExplainDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlExplainDataFrameAnalyticsResponse, unknown>>
  async explainDataFrameAnalytics (this: That, params?: T.MlExplainDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<T.MlExplainDataFrameAnalyticsResponse>
  async explainDataFrameAnalytics (this: That, params?: T.MlExplainDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.explain_data_frame_analytics']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    params = params ?? {}
    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    let method = ''
    let path = ''
    if (params.id != null) {
      method = body != null ? 'POST' : 'GET'
      path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}/_explain`
    } else {
      method = body != null ? 'POST' : 'GET'
      path = '/_ml/data_frame/analytics/_explain'
    }
    const meta: TransportRequestMetadata = {
      name: 'ml.explain_data_frame_analytics',
      pathParts: {
        id: params.id
      },
      acceptedParams: [
        'id',
        'source',
        'dest',
        'analysis',
        'description',
        'model_memory_limit',
        'max_num_threads',
        'analyzed_fields',
        'allow_lazy_start'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Force buffered data to be processed. The flush jobs API is only applicable when sending data for analysis using the post data API. Depending on the content of the buffer, then it might additionally calculate new results. Both flush and close operations are similar, however the flush is more efficient if you are expecting to send more data for analysis. When flushing, the job remains open and is available to continue analyzing data. A close operation additionally prunes and persists the model state to disk and the job must be opened again before analyzing further data.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-flush-job | Elasticsearch API documentation}
    */
  async flushJob (this: That, params: T.MlFlushJobRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlFlushJobResponse>
  async flushJob (this: That, params: T.MlFlushJobRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlFlushJobResponse, unknown>>
  async flushJob (this: That, params: T.MlFlushJobRequest, options?: TransportRequestOptions): Promise<T.MlFlushJobResponse>
  async flushJob (this: That, params: T.MlFlushJobRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.flush_job']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = 'POST'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_flush`
    const meta: TransportRequestMetadata = {
      name: 'ml.flush_job',
      pathParts: {
        job_id: params.job_id
      },
      acceptedParams: [
        'job_id',
        'advance_time',
        'calc_interim',
        'end',
        'skip_time',
        'start',
        'advance_time',
        'calc_interim',
        'end',
        'skip_time',
        'start'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Predict future behavior of a time series. Forecasts are not supported for jobs that perform population analysis; an error occurs if you try to create a forecast for a job that has an `over_field_name` in its configuration. Forcasts predict future behavior based on historical data.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-forecast | Elasticsearch API documentation}
    */
  async forecast (this: That, params: T.MlForecastRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlForecastResponse>
  async forecast (this: That, params: T.MlForecastRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlForecastResponse, unknown>>
  async forecast (this: That, params: T.MlForecastRequest, options?: TransportRequestOptions): Promise<T.MlForecastResponse>
  async forecast (this: That, params: T.MlForecastRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.forecast']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = 'POST'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_forecast`
    const meta: TransportRequestMetadata = {
      name: 'ml.forecast',
      pathParts: {
        job_id: params.job_id
      },
      acceptedParams: [
        'job_id',
        'duration',
        'expires_in',
        'max_model_memory',
        'duration',
        'expires_in',
        'max_model_memory'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Get anomaly detection job results for buckets. The API presents a chronological view of the records, grouped by bucket.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-get-buckets | Elasticsearch API documentation}
    */
  async getBuckets (this: That, params: T.MlGetBucketsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetBucketsResponse>
  async getBuckets (this: That, params: T.MlGetBucketsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetBucketsResponse, unknown>>
  async getBuckets (this: That, params: T.MlGetBucketsRequest, options?: TransportRequestOptions): Promise<T.MlGetBucketsResponse>
  async getBuckets (this: That, params: T.MlGetBucketsRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.get_buckets']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    let method = ''
    let path = ''
    if (params.job_id != null && params.timestamp != null) {
      method = body != null ? 'POST' : 'GET'
      path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/buckets/${encodeURIComponent(params.timestamp.toString())}`
    } else {
      method = body != null ? 'POST' : 'GET'
      path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/buckets`
    }
    const meta: TransportRequestMetadata = {
      name: 'ml.get_buckets',
      pathParts: {
        job_id: params.job_id,
        timestamp: params.timestamp
      },
      acceptedParams: [
        'job_id',
        'timestamp',
        'anomaly_score',
        'desc',
        'end',
        'exclude_interim',
        'expand',
        'page',
        'sort',
        'start',
        'anomaly_score',
        'desc',
        'end',
        'exclude_interim',
        'expand',
        'from',
        'size',
        'sort',
        'start'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Get info about events in calendars.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-get-calendar-events | Elasticsearch API documentation}
    */
  async getCalendarEvents (this: That, params: T.MlGetCalendarEventsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetCalendarEventsResponse>
  async getCalendarEvents (this: That, params: T.MlGetCalendarEventsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetCalendarEventsResponse, unknown>>
  async getCalendarEvents (this: That, params: T.MlGetCalendarEventsRequest, options?: TransportRequestOptions): Promise<T.MlGetCalendarEventsResponse>
  async getCalendarEvents (this: That, params: T.MlGetCalendarEventsRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.get_calendar_events']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    const method = 'GET'
    const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}/events`
    const meta: TransportRequestMetadata = {
      name: 'ml.get_calendar_events',
      pathParts: {
        calendar_id: params.calendar_id
      },
      acceptedParams: [
        'calendar_id',
        'end',
        'from',
        'job_id',
        'size',
        'start'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Get calendar configuration info.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-get-calendars | Elasticsearch API documentation}
    */
  async getCalendars (this: That, params?: T.MlGetCalendarsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetCalendarsResponse>
  async getCalendars (this: That, params?: T.MlGetCalendarsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetCalendarsResponse, unknown>>
  async getCalendars (this: That, params?: T.MlGetCalendarsRequest, options?: TransportRequestOptions): Promise<T.MlGetCalendarsResponse>
  async getCalendars (this: That, params?: T.MlGetCalendarsRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.get_calendars']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    params = params ?? {}
    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    let method = ''
    let path = ''
    if (params.calendar_id != null) {
      method = body != null ? 'POST' : 'GET'
      path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}`
    } else {
      method = body != null ? 'POST' : 'GET'
      path = '/_ml/calendars'
    }
    const meta: TransportRequestMetadata = {
      name: 'ml.get_calendars',
      pathParts: {
        calendar_id: params.calendar_id
      },
      acceptedParams: [
        'calendar_id',
        'page',
        'from',
        'size'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Get anomaly detection job results for categories.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-get-categories | Elasticsearch API documentation}
    */
  async getCategories (this: That, params: T.MlGetCategoriesRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetCategoriesResponse>
  async getCategories (this: That, params: T.MlGetCategoriesRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetCategoriesResponse, unknown>>
  async getCategories (this: That, params: T.MlGetCategoriesRequest, options?: TransportRequestOptions): Promise<T.MlGetCategoriesResponse>
  async getCategories (this: That, params: T.MlGetCategoriesRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.get_categories']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    let method = ''
    let path = ''
    if (params.job_id != null && params.category_id != null) {
      method = body != null ? 'POST' : 'GET'
      path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/categories/${encodeURIComponent(params.category_id.toString())}`
    } else {
      method = body != null ? 'POST' : 'GET'
      path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/categories`
    }
    const meta: TransportRequestMetadata = {
      name: 'ml.get_categories',
      pathParts: {
        job_id: params.job_id,
        category_id: params.category_id
      },
      acceptedParams: [
        'job_id',
        'category_id',
        'page',
        'from',
        'partition_field_value',
        'size'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Get data frame analytics job configuration info. You can get information for multiple data frame analytics jobs in a single API request by using a comma-separated list of data frame analytics jobs or a wildcard expression.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-get-data-frame-analytics | Elasticsearch API documentation}
    */
  async getDataFrameAnalytics (this: That, params?: T.MlGetDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetDataFrameAnalyticsResponse>
  async getDataFrameAnalytics (this: That, params?: T.MlGetDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetDataFrameAnalyticsResponse, unknown>>
  async getDataFrameAnalytics (this: That, params?: T.MlGetDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<T.MlGetDataFrameAnalyticsResponse>
  async getDataFrameAnalytics (this: That, params?: T.MlGetDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.get_data_frame_analytics']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    params = params ?? {}
    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    let method = ''
    let path = ''
    if (params.id != null) {
      method = 'GET'
      path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}`
    } else {
      method = 'GET'
      path = '/_ml/data_frame/analytics'
    }
    const meta: TransportRequestMetadata = {
      name: 'ml.get_data_frame_analytics',
      pathParts: {
        id: params.id
      },
      acceptedParams: [
        'id',
        'allow_no_match',
        'from',
        'size',
        'exclude_generated'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Get data frame analytics job stats.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-get-data-frame-analytics-stats | Elasticsearch API documentation}
    */
  async getDataFrameAnalyticsStats (this: That, params?: T.MlGetDataFrameAnalyticsStatsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetDataFrameAnalyticsStatsResponse>
  async getDataFrameAnalyticsStats (this: That, params?: T.MlGetDataFrameAnalyticsStatsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetDataFrameAnalyticsStatsResponse, unknown>>
  async getDataFrameAnalyticsStats (this: That, params?: T.MlGetDataFrameAnalyticsStatsRequest, options?: TransportRequestOptions): Promise<T.MlGetDataFrameAnalyticsStatsResponse>
  async getDataFrameAnalyticsStats (this: That, params?: T.MlGetDataFrameAnalyticsStatsRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.get_data_frame_analytics_stats']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    params = params ?? {}
    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    let method = ''
    let path = ''
    if (params.id != null) {
      method = 'GET'
      path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}/_stats`
    } else {
      method = 'GET'
      path = '/_ml/data_frame/analytics/_stats'
    }
    const meta: TransportRequestMetadata = {
      name: 'ml.get_data_frame_analytics_stats',
      pathParts: {
        id: params.id
      },
      acceptedParams: [
        'id',
        'allow_no_match',
        'from',
        'size',
        'verbose'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Get datafeed stats. You can get statistics for multiple datafeeds in a single API request by using a comma-separated list of datafeeds or a wildcard expression. You can get statistics for all datafeeds by using `_all`, by specifying `*` as the `<feed_id>`, or by omitting the `<feed_id>`. If the datafeed is stopped, the only information you receive is the `datafeed_id` and the `state`. This API returns a maximum of 10,000 datafeeds.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-get-datafeed-stats | Elasticsearch API documentation}
    */
  async getDatafeedStats (this: That, params?: T.MlGetDatafeedStatsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetDatafeedStatsResponse>
  async getDatafeedStats (this: That, params?: T.MlGetDatafeedStatsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetDatafeedStatsResponse, unknown>>
  async getDatafeedStats (this: That, params?: T.MlGetDatafeedStatsRequest, options?: TransportRequestOptions): Promise<T.MlGetDatafeedStatsResponse>
  async getDatafeedStats (this: That, params?: T.MlGetDatafeedStatsRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.get_datafeed_stats']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    params = params ?? {}
    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    let method = ''
    let path = ''
    if (params.datafeed_id != null) {
      method = 'GET'
      path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}/_stats`
    } else {
      method = 'GET'
      path = '/_ml/datafeeds/_stats'
    }
    const meta: TransportRequestMetadata = {
      name: 'ml.get_datafeed_stats',
      pathParts: {
        datafeed_id: params.datafeed_id
      },
      acceptedParams: [
        'datafeed_id',
        'allow_no_match'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Get datafeeds configuration info. You can get information for multiple datafeeds in a single API request by using a comma-separated list of datafeeds or a wildcard expression. You can get information for all datafeeds by using `_all`, by specifying `*` as the `<feed_id>`, or by omitting the `<feed_id>`. This API returns a maximum of 10,000 datafeeds.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-get-datafeeds | Elasticsearch API documentation}
    */
  async getDatafeeds (this: That, params?: T.MlGetDatafeedsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetDatafeedsResponse>
  async getDatafeeds (this: That, params?: T.MlGetDatafeedsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetDatafeedsResponse, unknown>>
  async getDatafeeds (this: That, params?: T.MlGetDatafeedsRequest, options?: TransportRequestOptions): Promise<T.MlGetDatafeedsResponse>
  async getDatafeeds (this: That, params?: T.MlGetDatafeedsRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.get_datafeeds']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    params = params ?? {}
    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    let method = ''
    let path = ''
    if (params.datafeed_id != null) {
      method = 'GET'
      path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}`
    } else {
      method = 'GET'
      path = '/_ml/datafeeds'
    }
    const meta: TransportRequestMetadata = {
      name: 'ml.get_datafeeds',
      pathParts: {
        datafeed_id: params.datafeed_id
      },
      acceptedParams: [
        'datafeed_id',
        'allow_no_match',
        'exclude_generated'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Get filters. You can get a single filter or all filters.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-get-filters | Elasticsearch API documentation}
    */
  async getFilters (this: That, params?: T.MlGetFiltersRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetFiltersResponse>
  async getFilters (this: That, params?: T.MlGetFiltersRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetFiltersResponse, unknown>>
  async getFilters (this: That, params?: T.MlGetFiltersRequest, options?: TransportRequestOptions): Promise<T.MlGetFiltersResponse>
  async getFilters (this: That, params?: T.MlGetFiltersRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.get_filters']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    params = params ?? {}
    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    let method = ''
    let path = ''
    if (params.filter_id != null) {
      method = 'GET'
      path = `/_ml/filters/${encodeURIComponent(params.filter_id.toString())}`
    } else {
      method = 'GET'
      path = '/_ml/filters'
    }
    const meta: TransportRequestMetadata = {
      name: 'ml.get_filters',
      pathParts: {
        filter_id: params.filter_id
      },
      acceptedParams: [
        'filter_id',
        'from',
        'size'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Get anomaly detection job results for influencers. Influencers are the entities that have contributed to, or are to blame for, the anomalies. Influencer results are available only if an `influencer_field_name` is specified in the job configuration.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-get-influencers | Elasticsearch API documentation}
    */
  async getInfluencers (this: That, params: T.MlGetInfluencersRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetInfluencersResponse>
  async getInfluencers (this: That, params: T.MlGetInfluencersRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetInfluencersResponse, unknown>>
  async getInfluencers (this: That, params: T.MlGetInfluencersRequest, options?: TransportRequestOptions): Promise<T.MlGetInfluencersResponse>
  async getInfluencers (this: That, params: T.MlGetInfluencersRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.get_influencers']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = body != null ? 'POST' : 'GET'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/influencers`
    const meta: TransportRequestMetadata = {
      name: 'ml.get_influencers',
      pathParts: {
        job_id: params.job_id
      },
      acceptedParams: [
        'job_id',
        'page',
        'desc',
        'end',
        'exclude_interim',
        'influencer_score',
        'from',
        'size',
        'sort',
        'start'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Get anomaly detection job stats.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-get-job-stats | Elasticsearch API documentation}
    */
  async getJobStats (this: That, params?: T.MlGetJobStatsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetJobStatsResponse>
  async getJobStats (this: That, params?: T.MlGetJobStatsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetJobStatsResponse, unknown>>
  async getJobStats (this: That, params?: T.MlGetJobStatsRequest, options?: TransportRequestOptions): Promise<T.MlGetJobStatsResponse>
  async getJobStats (this: That, params?: T.MlGetJobStatsRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.get_job_stats']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    params = params ?? {}
    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    let method = ''
    let path = ''
    if (params.job_id != null) {
      method = 'GET'
      path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_stats`
    } else {
      method = 'GET'
      path = '/_ml/anomaly_detectors/_stats'
    }
    const meta: TransportRequestMetadata = {
      name: 'ml.get_job_stats',
      pathParts: {
        job_id: params.job_id
      },
      acceptedParams: [
        'job_id',
        'allow_no_match'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Get anomaly detection jobs configuration info. You can get information for multiple anomaly detection jobs in a single API request by using a group name, a comma-separated list of jobs, or a wildcard expression. You can get information for all anomaly detection jobs by using `_all`, by specifying `*` as the `<job_id>`, or by omitting the `<job_id>`.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-get-jobs | Elasticsearch API documentation}
    */
  async getJobs (this: That, params?: T.MlGetJobsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetJobsResponse>
  async getJobs (this: That, params?: T.MlGetJobsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetJobsResponse, unknown>>
  async getJobs (this: That, params?: T.MlGetJobsRequest, options?: TransportRequestOptions): Promise<T.MlGetJobsResponse>
  async getJobs (this: That, params?: T.MlGetJobsRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.get_jobs']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    params = params ?? {}
    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    let method = ''
    let path = ''
    if (params.job_id != null) {
      method = 'GET'
      path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}`
    } else {
      method = 'GET'
      path = '/_ml/anomaly_detectors'
    }
    const meta: TransportRequestMetadata = {
      name: 'ml.get_jobs',
      pathParts: {
        job_id: params.job_id
      },
      acceptedParams: [
        'job_id',
        'allow_no_match',
        'exclude_generated'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Get machine learning memory usage info. Get information about how machine learning jobs and trained models are using memory, on each node, both within the JVM heap, and natively, outside of the JVM.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-get-memory-stats | Elasticsearch API documentation}
    */
  async getMemoryStats (this: That, params?: T.MlGetMemoryStatsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetMemoryStatsResponse>
  async getMemoryStats (this: That, params?: T.MlGetMemoryStatsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetMemoryStatsResponse, unknown>>
  async getMemoryStats (this: That, params?: T.MlGetMemoryStatsRequest, options?: TransportRequestOptions): Promise<T.MlGetMemoryStatsResponse>
  async getMemoryStats (this: That, params?: T.MlGetMemoryStatsRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.get_memory_stats']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    params = params ?? {}
    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    let method = ''
    let path = ''
    if (params.node_id != null) {
      method = 'GET'
      path = `/_ml/memory/${encodeURIComponent(params.node_id.toString())}/_stats`
    } else {
      method = 'GET'
      path = '/_ml/memory/_stats'
    }
    const meta: TransportRequestMetadata = {
      name: 'ml.get_memory_stats',
      pathParts: {
        node_id: params.node_id
      },
      acceptedParams: [
        'node_id',
        'master_timeout',
        'timeout'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Get anomaly detection job model snapshot upgrade usage info.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-get-model-snapshot-upgrade-stats | Elasticsearch API documentation}
    */
  async getModelSnapshotUpgradeStats (this: That, params: T.MlGetModelSnapshotUpgradeStatsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetModelSnapshotUpgradeStatsResponse>
  async getModelSnapshotUpgradeStats (this: That, params: T.MlGetModelSnapshotUpgradeStatsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetModelSnapshotUpgradeStatsResponse, unknown>>
  async getModelSnapshotUpgradeStats (this: That, params: T.MlGetModelSnapshotUpgradeStatsRequest, options?: TransportRequestOptions): Promise<T.MlGetModelSnapshotUpgradeStatsResponse>
  async getModelSnapshotUpgradeStats (this: That, params: T.MlGetModelSnapshotUpgradeStatsRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.get_model_snapshot_upgrade_stats']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    const method = 'GET'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots/${encodeURIComponent(params.snapshot_id.toString())}/_upgrade/_stats`
    const meta: TransportRequestMetadata = {
      name: 'ml.get_model_snapshot_upgrade_stats',
      pathParts: {
        job_id: params.job_id,
        snapshot_id: params.snapshot_id
      },
      acceptedParams: [
        'job_id',
        'snapshot_id',
        'allow_no_match'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Get model snapshots info.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-get-model-snapshots | Elasticsearch API documentation}
    */
  async getModelSnapshots (this: That, params: T.MlGetModelSnapshotsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetModelSnapshotsResponse>
  async getModelSnapshots (this: That, params: T.MlGetModelSnapshotsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetModelSnapshotsResponse, unknown>>
  async getModelSnapshots (this: That, params: T.MlGetModelSnapshotsRequest, options?: TransportRequestOptions): Promise<T.MlGetModelSnapshotsResponse>
  async getModelSnapshots (this: That, params: T.MlGetModelSnapshotsRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.get_model_snapshots']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    let method = ''
    let path = ''
    if (params.job_id != null && params.snapshot_id != null) {
      method = body != null ? 'POST' : 'GET'
      path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots/${encodeURIComponent(params.snapshot_id.toString())}`
    } else {
      method = body != null ? 'POST' : 'GET'
      path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots`
    }
    const meta: TransportRequestMetadata = {
      name: 'ml.get_model_snapshots',
      pathParts: {
        job_id: params.job_id,
        snapshot_id: params.snapshot_id
      },
      acceptedParams: [
        'job_id',
        'snapshot_id',
        'desc',
        'end',
        'page',
        'sort',
        'start',
        'desc',
        'end',
        'from',
        'size',
        'sort',
        'start'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Get overall bucket results. Retrievs overall bucket results that summarize the bucket results of multiple anomaly detection jobs. The `overall_score` is calculated by combining the scores of all the buckets within the overall bucket span. First, the maximum `anomaly_score` per anomaly detection job in the overall bucket is calculated. Then the `top_n` of those scores are averaged to result in the `overall_score`. This means that you can fine-tune the `overall_score` so that it is more or less sensitive to the number of jobs that detect an anomaly at the same time. For example, if you set `top_n` to `1`, the `overall_score` is the maximum bucket score in the overall bucket. Alternatively, if you set `top_n` to the number of jobs, the `overall_score` is high only when all jobs detect anomalies in that overall bucket. If you set the `bucket_span` parameter (to a value greater than its default), the `overall_score` is the maximum `overall_score` of the overall buckets that have a span equal to the jobs' largest bucket span.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-get-overall-buckets | Elasticsearch API documentation}
    */
  async getOverallBuckets (this: That, params: T.MlGetOverallBucketsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetOverallBucketsResponse>
  async getOverallBuckets (this: That, params: T.MlGetOverallBucketsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetOverallBucketsResponse, unknown>>
  async getOverallBuckets (this: That, params: T.MlGetOverallBucketsRequest, options?: TransportRequestOptions): Promise<T.MlGetOverallBucketsResponse>
  async getOverallBuckets (this: That, params: T.MlGetOverallBucketsRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.get_overall_buckets']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = body != null ? 'POST' : 'GET'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/overall_buckets`
    const meta: TransportRequestMetadata = {
      name: 'ml.get_overall_buckets',
      pathParts: {
        job_id: params.job_id
      },
      acceptedParams: [
        'job_id',
        'allow_no_match',
        'bucket_span',
        'end',
        'exclude_interim',
        'overall_score',
        'start',
        'top_n',
        'allow_no_match',
        'bucket_span',
        'end',
        'exclude_interim',
        'overall_score',
        'start',
        'top_n'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Get anomaly records for an anomaly detection job. Records contain the detailed analytical results. They describe the anomalous activity that has been identified in the input data based on the detector configuration. There can be many anomaly records depending on the characteristics and size of the input data. In practice, there are often too many to be able to manually process them. The machine learning features therefore perform a sophisticated aggregation of the anomaly records into buckets. The number of record results depends on the number of anomalies found in each bucket, which relates to the number of time series being modeled and the number of detectors.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-get-records | Elasticsearch API documentation}
    */
  async getRecords (this: That, params: T.MlGetRecordsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetRecordsResponse>
  async getRecords (this: That, params: T.MlGetRecordsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetRecordsResponse, unknown>>
  async getRecords (this: That, params: T.MlGetRecordsRequest, options?: TransportRequestOptions): Promise<T.MlGetRecordsResponse>
  async getRecords (this: That, params: T.MlGetRecordsRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.get_records']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = body != null ? 'POST' : 'GET'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/records`
    const meta: TransportRequestMetadata = {
      name: 'ml.get_records',
      pathParts: {
        job_id: params.job_id
      },
      acceptedParams: [
        'job_id',
        'desc',
        'end',
        'exclude_interim',
        'page',
        'record_score',
        'sort',
        'start',
        'desc',
        'end',
        'exclude_interim',
        'from',
        'record_score',
        'size',
        'sort',
        'start'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Get trained model configuration info.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-get-trained-models | Elasticsearch API documentation}
    */
  async getTrainedModels (this: That, params?: T.MlGetTrainedModelsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetTrainedModelsResponse>
  async getTrainedModels (this: That, params?: T.MlGetTrainedModelsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetTrainedModelsResponse, unknown>>
  async getTrainedModels (this: That, params?: T.MlGetTrainedModelsRequest, options?: TransportRequestOptions): Promise<T.MlGetTrainedModelsResponse>
  async getTrainedModels (this: That, params?: T.MlGetTrainedModelsRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.get_trained_models']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    params = params ?? {}
    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    let method = ''
    let path = ''
    if (params.model_id != null) {
      method = 'GET'
      path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}`
    } else {
      method = 'GET'
      path = '/_ml/trained_models'
    }
    const meta: TransportRequestMetadata = {
      name: 'ml.get_trained_models',
      pathParts: {
        model_id: params.model_id
      },
      acceptedParams: [
        'model_id',
        'allow_no_match',
        'decompress_definition',
        'exclude_generated',
        'from',
        'include',
        'size',
        'tags'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Get trained models usage info. You can get usage information for multiple trained models in a single API request by using a comma-separated list of model IDs or a wildcard expression.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-get-trained-models-stats | Elasticsearch API documentation}
    */
  async getTrainedModelsStats (this: That, params?: T.MlGetTrainedModelsStatsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlGetTrainedModelsStatsResponse>
  async getTrainedModelsStats (this: That, params?: T.MlGetTrainedModelsStatsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlGetTrainedModelsStatsResponse, unknown>>
  async getTrainedModelsStats (this: That, params?: T.MlGetTrainedModelsStatsRequest, options?: TransportRequestOptions): Promise<T.MlGetTrainedModelsStatsResponse>
  async getTrainedModelsStats (this: That, params?: T.MlGetTrainedModelsStatsRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.get_trained_models_stats']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    params = params ?? {}
    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    let method = ''
    let path = ''
    if (params.model_id != null) {
      method = 'GET'
      path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/_stats`
    } else {
      method = 'GET'
      path = '/_ml/trained_models/_stats'
    }
    const meta: TransportRequestMetadata = {
      name: 'ml.get_trained_models_stats',
      pathParts: {
        model_id: params.model_id
      },
      acceptedParams: [
        'model_id',
        'allow_no_match',
        'from',
        'size'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Evaluate a trained model.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-infer-trained-model | Elasticsearch API documentation}
    */
  async inferTrainedModel (this: That, params: T.MlInferTrainedModelRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlInferTrainedModelResponse>
  async inferTrainedModel (this: That, params: T.MlInferTrainedModelRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlInferTrainedModelResponse, unknown>>
  async inferTrainedModel (this: That, params: T.MlInferTrainedModelRequest, options?: TransportRequestOptions): Promise<T.MlInferTrainedModelResponse>
  async inferTrainedModel (this: That, params: T.MlInferTrainedModelRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.infer_trained_model']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = 'POST'
    const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/_infer`
    const meta: TransportRequestMetadata = {
      name: 'ml.infer_trained_model',
      pathParts: {
        model_id: params.model_id
      },
      acceptedParams: [
        'model_id',
        'docs',
        'inference_config',
        'timeout'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Get machine learning information. Get defaults and limits used by machine learning. This endpoint is designed to be used by a user interface that needs to fully understand machine learning configurations where some options are not specified, meaning that the defaults should be used. This endpoint may be used to find out what those defaults are. It also provides information about the maximum size of machine learning jobs that could run in the current cluster configuration.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-info | Elasticsearch API documentation}
    */
  async info (this: That, params?: T.MlInfoRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlInfoResponse>
  async info (this: That, params?: T.MlInfoRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlInfoResponse, unknown>>
  async info (this: That, params?: T.MlInfoRequest, options?: TransportRequestOptions): Promise<T.MlInfoResponse>
  async info (this: That, params?: T.MlInfoRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.info']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    params = params ?? {}
    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    const method = 'GET'
    const path = '/_ml/info'
    const meta: TransportRequestMetadata = {
      name: 'ml.info',
      acceptedParams: [
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Open anomaly detection jobs. An anomaly detection job must be opened to be ready to receive and analyze data. It can be opened and closed multiple times throughout its lifecycle. When you open a new job, it starts with an empty model. When you open an existing job, the most recent model state is automatically loaded. The job is ready to resume its analysis from where it left off, once new data is received.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-open-job | Elasticsearch API documentation}
    */
  async openJob (this: That, params: T.MlOpenJobRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlOpenJobResponse>
  async openJob (this: That, params: T.MlOpenJobRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlOpenJobResponse, unknown>>
  async openJob (this: That, params: T.MlOpenJobRequest, options?: TransportRequestOptions): Promise<T.MlOpenJobResponse>
  async openJob (this: That, params: T.MlOpenJobRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.open_job']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = 'POST'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_open`
    const meta: TransportRequestMetadata = {
      name: 'ml.open_job',
      pathParts: {
        job_id: params.job_id
      },
      acceptedParams: [
        'job_id',
        'timeout',
        'timeout'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Add scheduled events to the calendar.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-post-calendar-events | Elasticsearch API documentation}
    */
  async postCalendarEvents (this: That, params: T.MlPostCalendarEventsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlPostCalendarEventsResponse>
  async postCalendarEvents (this: That, params: T.MlPostCalendarEventsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlPostCalendarEventsResponse, unknown>>
  async postCalendarEvents (this: That, params: T.MlPostCalendarEventsRequest, options?: TransportRequestOptions): Promise<T.MlPostCalendarEventsResponse>
  async postCalendarEvents (this: That, params: T.MlPostCalendarEventsRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.post_calendar_events']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = 'POST'
    const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}/events`
    const meta: TransportRequestMetadata = {
      name: 'ml.post_calendar_events',
      pathParts: {
        calendar_id: params.calendar_id
      },
      acceptedParams: [
        'calendar_id',
        'events'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Send data to an anomaly detection job for analysis. IMPORTANT: For each job, data can be accepted from only a single connection at a time. It is not currently possible to post data to multiple jobs using wildcards or a comma-separated list.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-post-data | Elasticsearch API documentation}
    */
  async postData<TData = unknown> (this: That, params: T.MlPostDataRequest<TData>, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlPostDataResponse>
  async postData<TData = unknown> (this: That, params: T.MlPostDataRequest<TData>, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlPostDataResponse, unknown>>
  async postData<TData = unknown> (this: That, params: T.MlPostDataRequest<TData>, options?: TransportRequestOptions): Promise<T.MlPostDataResponse>
  async postData<TData = unknown> (this: That, params: T.MlPostDataRequest<TData>, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.post_data']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: any = params.body ?? undefined
    for (const key in params) {
      if (acceptedBody.includes(key)) {
        // @ts-expect-error
        body = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = 'POST'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_data`
    const meta: TransportRequestMetadata = {
      name: 'ml.post_data',
      pathParts: {
        job_id: params.job_id
      },
      acceptedParams: [
        'job_id',
        'data',
        'reset_end',
        'reset_start'
      ]
    }
    return await this.transport.request({ path, method, querystring, bulkBody: body, meta }, options)
  }

  /**
    * Preview features used by data frame analytics. Preview the extracted features used by a data frame analytics config.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-preview-data-frame-analytics | Elasticsearch API documentation}
    */
  async previewDataFrameAnalytics (this: That, params?: T.MlPreviewDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlPreviewDataFrameAnalyticsResponse>
  async previewDataFrameAnalytics (this: That, params?: T.MlPreviewDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlPreviewDataFrameAnalyticsResponse, unknown>>
  async previewDataFrameAnalytics (this: That, params?: T.MlPreviewDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<T.MlPreviewDataFrameAnalyticsResponse>
  async previewDataFrameAnalytics (this: That, params?: T.MlPreviewDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.preview_data_frame_analytics']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    params = params ?? {}
    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    let method = ''
    let path = ''
    if (params.id != null) {
      method = body != null ? 'POST' : 'GET'
      path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}/_preview`
    } else {
      method = body != null ? 'POST' : 'GET'
      path = '/_ml/data_frame/analytics/_preview'
    }
    const meta: TransportRequestMetadata = {
      name: 'ml.preview_data_frame_analytics',
      pathParts: {
        id: params.id
      },
      acceptedParams: [
        'id',
        'config'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Preview a datafeed. This API returns the first "page" of search results from a datafeed. You can preview an existing datafeed or provide configuration details for a datafeed and anomaly detection job in the API. The preview shows the structure of the data that will be passed to the anomaly detection engine. IMPORTANT: When Elasticsearch security features are enabled, the preview uses the credentials of the user that called the API. However, when the datafeed starts it uses the roles of the last user that created or updated the datafeed. To get a preview that accurately reflects the behavior of the datafeed, use the appropriate credentials. You can also use secondary authorization headers to supply the credentials.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-preview-datafeed | Elasticsearch API documentation}
    */
  async previewDatafeed<TDocument = unknown> (this: That, params?: T.MlPreviewDatafeedRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlPreviewDatafeedResponse<TDocument>>
  async previewDatafeed<TDocument = unknown> (this: That, params?: T.MlPreviewDatafeedRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlPreviewDatafeedResponse<TDocument>, unknown>>
  async previewDatafeed<TDocument = unknown> (this: That, params?: T.MlPreviewDatafeedRequest, options?: TransportRequestOptions): Promise<T.MlPreviewDatafeedResponse<TDocument>>
  async previewDatafeed<TDocument = unknown> (this: That, params?: T.MlPreviewDatafeedRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.preview_datafeed']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    params = params ?? {}
    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    let method = ''
    let path = ''
    if (params.datafeed_id != null) {
      method = body != null ? 'POST' : 'GET'
      path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}/_preview`
    } else {
      method = body != null ? 'POST' : 'GET'
      path = '/_ml/datafeeds/_preview'
    }
    const meta: TransportRequestMetadata = {
      name: 'ml.preview_datafeed',
      pathParts: {
        datafeed_id: params.datafeed_id
      },
      acceptedParams: [
        'datafeed_id',
        'datafeed_config',
        'job_config',
        'start',
        'end'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Create a calendar.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-put-calendar | Elasticsearch API documentation}
    */
  async putCalendar (this: That, params: T.MlPutCalendarRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlPutCalendarResponse>
  async putCalendar (this: That, params: T.MlPutCalendarRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlPutCalendarResponse, unknown>>
  async putCalendar (this: That, params: T.MlPutCalendarRequest, options?: TransportRequestOptions): Promise<T.MlPutCalendarResponse>
  async putCalendar (this: That, params: T.MlPutCalendarRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.put_calendar']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = 'PUT'
    const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}`
    const meta: TransportRequestMetadata = {
      name: 'ml.put_calendar',
      pathParts: {
        calendar_id: params.calendar_id
      },
      acceptedParams: [
        'calendar_id',
        'job_ids',
        'description'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Add anomaly detection job to calendar.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-put-calendar-job | Elasticsearch API documentation}
    */
  async putCalendarJob (this: That, params: T.MlPutCalendarJobRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlPutCalendarJobResponse>
  async putCalendarJob (this: That, params: T.MlPutCalendarJobRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlPutCalendarJobResponse, unknown>>
  async putCalendarJob (this: That, params: T.MlPutCalendarJobRequest, options?: TransportRequestOptions): Promise<T.MlPutCalendarJobResponse>
  async putCalendarJob (this: That, params: T.MlPutCalendarJobRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.put_calendar_job']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    const method = 'PUT'
    const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}/jobs/${encodeURIComponent(params.job_id.toString())}`
    const meta: TransportRequestMetadata = {
      name: 'ml.put_calendar_job',
      pathParts: {
        calendar_id: params.calendar_id,
        job_id: params.job_id
      },
      acceptedParams: [
        'calendar_id',
        'job_id'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Create a data frame analytics job. This API creates a data frame analytics job that performs an analysis on the source indices and stores the outcome in a destination index. By default, the query used in the source configuration is `{"match_all": {}}`. If the destination index does not exist, it is created automatically when you start the job. If you supply only a subset of the regression or classification parameters, hyperparameter optimization occurs. It determines a value for each of the undefined parameters.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-put-data-frame-analytics | Elasticsearch API documentation}
    */
  async putDataFrameAnalytics (this: That, params: T.MlPutDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlPutDataFrameAnalyticsResponse>
  async putDataFrameAnalytics (this: That, params: T.MlPutDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlPutDataFrameAnalyticsResponse, unknown>>
  async putDataFrameAnalytics (this: That, params: T.MlPutDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<T.MlPutDataFrameAnalyticsResponse>
  async putDataFrameAnalytics (this: That, params: T.MlPutDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.put_data_frame_analytics']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = 'PUT'
    const path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}`
    const meta: TransportRequestMetadata = {
      name: 'ml.put_data_frame_analytics',
      pathParts: {
        id: params.id
      },
      acceptedParams: [
        'id',
        'allow_lazy_start',
        'analysis',
        'analyzed_fields',
        'description',
        'dest',
        'max_num_threads',
        '_meta',
        'model_memory_limit',
        'source',
        'headers',
        'version'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Create a datafeed. Datafeeds retrieve data from Elasticsearch for analysis by an anomaly detection job. You can associate only one datafeed with each anomaly detection job. The datafeed contains a query that runs at a defined interval (`frequency`). If you are concerned about delayed data, you can add a delay (`query_delay') at each interval. By default, the datafeed uses the following query: `{"match_all": {"boost": 1}}`. When Elasticsearch security features are enabled, your datafeed remembers which roles the user who created it had at the time of creation and runs the query using those same roles. If you provide secondary authorization headers, those credentials are used instead. You must use Kibana, this API, or the create anomaly detection jobs API to create a datafeed. Do not add a datafeed directly to the `.ml-config` index. Do not give users `write` privileges on the `.ml-config` index.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-put-datafeed | Elasticsearch API documentation}
    */
  async putDatafeed (this: That, params: T.MlPutDatafeedRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlPutDatafeedResponse>
  async putDatafeed (this: That, params: T.MlPutDatafeedRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlPutDatafeedResponse, unknown>>
  async putDatafeed (this: That, params: T.MlPutDatafeedRequest, options?: TransportRequestOptions): Promise<T.MlPutDatafeedResponse>
  async putDatafeed (this: That, params: T.MlPutDatafeedRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.put_datafeed']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = 'PUT'
    const path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}`
    const meta: TransportRequestMetadata = {
      name: 'ml.put_datafeed',
      pathParts: {
        datafeed_id: params.datafeed_id
      },
      acceptedParams: [
        'datafeed_id',
        'aggregations',
        'aggs',
        'chunking_config',
        'delayed_data_check_config',
        'frequency',
        'indices',
        'indexes',
        'indices_options',
        'job_id',
        'max_empty_searches',
        'query',
        'query_delay',
        'runtime_mappings',
        'script_fields',
        'scroll_size',
        'headers',
        'allow_no_indices',
        'expand_wildcards',
        'ignore_throttled',
        'ignore_unavailable'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Create a filter. A filter contains a list of strings. It can be used by one or more anomaly detection jobs. Specifically, filters are referenced in the `custom_rules` property of detector configuration objects.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-put-filter | Elasticsearch API documentation}
    */
  async putFilter (this: That, params: T.MlPutFilterRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlPutFilterResponse>
  async putFilter (this: That, params: T.MlPutFilterRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlPutFilterResponse, unknown>>
  async putFilter (this: That, params: T.MlPutFilterRequest, options?: TransportRequestOptions): Promise<T.MlPutFilterResponse>
  async putFilter (this: That, params: T.MlPutFilterRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.put_filter']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = 'PUT'
    const path = `/_ml/filters/${encodeURIComponent(params.filter_id.toString())}`
    const meta: TransportRequestMetadata = {
      name: 'ml.put_filter',
      pathParts: {
        filter_id: params.filter_id
      },
      acceptedParams: [
        'filter_id',
        'description',
        'items'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Create an anomaly detection job. If you include a `datafeed_config`, you must have read index privileges on the source index. If you include a `datafeed_config` but do not provide a query, the datafeed uses `{"match_all": {"boost": 1}}`.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-put-job | Elasticsearch API documentation}
    */
  async putJob (this: That, params: T.MlPutJobRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlPutJobResponse>
  async putJob (this: That, params: T.MlPutJobRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlPutJobResponse, unknown>>
  async putJob (this: That, params: T.MlPutJobRequest, options?: TransportRequestOptions): Promise<T.MlPutJobResponse>
  async putJob (this: That, params: T.MlPutJobRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.put_job']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = 'PUT'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}`
    const meta: TransportRequestMetadata = {
      name: 'ml.put_job',
      pathParts: {
        job_id: params.job_id
      },
      acceptedParams: [
        'job_id',
        'allow_lazy_open',
        'analysis_config',
        'analysis_limits',
        'background_persist_interval',
        'custom_settings',
        'daily_model_snapshot_retention_after_days',
        'data_description',
        'datafeed_config',
        'description',
        'job_id',
        'groups',
        'model_plot_config',
        'model_snapshot_retention_days',
        'renormalization_window_days',
        'results_index_name',
        'results_retention_days',
        'allow_no_indices',
        'expand_wildcards',
        'ignore_throttled',
        'ignore_unavailable'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Create a trained model. Enable you to supply a trained model that is not created by data frame analytics.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-put-trained-model | Elasticsearch API documentation}
    */
  async putTrainedModel (this: That, params: T.MlPutTrainedModelRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlPutTrainedModelResponse>
  async putTrainedModel (this: That, params: T.MlPutTrainedModelRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlPutTrainedModelResponse, unknown>>
  async putTrainedModel (this: That, params: T.MlPutTrainedModelRequest, options?: TransportRequestOptions): Promise<T.MlPutTrainedModelResponse>
  async putTrainedModel (this: That, params: T.MlPutTrainedModelRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.put_trained_model']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = 'PUT'
    const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}`
    const meta: TransportRequestMetadata = {
      name: 'ml.put_trained_model',
      pathParts: {
        model_id: params.model_id
      },
      acceptedParams: [
        'model_id',
        'compressed_definition',
        'definition',
        'description',
        'inference_config',
        'input',
        'metadata',
        'model_type',
        'model_size_bytes',
        'platform_architecture',
        'tags',
        'prefix_strings',
        'defer_definition_decompression',
        'wait_for_completion'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Create or update a trained model alias. A trained model alias is a logical name used to reference a single trained model. You can use aliases instead of trained model identifiers to make it easier to reference your models. For example, you can use aliases in inference aggregations and processors. An alias must be unique and refer to only a single trained model. However, you can have multiple aliases for each trained model. If you use this API to update an alias such that it references a different trained model ID and the model uses a different type of data frame analytics, an error occurs. For example, this situation occurs if you have a trained model for regression analysis and a trained model for classification analysis; you cannot reassign an alias from one type of trained model to another. If you use this API to update an alias and there are very few input fields in common between the old and new trained models for the model alias, the API returns a warning.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-put-trained-model-alias | Elasticsearch API documentation}
    */
  async putTrainedModelAlias (this: That, params: T.MlPutTrainedModelAliasRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlPutTrainedModelAliasResponse>
  async putTrainedModelAlias (this: That, params: T.MlPutTrainedModelAliasRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlPutTrainedModelAliasResponse, unknown>>
  async putTrainedModelAlias (this: That, params: T.MlPutTrainedModelAliasRequest, options?: TransportRequestOptions): Promise<T.MlPutTrainedModelAliasResponse>
  async putTrainedModelAlias (this: That, params: T.MlPutTrainedModelAliasRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.put_trained_model_alias']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    const method = 'PUT'
    const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/model_aliases/${encodeURIComponent(params.model_alias.toString())}`
    const meta: TransportRequestMetadata = {
      name: 'ml.put_trained_model_alias',
      pathParts: {
        model_alias: params.model_alias,
        model_id: params.model_id
      },
      acceptedParams: [
        'model_alias',
        'model_id',
        'reassign'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Create part of a trained model definition.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-put-trained-model-definition-part | Elasticsearch API documentation}
    */
  async putTrainedModelDefinitionPart (this: That, params: T.MlPutTrainedModelDefinitionPartRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlPutTrainedModelDefinitionPartResponse>
  async putTrainedModelDefinitionPart (this: That, params: T.MlPutTrainedModelDefinitionPartRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlPutTrainedModelDefinitionPartResponse, unknown>>
  async putTrainedModelDefinitionPart (this: That, params: T.MlPutTrainedModelDefinitionPartRequest, options?: TransportRequestOptions): Promise<T.MlPutTrainedModelDefinitionPartResponse>
  async putTrainedModelDefinitionPart (this: That, params: T.MlPutTrainedModelDefinitionPartRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.put_trained_model_definition_part']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = 'PUT'
    const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/definition/${encodeURIComponent(params.part.toString())}`
    const meta: TransportRequestMetadata = {
      name: 'ml.put_trained_model_definition_part',
      pathParts: {
        model_id: params.model_id,
        part: params.part
      },
      acceptedParams: [
        'model_id',
        'part',
        'definition',
        'total_definition_length',
        'total_parts'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Create a trained model vocabulary. This API is supported only for natural language processing (NLP) models. The vocabulary is stored in the index as described in `inference_config.*.vocabulary` of the trained model definition.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-put-trained-model-vocabulary | Elasticsearch API documentation}
    */
  async putTrainedModelVocabulary (this: That, params: T.MlPutTrainedModelVocabularyRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlPutTrainedModelVocabularyResponse>
  async putTrainedModelVocabulary (this: That, params: T.MlPutTrainedModelVocabularyRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlPutTrainedModelVocabularyResponse, unknown>>
  async putTrainedModelVocabulary (this: That, params: T.MlPutTrainedModelVocabularyRequest, options?: TransportRequestOptions): Promise<T.MlPutTrainedModelVocabularyResponse>
  async putTrainedModelVocabulary (this: That, params: T.MlPutTrainedModelVocabularyRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.put_trained_model_vocabulary']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = 'PUT'
    const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/vocabulary`
    const meta: TransportRequestMetadata = {
      name: 'ml.put_trained_model_vocabulary',
      pathParts: {
        model_id: params.model_id
      },
      acceptedParams: [
        'model_id',
        'vocabulary',
        'merges',
        'scores'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Reset an anomaly detection job. All model state and results are deleted. The job is ready to start over as if it had just been created. It is not currently possible to reset multiple jobs using wildcards or a comma separated list.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-reset-job | Elasticsearch API documentation}
    */
  async resetJob (this: That, params: T.MlResetJobRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlResetJobResponse>
  async resetJob (this: That, params: T.MlResetJobRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlResetJobResponse, unknown>>
  async resetJob (this: That, params: T.MlResetJobRequest, options?: TransportRequestOptions): Promise<T.MlResetJobResponse>
  async resetJob (this: That, params: T.MlResetJobRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.reset_job']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    const method = 'POST'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_reset`
    const meta: TransportRequestMetadata = {
      name: 'ml.reset_job',
      pathParts: {
        job_id: params.job_id
      },
      acceptedParams: [
        'job_id',
        'wait_for_completion',
        'delete_user_annotations'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Revert to a snapshot. The machine learning features react quickly to anomalous input, learning new behaviors in data. Highly anomalous input increases the variance in the models whilst the system learns whether this is a new step-change in behavior or a one-off event. In the case where this anomalous input is known to be a one-off, then it might be appropriate to reset the model state to a time before this event. For example, you might consider reverting to a saved snapshot after Black Friday or a critical system failure.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-revert-model-snapshot | Elasticsearch API documentation}
    */
  async revertModelSnapshot (this: That, params: T.MlRevertModelSnapshotRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlRevertModelSnapshotResponse>
  async revertModelSnapshot (this: That, params: T.MlRevertModelSnapshotRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlRevertModelSnapshotResponse, unknown>>
  async revertModelSnapshot (this: That, params: T.MlRevertModelSnapshotRequest, options?: TransportRequestOptions): Promise<T.MlRevertModelSnapshotResponse>
  async revertModelSnapshot (this: That, params: T.MlRevertModelSnapshotRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.revert_model_snapshot']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = 'POST'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots/${encodeURIComponent(params.snapshot_id.toString())}/_revert`
    const meta: TransportRequestMetadata = {
      name: 'ml.revert_model_snapshot',
      pathParts: {
        job_id: params.job_id,
        snapshot_id: params.snapshot_id
      },
      acceptedParams: [
        'job_id',
        'snapshot_id',
        'delete_intervening_results',
        'delete_intervening_results'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Set upgrade_mode for ML indices. Sets a cluster wide upgrade_mode setting that prepares machine learning indices for an upgrade. When upgrading your cluster, in some circumstances you must restart your nodes and reindex your machine learning indices. In those circumstances, there must be no machine learning jobs running. You can close the machine learning jobs, do the upgrade, then open all the jobs again. Alternatively, you can use this API to temporarily halt tasks associated with the jobs and datafeeds and prevent new jobs from opening. You can also use this API during upgrades that do not require you to reindex your machine learning indices, though stopping jobs is not a requirement in that case. You can see the current value for the upgrade_mode setting by using the get machine learning info API.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-set-upgrade-mode | Elasticsearch API documentation}
    */
  async setUpgradeMode (this: That, params?: T.MlSetUpgradeModeRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlSetUpgradeModeResponse>
  async setUpgradeMode (this: That, params?: T.MlSetUpgradeModeRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlSetUpgradeModeResponse, unknown>>
  async setUpgradeMode (this: That, params?: T.MlSetUpgradeModeRequest, options?: TransportRequestOptions): Promise<T.MlSetUpgradeModeResponse>
  async setUpgradeMode (this: That, params?: T.MlSetUpgradeModeRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.set_upgrade_mode']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    params = params ?? {}
    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    const method = 'POST'
    const path = '/_ml/set_upgrade_mode'
    const meta: TransportRequestMetadata = {
      name: 'ml.set_upgrade_mode',
      acceptedParams: [
        'enabled',
        'timeout'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Start a data frame analytics job. A data frame analytics job can be started and stopped multiple times throughout its lifecycle. If the destination index does not exist, it is created automatically the first time you start the data frame analytics job. The `index.number_of_shards` and `index.number_of_replicas` settings for the destination index are copied from the source index. If there are multiple source indices, the destination index copies the highest setting values. The mappings for the destination index are also copied from the source indices. If there are any mapping conflicts, the job fails to start. If the destination index exists, it is used as is. You can therefore set up the destination index in advance with custom settings and mappings.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-start-data-frame-analytics | Elasticsearch API documentation}
    */
  async startDataFrameAnalytics (this: That, params: T.MlStartDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlStartDataFrameAnalyticsResponse>
  async startDataFrameAnalytics (this: That, params: T.MlStartDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlStartDataFrameAnalyticsResponse, unknown>>
  async startDataFrameAnalytics (this: That, params: T.MlStartDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<T.MlStartDataFrameAnalyticsResponse>
  async startDataFrameAnalytics (this: That, params: T.MlStartDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.start_data_frame_analytics']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    const method = 'POST'
    const path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}/_start`
    const meta: TransportRequestMetadata = {
      name: 'ml.start_data_frame_analytics',
      pathParts: {
        id: params.id
      },
      acceptedParams: [
        'id',
        'timeout'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Start datafeeds. A datafeed must be started in order to retrieve data from Elasticsearch. A datafeed can be started and stopped multiple times throughout its lifecycle. Before you can start a datafeed, the anomaly detection job must be open. Otherwise, an error occurs. If you restart a stopped datafeed, it continues processing input data from the next millisecond after it was stopped. If new data was indexed for that exact millisecond between stopping and starting, it will be ignored. When Elasticsearch security features are enabled, your datafeed remembers which roles the last user to create or update it had at the time of creation or update and runs the query using those same roles. If you provided secondary authorization headers when you created or updated the datafeed, those credentials are used instead.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-start-datafeed | Elasticsearch API documentation}
    */
  async startDatafeed (this: That, params: T.MlStartDatafeedRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlStartDatafeedResponse>
  async startDatafeed (this: That, params: T.MlStartDatafeedRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlStartDatafeedResponse, unknown>>
  async startDatafeed (this: That, params: T.MlStartDatafeedRequest, options?: TransportRequestOptions): Promise<T.MlStartDatafeedResponse>
  async startDatafeed (this: That, params: T.MlStartDatafeedRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.start_datafeed']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = 'POST'
    const path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}/_start`
    const meta: TransportRequestMetadata = {
      name: 'ml.start_datafeed',
      pathParts: {
        datafeed_id: params.datafeed_id
      },
      acceptedParams: [
        'datafeed_id',
        'end',
        'start',
        'timeout',
        'end',
        'start',
        'timeout'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Start a trained model deployment. It allocates the model to every machine learning node.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-start-trained-model-deployment | Elasticsearch API documentation}
    */
  async startTrainedModelDeployment (this: That, params: T.MlStartTrainedModelDeploymentRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlStartTrainedModelDeploymentResponse>
  async startTrainedModelDeployment (this: That, params: T.MlStartTrainedModelDeploymentRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlStartTrainedModelDeploymentResponse, unknown>>
  async startTrainedModelDeployment (this: That, params: T.MlStartTrainedModelDeploymentRequest, options?: TransportRequestOptions): Promise<T.MlStartTrainedModelDeploymentResponse>
  async startTrainedModelDeployment (this: That, params: T.MlStartTrainedModelDeploymentRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.start_trained_model_deployment']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = 'POST'
    const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/deployment/_start`
    const meta: TransportRequestMetadata = {
      name: 'ml.start_trained_model_deployment',
      pathParts: {
        model_id: params.model_id
      },
      acceptedParams: [
        'model_id',
        'adaptive_allocations',
        'cache_size',
        'deployment_id',
        'number_of_allocations',
        'priority',
        'queue_capacity',
        'threads_per_allocation',
        'timeout',
        'wait_for'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Stop data frame analytics jobs. A data frame analytics job can be started and stopped multiple times throughout its lifecycle.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-stop-data-frame-analytics | Elasticsearch API documentation}
    */
  async stopDataFrameAnalytics (this: That, params: T.MlStopDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlStopDataFrameAnalyticsResponse>
  async stopDataFrameAnalytics (this: That, params: T.MlStopDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlStopDataFrameAnalyticsResponse, unknown>>
  async stopDataFrameAnalytics (this: That, params: T.MlStopDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<T.MlStopDataFrameAnalyticsResponse>
  async stopDataFrameAnalytics (this: That, params: T.MlStopDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.stop_data_frame_analytics']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    const method = 'POST'
    const path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}/_stop`
    const meta: TransportRequestMetadata = {
      name: 'ml.stop_data_frame_analytics',
      pathParts: {
        id: params.id
      },
      acceptedParams: [
        'id',
        'allow_no_match',
        'force',
        'timeout'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Stop datafeeds. A datafeed that is stopped ceases to retrieve data from Elasticsearch. A datafeed can be started and stopped multiple times throughout its lifecycle.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-stop-datafeed | Elasticsearch API documentation}
    */
  async stopDatafeed (this: That, params: T.MlStopDatafeedRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlStopDatafeedResponse>
  async stopDatafeed (this: That, params: T.MlStopDatafeedRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlStopDatafeedResponse, unknown>>
  async stopDatafeed (this: That, params: T.MlStopDatafeedRequest, options?: TransportRequestOptions): Promise<T.MlStopDatafeedResponse>
  async stopDatafeed (this: That, params: T.MlStopDatafeedRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.stop_datafeed']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = 'POST'
    const path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}/_stop`
    const meta: TransportRequestMetadata = {
      name: 'ml.stop_datafeed',
      pathParts: {
        datafeed_id: params.datafeed_id
      },
      acceptedParams: [
        'datafeed_id',
        'allow_no_match',
        'force',
        'timeout',
        'allow_no_match',
        'force',
        'timeout'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Stop a trained model deployment.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-stop-trained-model-deployment | Elasticsearch API documentation}
    */
  async stopTrainedModelDeployment (this: That, params: T.MlStopTrainedModelDeploymentRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlStopTrainedModelDeploymentResponse>
  async stopTrainedModelDeployment (this: That, params: T.MlStopTrainedModelDeploymentRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlStopTrainedModelDeploymentResponse, unknown>>
  async stopTrainedModelDeployment (this: That, params: T.MlStopTrainedModelDeploymentRequest, options?: TransportRequestOptions): Promise<T.MlStopTrainedModelDeploymentResponse>
  async stopTrainedModelDeployment (this: That, params: T.MlStopTrainedModelDeploymentRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.stop_trained_model_deployment']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    const method = 'POST'
    const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/deployment/_stop`
    const meta: TransportRequestMetadata = {
      name: 'ml.stop_trained_model_deployment',
      pathParts: {
        model_id: params.model_id
      },
      acceptedParams: [
        'model_id',
        'allow_no_match',
        'force'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Update a data frame analytics job.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-update-data-frame-analytics | Elasticsearch API documentation}
    */
  async updateDataFrameAnalytics (this: That, params: T.MlUpdateDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlUpdateDataFrameAnalyticsResponse>
  async updateDataFrameAnalytics (this: That, params: T.MlUpdateDataFrameAnalyticsRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlUpdateDataFrameAnalyticsResponse, unknown>>
  async updateDataFrameAnalytics (this: That, params: T.MlUpdateDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<T.MlUpdateDataFrameAnalyticsResponse>
  async updateDataFrameAnalytics (this: That, params: T.MlUpdateDataFrameAnalyticsRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.update_data_frame_analytics']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = 'POST'
    const path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}/_update`
    const meta: TransportRequestMetadata = {
      name: 'ml.update_data_frame_analytics',
      pathParts: {
        id: params.id
      },
      acceptedParams: [
        'id',
        'description',
        'model_memory_limit',
        'max_num_threads',
        'allow_lazy_start'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Update a datafeed. You must stop and start the datafeed for the changes to be applied. When Elasticsearch security features are enabled, your datafeed remembers which roles the user who updated it had at the time of the update and runs the query using those same roles. If you provide secondary authorization headers, those credentials are used instead.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-update-datafeed | Elasticsearch API documentation}
    */
  async updateDatafeed (this: That, params: T.MlUpdateDatafeedRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlUpdateDatafeedResponse>
  async updateDatafeed (this: That, params: T.MlUpdateDatafeedRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlUpdateDatafeedResponse, unknown>>
  async updateDatafeed (this: That, params: T.MlUpdateDatafeedRequest, options?: TransportRequestOptions): Promise<T.MlUpdateDatafeedResponse>
  async updateDatafeed (this: That, params: T.MlUpdateDatafeedRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.update_datafeed']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = 'POST'
    const path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}/_update`
    const meta: TransportRequestMetadata = {
      name: 'ml.update_datafeed',
      pathParts: {
        datafeed_id: params.datafeed_id
      },
      acceptedParams: [
        'datafeed_id',
        'aggregations',
        'chunking_config',
        'delayed_data_check_config',
        'frequency',
        'indices',
        'indexes',
        'indices_options',
        'job_id',
        'max_empty_searches',
        'query',
        'query_delay',
        'runtime_mappings',
        'script_fields',
        'scroll_size',
        'allow_no_indices',
        'expand_wildcards',
        'ignore_throttled',
        'ignore_unavailable'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Update a filter. Updates the description of a filter, adds items, or removes items from the list.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-update-filter | Elasticsearch API documentation}
    */
  async updateFilter (this: That, params: T.MlUpdateFilterRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlUpdateFilterResponse>
  async updateFilter (this: That, params: T.MlUpdateFilterRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlUpdateFilterResponse, unknown>>
  async updateFilter (this: That, params: T.MlUpdateFilterRequest, options?: TransportRequestOptions): Promise<T.MlUpdateFilterResponse>
  async updateFilter (this: That, params: T.MlUpdateFilterRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.update_filter']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = 'POST'
    const path = `/_ml/filters/${encodeURIComponent(params.filter_id.toString())}/_update`
    const meta: TransportRequestMetadata = {
      name: 'ml.update_filter',
      pathParts: {
        filter_id: params.filter_id
      },
      acceptedParams: [
        'filter_id',
        'add_items',
        'description',
        'remove_items'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Update an anomaly detection job. Updates certain properties of an anomaly detection job.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-update-job | Elasticsearch API documentation}
    */
  async updateJob (this: That, params: T.MlUpdateJobRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlUpdateJobResponse>
  async updateJob (this: That, params: T.MlUpdateJobRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlUpdateJobResponse, unknown>>
  async updateJob (this: That, params: T.MlUpdateJobRequest, options?: TransportRequestOptions): Promise<T.MlUpdateJobResponse>
  async updateJob (this: That, params: T.MlUpdateJobRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.update_job']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = 'POST'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_update`
    const meta: TransportRequestMetadata = {
      name: 'ml.update_job',
      pathParts: {
        job_id: params.job_id
      },
      acceptedParams: [
        'job_id',
        'allow_lazy_open',
        'analysis_limits',
        'background_persist_interval',
        'custom_settings',
        'categorization_filters',
        'description',
        'model_plot_config',
        'model_prune_window',
        'daily_model_snapshot_retention_after_days',
        'model_snapshot_retention_days',
        'renormalization_window_days',
        'results_retention_days',
        'groups',
        'detectors',
        'per_partition_categorization'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Update a snapshot. Updates certain properties of a snapshot.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-update-model-snapshot | Elasticsearch API documentation}
    */
  async updateModelSnapshot (this: That, params: T.MlUpdateModelSnapshotRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlUpdateModelSnapshotResponse>
  async updateModelSnapshot (this: That, params: T.MlUpdateModelSnapshotRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlUpdateModelSnapshotResponse, unknown>>
  async updateModelSnapshot (this: That, params: T.MlUpdateModelSnapshotRequest, options?: TransportRequestOptions): Promise<T.MlUpdateModelSnapshotResponse>
  async updateModelSnapshot (this: That, params: T.MlUpdateModelSnapshotRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.update_model_snapshot']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = 'POST'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots/${encodeURIComponent(params.snapshot_id.toString())}/_update`
    const meta: TransportRequestMetadata = {
      name: 'ml.update_model_snapshot',
      pathParts: {
        job_id: params.job_id,
        snapshot_id: params.snapshot_id
      },
      acceptedParams: [
        'job_id',
        'snapshot_id',
        'description',
        'retain'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Update a trained model deployment.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-update-trained-model-deployment | Elasticsearch API documentation}
    */
  async updateTrainedModelDeployment (this: That, params: T.MlUpdateTrainedModelDeploymentRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlUpdateTrainedModelDeploymentResponse>
  async updateTrainedModelDeployment (this: That, params: T.MlUpdateTrainedModelDeploymentRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlUpdateTrainedModelDeploymentResponse, unknown>>
  async updateTrainedModelDeployment (this: That, params: T.MlUpdateTrainedModelDeploymentRequest, options?: TransportRequestOptions): Promise<T.MlUpdateTrainedModelDeploymentResponse>
  async updateTrainedModelDeployment (this: That, params: T.MlUpdateTrainedModelDeploymentRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.update_trained_model_deployment']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = 'POST'
    const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/deployment/_update`
    const meta: TransportRequestMetadata = {
      name: 'ml.update_trained_model_deployment',
      pathParts: {
        model_id: params.model_id
      },
      acceptedParams: [
        'model_id',
        'number_of_allocations',
        'adaptive_allocations',
        'number_of_allocations'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Upgrade a snapshot. Upgrade an anomaly detection model snapshot to the latest major version. Over time, older snapshot formats are deprecated and removed. Anomaly detection jobs support only snapshots that are from the current or previous major version. This API provides a means to upgrade a snapshot to the current major version. This aids in preparing the cluster for an upgrade to the next major version. Only one snapshot per anomaly detection job can be upgraded at a time and the upgraded snapshot cannot be the current snapshot of the anomaly detection job.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-ml-upgrade-job-snapshot | Elasticsearch API documentation}
    */
  async upgradeJobSnapshot (this: That, params: T.MlUpgradeJobSnapshotRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlUpgradeJobSnapshotResponse>
  async upgradeJobSnapshot (this: That, params: T.MlUpgradeJobSnapshotRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlUpgradeJobSnapshotResponse, unknown>>
  async upgradeJobSnapshot (this: That, params: T.MlUpgradeJobSnapshotRequest, options?: TransportRequestOptions): Promise<T.MlUpgradeJobSnapshotResponse>
  async upgradeJobSnapshot (this: That, params: T.MlUpgradeJobSnapshotRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath
    } = this[kAcceptedParams]['ml.upgrade_job_snapshot']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    for (const key in params) {
      if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        // @ts-expect-error
        querystring[key] = params[key]
      }
    }

    const method = 'POST'
    const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots/${encodeURIComponent(params.snapshot_id.toString())}/_upgrade`
    const meta: TransportRequestMetadata = {
      name: 'ml.upgrade_job_snapshot',
      pathParts: {
        job_id: params.job_id,
        snapshot_id: params.snapshot_id
      },
      acceptedParams: [
        'job_id',
        'snapshot_id',
        'wait_for_completion',
        'timeout'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Validate an anomaly detection job.
    * @see {@link https://www.elastic.co/guide/en/machine-learning/9.2/ml-jobs.html | Elasticsearch API documentation}
    */
  async validate (this: That, params?: T.MlValidateRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlValidateResponse>
  async validate (this: That, params?: T.MlValidateRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlValidateResponse, unknown>>
  async validate (this: That, params?: T.MlValidateRequest, options?: TransportRequestOptions): Promise<T.MlValidateResponse>
  async validate (this: That, params?: T.MlValidateRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.validate']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: Record<string, any> | string | undefined
    const userBody = params?.body
    if (userBody != null) {
      if (typeof userBody === 'string') {
        body = userBody
      } else {
        body = { ...userBody }
      }
    }

    params = params ?? {}
    for (const key in params) {
      if (acceptedBody.includes(key)) {
        body = body ?? {}
        // @ts-expect-error
        body[key] = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = 'POST'
    const path = '/_ml/anomaly_detectors/_validate'
    const meta: TransportRequestMetadata = {
      name: 'ml.validate',
      acceptedParams: [
        'job_id',
        'analysis_config',
        'analysis_limits',
        'data_description',
        'description',
        'model_plot',
        'model_snapshot_id',
        'model_snapshot_retention_days',
        'results_index_name'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }

  /**
    * Validate an anomaly detection job.
    * @see {@link https://www.elastic.co/docs/api/doc/elasticsearch | Elasticsearch API documentation}
    */
  async validateDetector (this: That, params: T.MlValidateDetectorRequest, options?: TransportRequestOptionsWithOutMeta): Promise<T.MlValidateDetectorResponse>
  async validateDetector (this: That, params: T.MlValidateDetectorRequest, options?: TransportRequestOptionsWithMeta): Promise<TransportResult<T.MlValidateDetectorResponse, unknown>>
  async validateDetector (this: That, params: T.MlValidateDetectorRequest, options?: TransportRequestOptions): Promise<T.MlValidateDetectorResponse>
  async validateDetector (this: That, params: T.MlValidateDetectorRequest, options?: TransportRequestOptions): Promise<any> {
    const {
      path: acceptedPath,
      body: acceptedBody,
      query: acceptedQuery
    } = this[kAcceptedParams]['ml.validate_detector']

    const userQuery = params?.querystring
    const querystring: Record<string, any> = userQuery != null ? { ...userQuery } : {}

    let body: any = params.body ?? undefined
    for (const key in params) {
      if (acceptedBody.includes(key)) {
        // @ts-expect-error
        body = params[key]
      } else if (acceptedPath.includes(key)) {
        continue
      } else if (key !== 'body' && key !== 'querystring') {
        if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
          // @ts-expect-error
          querystring[key] = params[key]
        } else {
          body = body ?? {}
          // @ts-expect-error
          body[key] = params[key]
        }
      }
    }

    const method = 'POST'
    const path = '/_ml/anomaly_detectors/_validate/detector'
    const meta: TransportRequestMetadata = {
      name: 'ml.validate_detector',
      acceptedParams: [
        'detector'
      ]
    }
    return await this.transport.request({ path, method, querystring, body, meta }, options)
  }
}
